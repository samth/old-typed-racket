========================================================================
>>> Introduction to Typed Scheme

* Why Types?

* Why Typed Scheme?

* What's Different about Typed Scheme?

* Some Examples of Typed Scheme for 660 Programs


========================================================================






* General plan for how the course will go.

* Administrative stuff.  (Most of the stuff from the web page.)
  >>> http://www.ccs.neu.edu/course/csu660/ <<<

* Why should we care about programming languages?  (Any examples of big
  projects *without* a little language?)

========================================================================

* What defines a language?
  - syntax
  - semantics
  - libraries
  - idioms

* How important is each of these?

  - libraries give you the run-time support, not an important part of
    the language itself.  (BTW, the line between what is a library and
    what is part of a language is less obvious than it seems.)

  - idioms originate from both language design and culture.  They are
    often misleading.  For example, something JavaScript programmers
    will often write:

      if (isExplorer)
        document.onmousemove = explorer_move;
      else
        document.onmousemove = mozilla_move;

    or

      if (isExplorer)
        document.onmousemove = function () { ... };
      else
        document.onmousemove = function () { ... };

    or

      document.onmousemove =
        isExplorer ? function () { ... }
                   : function () { ... };

    How many JavaScript programmers will know what this does:

      function foo(n) {
        return function(m) { return m+n; }
      }

  - Compare: a[25]+5                   (Java: exception)
             (+ (vector-ref a 25) 5)   (Scheme: exception)
             a[25]+5                   (JavaScript: NaN or undefined)
             a[25]+5                   (Python: exception)
             $a[25]+5                  (Perl: 5)
             a[25]+5                   (C: <<<BOOM>>>)
    -> syntax is mostly in the cosmetics department.
    -> semantics is the real thing.

* How should we talk about semantics?

  - A few well-known formalisms for semantics.

  - We will use programs to explain semantics: the best explanation *is*
    a program.

  - We will use Scheme for many reasons (syntax, functional, simple,
    formal, environment).

  - Ignore possible philosophical issues with circularity (but be aware
    of them).  (Actually, they are solved: Scheme has a formal
    explanation that can be taken as a translation from Scheme to logic,
    which means that things that we write can be translated to logic).

========================================================================

* General diagram of the applications etc:

  - MzScheme - a Scheme implementation;

  - MrEd - a C application that uses wxWindows for a portable GUI
    environment; with some stuff written in Scheme;

  - DrScheme - a MrEd application (written only in Scheme);

  Show examples where things are and running them.

* Documentation:

  - Scheme ultimate doc - R5RS;

  - MzScheme;

  - More PLT documents - MrEd, DrScheme etc.

========================================================================

Side-note:

E.W. DIJKSTRA

"Goto Statement Considered Harmful."

This paper tries to convince us that the well-known goto statement
should be eliminated from our programming languages or, at least (since
I don't think that it will ever be eliminated), that programmers should
not use it. It is not clear what should replace it. The paper doesn't
explain to us what would be the use of the "if" statement without a
"goto" to redirect the flow of execution: Should all our postconditions
consist of a single statement, or should we only use the arithmetic
"if," which doesn't contain the offensive "goto"?

And how will one deal with the case in which, having reached the end of
an alternative, the program needs to continue the execution somewhere
else?

The author is a proponent of the so-called "structured programming"
style, in which, if I get it right, gotos are replaced by
indentation. Structured programming is a nice academic exercise, which
works well for small examples, but I doubt that any real-world program
will ever be written in such a style. More than 10 years of industrial
experience with Fortran have proved conclusively to everybody concerned
that, in the real world, the goto is useful and necessary: its presence
might cause some inconveniences in debugging, but it is a de facto
standard and we must live with it. It will take more than the academic
elucubrations of a purist to remove it from our languages.

Publishing this would waste valuable paper: Should it be published, I am
as sure it will go uncited and unnoticed as I am confident that, 30
years from now, the goto will still be alive and well and used as widely
as it is today.

Confidential comments to the editor: The author should withdraw the
paper and submit it someplace where it will not be peer reviewed. A
letter to the editor would be a perfect choice: Nobody will notice it
there!

========================================================================
>>> Introduction to Scheme

Scheme syntax...

Reminder - the parens can be compared to C parens - they mean apply
something - this is the reason why (+ (1) (2)) won't work - if you use C
syntax that is "+(1(), 2())" but "1" isn't a function so "1()" is an
error.

An important difference between _syntax_ and _semantics_ - a good way to
think about this is the difference between the string "42" stored in a
file somewhere (two ASCII values), and the number "42" stored in memory
(in some representation).  You could also continue with the above
example - there is nothing wrong with "murder" - it's just a word, but
murder is something you'll go to jail for.  The evaluation function that
Scheme uses is actually a function that takes a piece of syntax and
returns (or executes) its semantics.

========================================================================

`define' is used for definitions, do not use them for changing values,
for example, you should not try to (define x (+ x 1)): this will not
work in the early language levels, and will lead to penalty if used
later.

========================================================================

There are two boolean values built in to Scheme - `#t' (true) and `#f'
(false).  They can be used in `if' statements, for example:

  (if (< 2 3) 10 20)  -->  10

because (< 2 3) evaluates to #t.  As a matter of fact, *any* value
except for #f is considered to be true, so:

  (if 0 1 2)  -->  1

  (if "false" 1 2)  -->  1

========================================================================

Note: Scheme is a _functional_ language - so _everything_ has a value.

This makes the expression

  (if test consequent)

have no meaning when "test" evaluates to #f.  This is unlike Pascal/C
where statements _do_ something (side effect) like printing or an
assignment - here an if statement with no alternate part will just "do
nothing" if the test is false...  Scheme, however, must return some
value - our implementation could decide on simply returning #f as the
value of

  (if #f something)

but this is something you shouldn't rely on (as all other
"it-will-probably-do-this" things), and, in MzScheme it returns
something different.

In any case, in the early language levels, the condition expression must
be a boolean, and you cannot use an `if' with one branch only.

========================================================================

Well, *almost* everything is a value...

There are certain things that are part of Scheme's syntax -- for example
`if' and `define' are special forms, they do not have a value!  More
about this shortly.

========================================================================

`cond' is used for a sequence of `if...else if...else if...else'.  The
problem is that nested `if's are inconvenient.  For example,

  (define (digit-num n)
    (if (<= n 9)
      1
      (if (<= n 99)
        2
        (if (<= n 999)
          3
          (if (<= n 9999)
            4
            "a lot")))))

In C/Java/Whatever, you'd write:

  function digit_num(n) {
    if (n <= 9)         return 1;
    else if (n <= 99)   return 2;
    else if (n <= 999)  return 3;
    else if (n <= 9999) return 4;
    else return "a lot";
  }

(Side question: why isn't there a `return' statement in Scheme?)

But trying to force Scheme code to look similar:

  (define (digit-num n)
    (if (<= n 9)
      1
    (if (<= n 99)
      2
    (if (<= n 999)
      3
    (if (<= n 9999)
      4
      "a lot")))))

is more than just bad taste -- the indentation rules are there for a
reason, the main one is that you can see the structure of your program
at a quick glance, and this is no longer true in the above code.  (Such
code will be penalized!)

So, instead of this, we can use Scheme's `cond' statement, like this:

  (define (digit-num n)
    (cond [(<= n 9)    1]
          [(<= n 99)   2]
          [(<= n 999)  3]
          [(<= n 9999) 4]
          [else        "a lot"]))

Note that `else' is a keyword that is used by the `cond' form.  Also
note that square brackets are read by DrScheme like round parens, it
will only make sure that the paren pairs match.  We use this to make
code more readable -- specifically, there is a major difference between
the above use of "[]" from the conventional use of "()".  Can you see
what it is?

The general structure of a `cond':

  (cond [test-1 expr-1]
        [test-2 expr-2]
        ...
        [test-n expr-n]
        [else   else-expr])

========================================================================

Example for using an if statement, and a recursive function:

  (define (fact n)
    (if (zero? n)
      1
      (* n (fact (- n 1)))))

Use this to show the different tools, esp:
* special objects that *cannot* be used
* syntax-checker
* stepper
* submission tool (installing, registering and submitting)

An example of converting it to tail recursive form:

  (define (helper n acc)
    (if (zero? n)
      acc
      (helper (- n 1) (* acc n))))
  (define (fact n)
    (helper n 1))

========================================================================

Additional notes about homework submissions:

* Begin every function with clear documentation: a purpose of statement
  and its type.

* Document the function when needed, and according to the guidelines
  above and in the style guide.

* After the function, always have a few test cases -- they should cover
  your complete code (make sure to include possible corner cases).

========================================================================
>>> Introduction to Scheme: Lists & Recursion

Lists: a fundamental Scheme data type.

A list is defined as either:

1. the empty list (`empty' or `null'),

2. a pair (`cons' cell) of anything and a list.

As simple as this may be, it gives us precise *formal* rules to prove
that something is a list.

* Why is there a "the" in the first rule?

Examples:

  null
  (cons 1 null)
  (cons 1 (cons 2 (cons 3 null)))
  (list 1 2 3) ; a more convenient function to get the above

List operations -- predicates:

  null? ; true only for the empty list
  pair? ; true for any cons cell
  list? ; this can be defined using the above

Why can't we define `list?' as

  (define (list? x)
    (or (null? x) (pair? x)))

The difference between the above definition and the proper one can be
observed in the full Scheme language, not in the student languages.

List operations -- destructors for pairs (cons cells):

  first
  rest

Traditionally called `car', `cdr'.

Also, any `c<x>r' combination for <x> that is made of up to four `a's
and `d's -- we will probably not use much more than `cadr', `caddr' etc.

========================================================================

Example for recursive function involving lists:

  (define (list-length list)
    (if (null? list)
      0
      (+ 1 (list-length (cdr list)))))

Use different tools, esp:
* syntax-checker
* stepper

How come we could use `list' as an argument -- use the syntax checker

  (define (list-length-helper list len)
    (if (null? list)
      len
      (list-length-helper (cdr list) (+ len 1))))
  (define (list-length list)
    (list-length-helper list 0))

Main idea: lists are a recursive structure, so functions that operate on
lists should be recursive functions that follow the recursive definition
of lists.

Another example for list function -- summing a list of numbers

  (define (sum-list l)
    (if (null? l)
      0
      (+ (car l) (sum-list (cdr l)))))

Also show how to implement `rcons', using this guideline.

========================================================================

More examples:

Define `reverse' -- solve the problem using `rcons'.

`rcons' can be generalized into something very useful: `append'.

* How would we use `append' instead of `rcons'?

* How much time will this take?  Does it matter if we use `append' or
  `rcons'?

Redefine `reverse' using tail recursion.

* Is the result more complex?  (Yes, but not too bad because it collects
  the elements in reverse.)

========================================================================

When you have some common value that you need to use in several places,
it is bad to duplicate it.  For example:

  (define (how-many a b c)
    (cond [(> (* b b) (* 4 a c)) 2]
          [(= (* b b) (* 4 a c)) 1]
          [(< (* b b) (* 4 a c)) 0]))

What's bad about it?

* It's longer than necessary, which will eventually make your code less
  readable.

* It's slower -- by the time you reach the last case, you have evaluated
  the two sequences three times.

* It's more prone to bugs -- the above code is short enough, but what if
  it was longer so you don't see the three occurrences on the same
  page?  Will you remember to fix all places when you debug the code
  months after it was written?

In general, the ability to use names is probably the most fundamental
concept in computer science -- the fact that makes computer programs
what they are.

We already have a facility to name values: function arguments.  We could
split the above function into two like this:

  (define (how-many-helper b^2 4ac) ; note the identifier name!
    (cond [(> b^2 4ac) 2]
          [(= b^2 4ac) 1]
          [(< b^2 4ac) 0]))

  (define (how-many a b c)
    (how-many-helper (* b b) (* 4 a c)))

But instead of the awkward solution of coming up with a new function
just for its names, we have a facility to bind local names -- `let'.  In
general, the syntax for a `let' special form is

  (let ([id expr] ...) expr)

For example,

  (let ([x 1] [y 2]) (+ x y))

But note that the bindings are done "in parallel", for example, try
this:

  (let ([x 1] [y 2])
    (let ([x y] [y x])
      (list x y)))

Using this for the above problem:

  (define (how-many a b c)
    (let ([b^2 (* b b)]
          [4ac (* 4 a c)])
      (cond [(> b^2 4ac) 2]
            [(= b^2 4ac) 1]
            [(< b^2 4ac) 0])))

========================================================================

Some notes on writing code
(also see the style-guide in the handouts section)

*** Code quality will be graded to in this course!

* Use abstractions whenever possible, as said above.  This is bad:

  (define (how-many a b c)
    (cond
      ((> (* b b) (* 4 a c)) 2)
      ((= (* b b) (* 4 a c)) 1)
      ((< (* b b) (* 4 a c)) 0)))
  (define (what-kind a b c)
    (cond
      ((= a 0) 'degenerate)
      ((> (* b b) (* 4 a c)) 'two)
      ((= (* b b) (* 4 a c)) 'one)
      ((< (* b b) (* 4 a c)) 'none)))

* But don't over abstract: (define one 'one) (define two 'two)

* Always do test cases (show coverage tool), you might want to comment
  them, but you should always make sure your code works.

* Do not under-document, but also don't over-document.

* INDENTATION!  (Let DrScheme decide for you, and get used to its rules)
  --> This is part of the culture that was mentioned last time, but it's
      done this way for good reason: decades of programming experience
      have shown this to be the most readable format.

* As a general rule, `if' should be either all on one line, or the
  condition on the first and each consequent on a separate line.
  Similarly for `define' -- either all on one line or a newline after
  the object that is being define (either an identifier or a an
  identifier with arguments).

* Another general rule: you should never have white space after an
  open-paren, or before a close paren (white space includes newlines).
  Also, before an open paren there should be either another open paren
  or white space, and the same goes for after a closing paren.

* Use the tools that are available to you: for example, use `cond'
  instead of nested ifs (definitely do not force the indentation to make
  a nested `if' look like its C counterpart -- remember to let DrScheme
  indent for you).

  Another example -- do not use `(+ 1 (+ 2 3))' instead of `(+ 1 2 3)'
  (this might be needed in *extremely* rare situations, only when you
  know your calculus and have extensive knowledge about round-off
  errors).

  Another example -- do not use `(cons 1 (cons 2 (cons 3 null)))'
  instead of `(list 1 2 3)'.

  Also -- don't write things like:

    (if x #t y)   --same-as-->  (or x y)
    (if x y #f)   --same-as-->  (and x y)
    (if x #f #t)  --same-as-->  (not x)

* Use these as examples for many of these issues:

  (define (interest x)
    (* x (cond
      [(and (> x 0) (<= x 1000)) 0.04]
      [(and (> x 1000) (<= x 5000)) 0.045]
      [else 0.05])))

  (define (how-many a b c)
    (cond ((> (* b b) (* (* 4 a) c))
           2)
          ((< (* b b) (* (* 4 a) c))
           0)
          (else
           1)))

  (define (what-kind a b c)
    (if (equal? a 0) 'degenerate
        (if (equal? (how-many a b c) 0) 'zero
            (if (equal? (how-many a b c) 1) 'one
                'two)
            )
        )
    )

  (define (interest deposit)
    (cond
    [(< deposit 0) "invalid deposit"]
    [(and (>= deposit 0) (<= deposit 1000)) (* deposit 1.04) ]
    [(and (> deposit 1000) (<= deposit 5000)) (* deposit 1.045)]
    [(> deposit 5000) (* deposit 1.05)]))

  (define (interest deposit)
    (if (< deposit 1001) (* 0.04 deposit)
      (if (< deposit 5001) (* 0.045 deposit)
      (* 0.05 deposit))))

  (define (what-kind a b c) (cond ((= 0 a) 'degenerate)
                            (else (cond ((> (* b b)(*(* 4 a) c)) 'two)
                                 (else (cond ((= (* b b)(*(* 4 a) c)) 'one)
                                 (else 'none)))))));

========================================================================

An important "discovery" in computer science is that we *don't* need
names for every intermediate sub-expression -- for example, in almost
any language we can write the equivalent of:

  s = (-b + sqrt(b^2 - 4*a*c)) / 2a

instead of

  x = b * b
  y = 4 * a
  y = y * c
  x = x - y
  x = sqrt(x)
  y = -b
  x = y + x
  y = 2 * a
  s = x / y

Such languages are put in contrast to assembly languages, and were all
put under the generic label of "high level languages".

(Here's an interesting idea -- why not do the same for function values?)

========================================================================

The fact that in Scheme we can use functions as values is very useful in
Scheme -- for example, `map', `foldl' & `foldr', many more.

Example:

  ;;; every?: (A -> bool) (list-of A) -> bool
  ;;; Returns false if any element of lst fails the given pred, true if
  ;;; all pass pred.
  (define (every? pred lst)
    (or (null? lst)
        (and (pred (car lst))
             (every? pred (cdr lst)))))

========================================================================

Types can become interesting when dealing with higher-order functions.
For example, `map' receives a function and a list of some type, and
applies the function over this list to accumulate its output, so its
type is:

  ;; map : (A -> B) (list-of A) -> (list-of B)

Actually, `map' can use more than a single list, it will apply the
function on the first element in all lists, then the second and so on.
So the type of `map' with two lists can be described as:

  ;; map : (A B -> C) (list-of A) (list-of B) -> (list-of C)

Here's a hairy example -- what is the type of this function:

  (define (foo x y)
    (map map x y))

Begin by what we know -- both `map's, call them `map1' and `map2', have
the double- and single-list types of `map' respectively, here they are,
with different names for types:

  map1 : (A B -> C) (list-of A) (list-of B) -> (list-of C)

  map2 : (X -> Y) (list-of X) -> (list-of Y)

Now, we know that `map2' is the first argument to `map1', so the type of
`map1's first argument should be the type of `map2':

  (A B -> C) = (X -> Y) (list-of X) -> (list-of Y)

From here we can conclude that

  A = (X -> Y)

  B = (list-of X)

  C = (list-of Y)

If we use these equations in `map1's type, we get:

  map1 : ((X -> Y) (list-of X) -> (list-of Y))
         (list-of (X -> Y))
         (list-of (list-of X))
         -> (list-of (list-of Y))

Now, `foo's two arguments are the 2nd and 3rd arguments of `map1', and
its result is `map1's result, so we can now write the type of `foo':

  ;; foo : (list-of (X -> Y))
  ;;       (list-of (list-of X))
  ;;       -> (list-of (list-of Y))
  (define (foo x y)
    (map map x y))

This should help you understand why, for example, this will cause a type
error:

  (foo (list add1 sub1 add1) (list 1 2 3))

and why this is value:

  (foo (list add1 sub1 add1) (map list (list 1 2 3)))

========================================================================

Quick overview:
* map (+ impl)
* append, reverse -- run-time!

========================================================================
>>> BNF, Grammars

Getting back to the theme of the course: we want to investigate
programming languages, and we want to do that *using* a programming
language.

The first thing when we design a language is to specify the language.
For this we use BNF (Backus-Naur Form).  For example, here is the
definition of a simple arithmetic language:

  <AE> ::= <num>
         | <AE> + <AE>
         | <AE> - <AE>

Explain the different parts.  Specifically, this is a mixture of
low-level (concrete) syntax definition with parsing.

We use this to derive expressions in some language.  We start with
<AE>, which should be on of these:
* a number <num>
* <num>, the text "+", and another <num>
* the same but with "-"

<num> is a terminal: when we reach it in the derivation, we're done.
<AE> is a non-terminal: when we reach it, we have to continue with one
of the options.  It should be clear that the "+" and the "-" are things
we expect to find in the input -- because they are not wrapped in <>s.

We could specify what <num> is:

  <num> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
          | <num> <num>

But we don't -- why?  Because in Scheme we have numbers as primitives
and we want to use Scheme to implement our languages.  This makes life a
lot easier, and we get free stuff like floats, rationals etc.

For example, we can use this to prove that "1-2+3" is a valid <AE>
expression:

  <AE>
  <AE> + <AE>         ; (2)
  <AE> + <num>        ; (1)
  <AE> - <AE> + <num> ; (3)
  <AE> - <AE> + 3     ; (num)
  <num> - <AE> + 3    ; (1)
  <num> - <num> + 3   ; (1)
  1 - <num> + 3       ; (num)
  1 - 2 + 3           ; (num)

This would be one way of doing this.  Instead, we can can visualize the
derivation using a tree, with the rules used at every node.  (Leave this
on -- later show that this removes some confusion but not all.)

These specifications suffer from being ambiguous: an expression can be
derived in multiple ways.  Even the little syntax for a number is
ambiguous -- a number like "123" can be derived in two ways that result
in trees that look different.  This ambiguity is not a "real" problem
now, but it will become one very soon.  We want to get rid of this
ambiguity, so that there is a single (= deterministic) way to derive all
expressions.

There is a standard way to resolve that -- we add another non-terminal
to the definition, and make it so that each rule can continue to exactly
one of its alternatives.  For example, this is what we can do with
numbers:

  <num>   ::= <digit> | <digit> <num>

  <digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

Similar solutions can be applied to the <AE> BNF -- we either restrict
the way derivations can happen or we come up with new non-terminals to
force a deterministic derivation trees.

As an example of restricting derivations, we look at the current
grammar:

  <AE> ::= <num>
         | <AE> + <AE>
         | <AE> - <AE>

and instead of allowing an <AE> on both sides of the operation, we force
one to be a number:

  <AE> ::= <num>
         | <num> + <AE>
         | <num> - <AE>

Now there is a single way to derive any expression, and it is always
associating operations to the right: an expression like "1+2+3" can only
be derived as "1+(2+3)".  To change this to left-association, we would
use this:

  <AE> ::= <num>
         | <AE> + <num>
         | <AE> - <num>

But what if we want to force precedence?  Say that our AE syntax has
addition and multiplication:

  <AE> ::= <num>
         | <AE> + <AE>
         | <AE> * <AE>

We can do that same thing as above and add new non-terminals -- say one
for "factors":

  <AE>  ::= <num>
          | <AE> + <AE>
          | <fac>

  <fac> ::= <num>
          | <fac> * <fac>

Now we must parse any AE expression as additions of multiplications (or
numbers).  First, note that if <AE> goes to <fac> and that goes to
<num>, then there is no need for an <AE> to go to a <num>, so this is
the same syntax:

  <AE>  ::= <AE> + <AE>
          | <fac>

  <fac> ::= <num>
          | <fac> * <fac>

Now, if we want to still be able to multiply additions, we can force
them to appear in parentheses:

  <AE>  ::= <AE> + <AE>
          | <fac>

  <fac> ::= <num>
          | <fac> * <fac>
          | ( <AE> )

Next, note that AE is still ambiguous about additions, which can be
fixed by forcing the left hand side of an addition to be a factor:

  <AE>  ::= <fac> + <AE>
          | <fac>

  <fac> ::= <num>
          | <fac> * <fac>
          | ( <AE> )

We still have an ambiguity for multiplications, so we do the same thing
and add another non-terminal for "atoms":

  <AE>   ::= <fac> + <AE>
           | <fac>

  <fac>  ::= <atom> * <fac>
           | <atom>

  <atom> ::= <number>
           | ( <AE> )

And you can try to derive several expressions to be convinced that
derivation is always deterministic now.

But as you can see, this is exactly the cosmetics that we want to avoid
-- it will lead us to things that might be interesting, but unrelated to
the principles behind programming languages.  It will also become much
much worse when we have a real language rather such a tiny one.

Is there a good solution?  -- It is right in our face: do what Scheme
does -- always use fully parenthesized expressions:

  <AE> ::= <num>
         | ( <AE> + <AE> )
         | ( <AE> - <AE> )

But in Scheme *everything* has a value -- including those `+'s and `-'s,
which makes this extremely convenient with future operations that might
have either more or less arguments than 2.  In our toy language we will
do this for now, but later we will want to have something more powerful.
To get prepared for that, we simplify this further -- put the operator
in the first place and the arguments follow, all separated by white
spaces:

  <AE> ::= <num>
         | ( + <AE> <AE> )
         | ( - <AE> <AE> )

In a sense, Scheme code is written in a form of already-parsed syntax...

========================================================================
>>> Simple Parsing

Implementing a "parser"

Unrelated to what the syntax actually looks like, we want to parse it as
soon as possible -- converting the concrete syntax to an abstract syntax
tree.

No matter how we write our syntax:
- 3+4     (infix),
- 3 4 +   (postfix),
- +(3,4)  (prefix with args in parens),
- (+ 3 4) (parenthesized prefix),

we always mean the same abstract thing -- adding the number 3 and the
number 4.  The essence of this is basically a tree structure with an
addition operation as the root and two leaves holding the two numerals.

With the right data definition, we can describe this in Scheme as the
expression

  (Add (Num 3) (Num 4))

Similarly, the expression

  (3-4)+7

will be described in Scheme as the expression:

  (Add (Sub (Num 3) (Num 4)) (Num 7))

Important note: "expression" was used in two *different* ways in the
above -- each way corresponds to a different language.

To define the data type and the necessary constructors we will use this:

  (define-type AE
    [Num (n number?)]
    [Add (lhs AE?) (rhs AE?)]
    [Sub (lhs AE?) (rhs AE?)])

* Note -- scheme follows the tradition of Lisp which makes syntax issues
  almost negligible -- the language we use is almost as if we are using
  the parse tree directly.  Actually, it is a very simple syntax for
  parse trees, one that makes parsing extremely easy.

  (This has an interesting historical reason...  Some Lisp history --
  M-expressions vs. S-expressions, and the fact that we write code that
  is isomorphic to an AST.  Later we will see some of the advantages
  that we get by doing this.)

To make things at a very simple level, we will use the above fact
through a double-level approach:
* we first "parse" our language into an intermediate representation -- a
  Scheme list -- this is mostly done by a modified version of Scheme's
  `read' that uses curly braces "{}"s instead of round parens "()"s,
* then we write our own `parse' function that will parse the resulting
  list into an instance of the AE type -- an abstract syntax tree (AST).

This is achieved by the following simple recursive function:

  ;; parse-sexpr : s-expr -> AE
  ;; to convert s-expressions into AEs
  (define (parse-sexpr sexpr)
    (cond [(number? sexpr) (Num sexpr)]
          [(and (list? sexpr) (= 3 (length sexpr)))
           (let ([make-node
                  (match (first sexpr)
                    ['+ Add]
                    ['- Sub]
                    [else (error 'parse-sexpr "don't know about ~s"
                                 (first sexpr))])])
             (make-node (parse-sexpr (second sexpr))
                        (parse-sexpr (third sexpr))))]
          [else (error 'parse-sexpr "bad syntax in ~s" sexpr)]))

This function is pretty simple, but as our languages grow, they will
become more verbose and more difficult to write.  So, instead, we use a
new special form: `match', which is matching a value and binds new
identifiers to different parts (try it with "Check Syntax").  Re-writing
the above code using `match':

  ;; parse-sexpr : s-expr -> AE
  ;; to convert s-expressions into AEs
  (define (parse-sexpr sexpr)
    (match sexpr
      [(number: n) (Num n)]
      [(list op left right)
       (let ([make-node
              (match op
                ['+ Add]
                ['- Sub]
                [else (error 'parse-sexpr "don't know about ~s" op)])])
         (make-node (parse-sexpr left)
                    (parse-sexpr right)))]
      [else (error 'parse-sexpr "bad syntax in ~s" sexpr)]))

To make things less confusing, we will combine this with the function
that parses a string into a sexpr so we can use strings to represent our
programs:

  ;; parse : string -> AE
  ;; parses a string containing an AE expression to an AE
  (define (parse str)
    (parse-sexpr (string->sexpr str)))

========================================================================

A quick note about using `match':

The syntax for `match' is

  (match value
    [pattern result]
    ...)

The value is matched against each pattern, possibly binding names in the
process, and if a pattern matches it evaluates the result expression.
The simplest form of a pattern is simply an identifier -- it always
matches and binds that identifier to the value:

  (match (list 1 2 3) [x x]) ; evaluates to the list

Another simple pattern is a quoted symbol, which matches that symbol.
For example:

  (match foo ['x "yes"] [else "no"])

will evaluate to "yes" if `foo' is the symbol `x', and to "no"
otherwise.  Note that `else' is not a keyword here -- it happens to be a
pattern that always succeeds, so it behaves like an else clause except
that it binds `else' to the unmatched-so-far value.

Many patterns look like function application -- but don't confuse them
with applications.  A `(list x y z)' pattern matches a list of exactly
three items and binds the identifiers -- which is useful with nested
patterns:

  (match (list 1 2 3) [(list x y z) (+ x y z)]) ; evaluates to 6
  (match '((1) (2) 3)
    [(list (list x) (list y) z) (+ x y z)]) ; evaluates to 6

There is also a `cons' pattern that matches a non-empty list and then
matches the first part against the head for the list and the second part
against the tail of the list.

In a `list' pattern, you can use `...' to specify that the previous
pattern is repeated zero or more times, and bound names get bound to the
list of respective matching.  One simple consequent is that the
`(list hd tl ...)' pattern is exactly the same as `(cons hd tl)', but
being able to repeat an arbitrary pattern is very useful:

  (match '((1 2) (3 4) (5 6) (7 8))
    [(list (list x y) ...) (append x y)])
  ; evaluates to (1 3 5 7 2 4 6 8)

A few more useful patterns:

  _                    -- matches anything, but does not bind
  (or pattern pattern) -- matches either pattern (careful with bindings)
  (number: n)          -- matches any number and binds it to `n'
  (symbol: s)          -- same for symbols
  (string: s)          -- strings

If no pattern matches the value, an error is raised.

========================================================================
>>> Semantics (= Evaluation)

Back to BNF -- now, meaning.

An important feature of these BNF specifications: we can use the
derivations to specify *meaning* (and meaning in our context is
"running" a program (or "interpreting", "compiling", but we will use
"evaluating")).  For example:

  <AE> ::= <num>         ; <AE> evaluates to the number
         | <AE1> + <AE2> ; <AE> evaluates to the sum of evaluating
                         ;      <AE1> and <AE2>
         | <AE1> - <AE2> ; ... the subtraction of <AE2> from <AE1>

To do this a little more formally:

  a. eval(<num>) = <num>
  b. eval(<AE1> + <AE2>) = eval(<AE1>) + eval(<AE2>)
  c. eval(<AE1> - <AE2>) = eval(<AE1>) - eval(<AE2>)

Note the completely different roles of the two "+"s and "-"s.

An alternative popular notation for eval(X) is [[X]]:

  a. [[<num>]] = <num>
  b. [[<AE1> + <AE2>]] = [[<AE1>]] + [[<AE2>]]
  c. [[<AE1> - <AE2>]] = [[<AE1>]] - [[<AE2>]]

Is there a problem with this definition?  Ambiguity:

  eval(1 - 2 + 3) = ?

Depending on the way the expression is parsed, we get either 2 or -4:

  eval(1 - 2 + 3) = eval(1 - 2) + eval(3)           [b]
                  = eval(1) - eval(2) + eval(3)     [c]
                  = 1 - 2 + 3                       [a,a,a]
                  = 2

  eval(1 - 2 + 3) = eval(1) - eval(2 + 3)           [c]
                  = eval(1) - (eval(2) + eval(3))   [a]
                  = 1 - (2 + 3)                     [a,a,a]
                  = -4

Again, be very aware of confusing subtleties which are extremely
important: We need parens around a sub-expression only in one case, why?
-- When we write:

  eval(1 - 2 + 3) = ... = 1 - 2 + 3

we have two expressions, but one stands for an *input syntax*, and one
stands for a `real' mathematical expression.

In a case of a computer implementation, the syntax on the left is (as
always) an AE syntax, and the `real' expression on the right is an
expression in whatever language we use to implement our AE language.

Like we said earlier, ambiguity is not a real problem until the actual
parse tree matters.  With `eval' it definitely matters, so we must not
make it possible to derive any syntax in multiple ways or our evaluation
will be non-deterministic.

========================================================================

Quick exercise:

We can define a meaning for <digit>s and then <num>s in a similar way:

  eval(0) = 0
  eval(1) = 1
  eval(2) = 2
  ...
  eval(9) = 9

  eval(<digit> <num>) = 10*eval(<digit>) + eval(<num>)

Is this exactly what we want?  -- Depends on what we actually want...

* Example for free stuff that looks trivial: if we were to define the
  meaning of <num> this way, would it always work?  Think an average
  language that does not give you bignums, making the above rules fail
  when the numbers are too big.

========================================================================
>>> Semantics: Implementing an Evaluator

Now continue to implement the semantics of our syntax -- we express that
through an `eval' function that evaluates an expression.

We use a basic programming principle -- splitting the code into two
layers, one for parsing the input, and one for doing the evaluation.
Doing this avoids the mess we'd get into otherwise, for example:

  (define (eval expr)
    (cond [(number? expr) expr]
          [(and (list? expr) (= 3 (length expr))
                (or (eq? '+ (car expr)) (eq? '- (car expr))))
           (let ([1st (eval (cadr expr))]
                 [2nd (eval (caddr expr))]
                 [op  (if (eq? '+ (car expr)) + -)])
             (op 1st 2nd))]
          [else (error 'eval "bad input!")]))

This is messy because it combines two very different things -- syntax
and semantics -- into a single lump of code.  If we split the code, we
can easily include decisions like making

  {+ 1 {- 3 "a"}}

syntactically invalid.  (Which is not, BTW, what Scheme does...)  (Also,
this is like the distinction between XML syntax and well-formed XML
syntax.)

An additional advantage is that by using two separate components, it is
simple to replace each one, making it possible to change the input
syntax, and the semantics independently -- we only need to keep the same
interface data (the AST) and things will work fine.

Our `parse' function converts an input syntax to an abstract syntax tree
(AST).  It is abstract exactly because it is independent of any actual
concrete syntax that you type in, print out etc.

========================================================================

Back to our `eval' -- this will be its (obvious) contract:

  ;; eval : AE -> number
  ;; consumes an AE and computes the corresponding number

which leads to some obvious test cases:

  (equal? 3 (eval (parse "3")))
  (equal? 7 (eval (parse "{+ 3 4}")))
  (equal? 6 (eval (parse "{+ {- 3 4} 7}")))

Like everything else, the structure of the recursive `eval' code follows
the recursive structure of its input.  The template is therefore:

  (define (eval expr)
    (cases expr
      [(Num n)   ...]
      [(Add l r) ... (eval l) ... (eval r) ...]
      [(Sub l r) ... (eval l) ... (eval r) ...]))

In this case, filling in the gaps is very simple

  (define (eval expr)
    (cases expr
      [(Num n)   n]
      [(Add l r) (+ (eval l) (eval r))]
      [(Sub l r) (- (eval l) (eval r))]))

We can further combine `eval' and `parse' into a single `run' function
that evaluates an AE string.

  ;; run : string -> number
  ;; evaluate an AE program contained in a string
  (define (run str)
    (eval (parse str)))

The resulting *full* code is:

  --------------------------------------------------------------------
  #| BNF for the AE language:
     <AE> ::= <num>
            | { + <AE> <AE> }
            | { - <AE> <AE> }
            | { * <AE> <AE> }
            | { / <AE> <AE> }
  |#

  ;; AE abstract syntax trees
  (define-type AE
    [Num (n number?)]
    [Add (lhs AE?) (rhs AE?)]
    [Sub (lhs AE?) (rhs AE?)]
    [Mul (lhs AE?) (rhs AE?)]
    [Div (lhs AE?) (rhs AE?)])

  ;; parse-sexpr : s-expr -> AE
  ;; to convert s-expressions into AEs
  (define (parse-sexpr sexpr)
    (match sexpr
      [(number: n) (Num n)]
      [(list op left right)
       (let ([make-node
              (match op
                ['+ Add]
                ['- Sub]
                ['* Mul]
                ['/ Div]
                [else (error 'parse-sexpr "don't know about ~s" op)])])
         (make-node (parse-sexpr left)
                    (parse-sexpr right)))]
      [else (error 'parse-sexpr "bad syntax in ~s" sexpr)]))

  ;; parse : string -> AE
  ;; parses a string containing an AE expression to an AE AST
  (define (parse str)
    (parse-sexpr (string->sexpr str)))

  ;; eval : AE -> number
  ;; consumes an AE and computes the corresponding number
  (define (eval expr)
    (cases expr
      [(Num n)   n]
      [(Add l r) (+ (eval l) (eval r))]
      [(Sub l r) (- (eval l) (eval r))]
      [(Mul l r) (* (eval l) (eval r))]
      [(Div l r) (/ (eval l) (eval r))]))

  ;; run : string -> number
  ;; evaluate an AE program contained in a string
  (define (run str)
    (eval (parse str)))

  ;; tests:
  (equal? 3 (run "3"))
  (equal? 7 (run "{+ 3 4}"))
  (equal? 6 (run "{+ {- 3 4} 7}"))
  --------------------------------------------------------------------

For anyone who thinks that Scheme is a bad choice, this is a good point
to think how much code would be needed in some other language to do the
same as above.

========================================================================
>>> Bindings & Substitution

We now get to an important concept: substitution.

Even in our simple language, we encounter repeated expressions.  For
example, if we want to compute the square of some expression:

  {* {+ 4 2} {+ 4 2}}

Why would we want to get rid of the repeated sub-expression?

* It introduces a redundant computation.  In this example, we want to
  avoid computing the same sub-expression a second time.

* It makes the computation more complicated than it could be without the
  repetition.  Compare the above with:

    with x = {+ 4 2},
      {* x x}

* This is related to a basic fact in programming that we have already
  discussed: duplicating information is always a bad thing.  Among other
  bad consequences, it can even lead to bugs that could not happen if we
  wouldn't duplicate code.  A toy example is "fixing" one of the numbers
  in one expression and forgetting to fix the corresponding one:

    {* {+ 4 2} {+ 4 1}}

  Real world examples involve much more code, which make such bugs very
  difficult to find, but they still follow the same principle.

* This gives us more expressive power -- we don't just say that we want
  to multiply two expressions that both happen to be {+ 4 2}, we say
  that we multiply the {+ 4 2} expression by *itself*.  It allows us to
  express identity of two values as well as using two values that happen
  to be the same.

So, the normal way to avoid redundancy is to introduce an identifier.
Even when we speak, we might say: "let x be 4 plus 2, multiply x by x".

(These are often called "variables", but we will try to avoid this name:
what if the identifier does not change (vary)?)

To get this, we introduce a new form into our language:

  {with {x {+ 4 2}}
    {* x x}}

We expect to be able to reduce this to:

  {* 6 6}

by substituting 6 for `x' in the body sub-expression of `with'.

A little more complicated example:

  {with {x {+ 4 2}}
    {with {y {* x x}}
      {+ y y}}}
  [add]  = {with {x 6} {with y {* x x} {+ y y}}}
  [subst]= {with {y {* 6 6}} {+ y y}}
  [mul]  = {with {y 36} {+ y y}}
  [subst]= {+ 36 36}
  [add]  = 72

========================================================================

To add this to our language, we start with the BNF.  We now call our
language `WAE' (With+AE):

  <WAE> ::= <num>
          | { + <WAE> <WAE> }
          | { - <WAE> <WAE> }
          | { * <WAE> <WAE> }
          | { with { <id> <WAE> } <WAE> }
          | <id>

Note that we had to introduce two new rules: one for introducing an
identifier, and one for using it.  This is common in many language
specifications, for example `define-type' introduced a new type, and it
comes with `cases' that allows us to destruct its instances.

For <id> we need to use some form of identifiers, the natural choice in
Scheme is to use symbols.  We can therefore write the corresponding type
definition:

  (define-type WAE
    [Num  (n number?)]
    [Add  (lhs WAE?) (rhs WAE?)]
    [Sub  (lhs WAE?) (rhs WAE?)]
    [Mul  (lhs WAE?) (rhs WAE?)]
    [Id   (name symbol?)]
    [With (name symbol?) (named WAE?) (body WAE?)])

The parser is easily extended to produce these syntax objects:

  ;; parse-sexpr : s-expr -> WAE
  ;; to convert s-expressions into WAEs
  (define (parse-sexpr sexpr)
    (match sexpr
      [(number: n)    (Num n)]
      [(symbol: name) (Id name)]
      [(cons 'with more)
       ;; go in here for all sexpr that begin with a 'with
       (match sexpr
         [(list 'with (list (symbol: name) named) body)
          (With name
                (parse-sexpr named)
                (parse-sexpr body))]
         [else (error 'parse-sexpr "bad `with' syntax in ~s" sexpr)])]
      [(list op left right)
       (let ([make-node
              (match op
                ['+ Add]
                ['- Sub]
                ['* Mul]
                [else (error 'parse-sexpr "don't know about ~s" op)])])
         (make-node (parse-sexpr left)
                    (parse-sexpr right)))]
      [else (error 'parse-sexpr "bad syntax in ~s" sexpr)]))

And we're done with the syntactic part of the `with' extension.

(Quick question -- why is `With' indented like a normal function in this
code?)

========================================================================
Now, to make this work, we will need to do some substitutions.

We basically want to say that to evaluate:

  {with {id WAE1} WAE2}

we need to evaluate WAE2 with id substituted by WAE1.  Formally:

  eval( {with {id WAE1} WAE2} ) = eval( subst(WAE2,id,WAE1) )

There is a more common syntax for substitution (quick: what do I mean by
this "syntax"?):

  eval( {with {id WAE1} WAE2} ) = eval( WAE2[WAE1/id] )

Now all we need is an exact definition of substitution.  (Note that
substitution is not the same as evaluation, only part of the evaluation
process.  In the previous examples, when we evaluated the expression we
did substitutions as well as the usual arithmetic operations that were
already part of the AE evaluator.  In this last definition there is
still a missing evaluation step, see if you can find it.)

So let us try to define substitution now:

  [substitution, take 1]  e[v/i]
  To substitute an identifier `i' in an expression `e' with an
  expression `v', replace all identifiers in `e' that have the same name
  `i' by the expression `v'.

This seems to work with simple expressions, for example:

  {with {x 5} {+ x x}}   -->  {+ 5 5}
  {with {x 5} {+ 10 4}}  -->  {+ 10 4}

however, we crash with an invalid syntax if we try:

  {with {x 5} {+ x {with {x 3} 10}}}  -->  {+ 5 {with {5 3} 10}} ???

-- we got to an invalid expression.

To fix this, we need to distinguish "normal" occurrences of identifiers,
and ones that are used as new bindings.  We need a few new terms for
this:

1. Binding Instance: a binding instance of an identifier is one that is
   used to name it in a new binding.  In our <WAE> syntax, binding
   instances are only the <id> position of the `with' form.

2. Scope: the scope of a binding instance is the region of program text
   in which instances of the identifier refer to the value bound in the
   binding instance.  (Note that this definition actually relies on a
   definition of substitution, because that is what is used to specify
   how identifiers refer to values.)

3. Bound Instance: an instance of an identifier is bound if it is
   contained within the scope of a binding instance of its name.

4. Free Instance: An identifier that is not contained in any binding
   instance of its name is said to be free.

Using this we can say that the problem with the previous definition of
substitution is that it failed to distinguish between bound instances
(which should be substituted) and binding instances (which should not).
So we try to fix this:

  [substitution, take 2]  e[v/i]
  To substitute an identifier `i' in an expression `e' with an
  expression `v', replace all instances of `i' that are not themselves
  binding instances with the expression `v'.

First of all, check the previous examples:

  {with {x 5} {+ x x}}   -->  {+ 5 5}
  {with {x 5} {+ 10 4}}  -->  {+ 10 4}

still work, and

  {with {x 5} {+ x {with {x 3} 10}}}  -->  {+ 5 {with {x 3} 10}}
                                      -->  {+ 5 10}

also works.  However, if we try this:

  {with {x 5} {+ x {with {x 3} x}}}

we get:

  -->  {+ 5 {with {x 3} 5}}
  -->  {+ 5 5}
  -->  10

but we want that to be 8: the inner `x' should be bound by the closest
`with' that binds it.

The problem is that the new definition of substitution that we have
respects binding instances, but it fails to deal with their scope.  In
the above example, we want the inner `with' to *shadow* the outer
`with's binding for `x'.

  [substitution, take 3]  e[v/i]
  To substitute an identifier `i' in an expression `e' with an
  expression `v', replace all instances of `i' that are not themselves
  binding instances, and that are not in any nested scope, with the
  expression `v'.

This avoids bad substitution above, but it is now doing things too
carefully:

  {with {x 5} {+ x {with {y 3} x}}}

becomes

  -->  {+ 5 {with {y 3} x}}
  -->  {+ 5 x}

which is an error because `x' is unbound (and there is reasonable no
rule that we can specify to evaluate it).

The problem is that our substitution halts at every new scope, in this
case, it stopped at the new `y' scope, but it shouldn't have because it
uses a different name.  In fact, that last definition of substitution
cannot handle any nested scope.

Revise again:

  [substitution, take 4]  e[v/i]
  To substitute an identifier `i' in an expression `e' with an
  expression `v', replace all instances of `i' that are not themselves
  binding instances, and that are not in any nested scope of `i', with
  the expression `v'.

which, finally, is a good definition.  This is just a little too
mechanical.  Notice that we actually refer to all instances of `i' that
are not in a scope of a binding instance of `i', which simply means all
*free occurrences* of `i' -- free in `e' (why? -- remember the
definition of "free"?):

  [substitution, take 4b]  e[v/i]
  To substitute an identifier `i' in an expression `e' with an
  expression `v', replace all instances of `i' that are free in `e' with
  the expression `v'.

Based on this we can finally write the code for it:

  ;; subst : WAE symbol WAE -> WAE
  ;; substitutes the second argument with the third argument in the
  ;; first argument, as per the rules of substitution; the resulting
  ;; expression contains no free instances of the second argument
  (define (subst expr from to)
    (cases expr
      [(Num n) expr]
      [(Add l r) (Add (subst l from to) (subst r from to))]
      [(Sub l r) (Sub (subst l from to) (subst r from to))]
      [(Mul l r) (Mul (subst l from to) (subst r from to))]
      [(Id name) (if (eq? name from) to expr)]
      [(With bound-id named-expr bound-body)
       (if (eq? bound-id from)
         expr           ; <-- don't go in!
         (With bound-id
               named-expr
               (subst bound-body from to)))]))

... and this is just the same as writing a formal "paper version" of the
substitution rule.

... but we still have bugs!

========================================================================

Before we find the bugs, we need to see when and how substitution is
used in the evaluation process.

To modify our evaluator, we will need rules to deal with the new syntax
pieces -- `with' expressions and identifiers.

When we see an expression that looks like:

  {with {x E1} E2}

we continue by *evaluating* `E1' to get a value `V1', we then substitute
the identifier `x' with the expression `V1' in `E2', and continue by
evaluating this new expression.  In other words, we have the following
evaluation rule:

  eval( {with {x E1} E2} ) = eval( E2[eval(E1)/x] )

So we know what to do with `with' expressions.  How about identifiers?
The main feature of `subst', as said in the purpose statement, is that
it leaves no free instances of the substituted variable around.  This
means that if the initial expression is valid (did not contain any free
variables), then when we go from

  {with {x E1} E2}

to

  E2[E1/x]

the result is an expression that has *no* free instances of `x'.  So we
don't need to handle identifiers in the evaluator -- substitutions make
them all go away.

We can now extend the formal definition of AE to that of WAE:

    eval(...) = ... same as the AE rules ...
    eval({with {x E1} E2}) = eval(E2[eval(E1)/x])
    eval(id) = error!

If you're paying close attention, you might catch a potential problem in
this definition: we're substituting `eval(E1)' for `x' in `E2' -- an
operation that requires a WAE expression, but `eval(E1)' is a number.
(Look at the type of the `eval' definition we had for AE, then look at
the above definition of `subst'.)  This seems like being overly
pedantic, but we it will require some resolution when we get to the
code.  The above rules are easily coded as follows:

  ;; eval : WAE -> number
  ;; evaluates WAE expressions by reducing them to numbers
  (define (eval expr)
    (cases expr
      [(Num n) n]
      [(Add l r) (+ (eval l) (eval r))]
      [(Sub l r) (- (eval l) (eval r))]
      [(Mul l r) (* (eval l) (eval r))]
      [(With bound-id named-expr bound-body)
       (eval (subst bound-body
                    bound-id
                    (Num (eval named-expr))))] ; <-***
      [(Id name) (error 'eval "free identifier: ~s" name)]))

Note the `Num' expression in the marked line: evaluating the named
expression gives us back a number -- we need to convert this number into
a syntax to be able to use it with `subst'.  The solution is to use
`Num' to convert the resulting number into a numeral (the syntax of a
number).  It's not an elegant solution, but it will do for now.

Finally, here are a few test cases.  We use a new `test' special form
which is part of the course plugin.  The way to use `test' is with two
expressions and an `=>' arrow -- DrScheme evaluates both, and nothing
will happen if the results are equal.  If the results are different, you
will get a warning line, but evaluation will continue so you can try
additional tests.  You can also use an `=error>' arrow to test an error
message -- use it with some text from the expected error, `?' stands for
any single character, and `*' is a sequence of zero or more characters.
(When you use `test' in your homework, the handin server will abort when
tests fail.)  We expect these tests to succeed (make sure that you
understand *why* they should succeed).

  ;; tests
  (test (run "5") => 5)
  (test (run "{+ 5 5}") => 10)
  (test (run "{with {x {+ 5 5}} {+ x x}}") => 20)
  (test (run "{with {x 5} {+ x x}}") => 10)
  (test (run "{with {x {+ 5 5}} {with {y {- x 3}} {+ y y}}}") => 14)
  (test (run "{with {x 5} {with {y {- x 3}} {+ y y}}}") => 4)
  (test (run "{with {x 5} {+ x {with {x 3} 10}}}") => 15)
  (test (run "{with {x 5} {+ x {with {x 3} x}}}") => 8)
  (test (run "{with {x 5} {+ x {with {y 3} x}}}") => 10)
  (test (run "{with {x 5} {with {y x} y}}") => 5)
  (test (run "{with {x 5} {with {x x} x}}") => 5)
  (test (run "{with {x 1} y}") =error> "free identifier")

Putting this all together, we get the following code; trying to run this
code will raise an unexpected error...

  --------------------------------------------------------------------
  #| BNF for the WAE language:
       <WAE> ::= <num>
               | { + <WAE> <WAE> }
               | { - <WAE> <WAE> }
               | { * <WAE> <WAE> }
               | { with { <id> <WAE> } <WAE> }
               | <id>
  |#

  ;; WAE abstract syntax trees
  (define-type WAE
    [Num  (n number?)]
    [Add  (lhs WAE?) (rhs WAE?)]
    [Sub  (lhs WAE?) (rhs WAE?)]
    [Mul  (lhs WAE?) (rhs WAE?)]
    [Id   (name symbol?)]
    [With (name symbol?) (named WAE?) (body WAE?)])

  ;; parse-sexpr : s-expr -> WAE
  ;; to convert s-expressions into WAEs
  (define (parse-sexpr sexpr)
    (match sexpr
      [(number: n)    (Num n)]
      [(symbol: name) (Id name)]
      [(cons 'with more)
       (match sexpr
         [(list 'with (list (symbol: name) named) body)
          (With name (parse-sexpr named) (parse-sexpr body))]
         [else (error 'parse-sexpr "bad `with' syntax in ~s" sexpr)])]
      [(list op left right)
       (let ([make-node
              (match op
                ['+ Add]
                ['- Sub]
                ['* Mul]
                [else (error 'parse-sexpr "don't know about ~s" op)])])
         (make-node (parse-sexpr left)
                    (parse-sexpr right)))]
      [else (error 'parse-sexpr "bad syntax in ~s" sexpr)]))

  ;; parse : string -> WAE
  ;; parses a string containing a WAE expression to a WAE AST
  (define (parse str)
    (parse-sexpr (string->sexpr str)))

  ;; subst : WAE symbol WAE -> WAE
  ;; substitutes the second argument with the third argument in the
  ;; first argument, as per the rules of substitution; the resulting
  ;; expression contains no free instances of the second argument
  (define (subst expr from to)
    (cases expr
      [(Num n) expr]
      [(Add l r) (Add (subst l from to) (subst r from to))]
      [(Sub l r) (Sub (subst l from to) (subst r from to))]
      [(Mul l r) (Mul (subst l from to) (subst r from to))]
      [(Id name) (if (eq? name from) to expr)]
      [(With bound-id named-expr bound-body)
       (if (eq? bound-id from)
         expr
         (With bound-id
               named-expr
               (subst bound-body from to)))]))

  ;; eval : WAE -> number
  ;; evaluates WAE expressions by reducing them to numbers
  (define (eval expr)
    (cases expr
      [(Num n) n]
      [(Add l r) (+ (eval l) (eval r))]
      [(Sub l r) (- (eval l) (eval r))]
      [(Mul l r) (* (eval l) (eval r))]
      [(With bound-id named-expr bound-body)
       (eval (subst bound-body
                    bound-id
                    (Num (eval named-expr))))]
      [(Id name) (error 'eval "free identifier: ~s" name)]))

  ;; run : string -> number
  ;; evaluate a WAE program contained in a string
  (define (run str)
    (eval (parse str)))

  ;; tests
  (test (run "5") => 5)
  (test (run "{+ 5 5}") => 10)
  (test (run "{with {x {+ 5 5}} {+ x x}}") => 20)
  (test (run "{with {x 5} {+ x x}}") => 10)
  (test (run "{with {x {+ 5 5}} {with {y {- x 3}} {+ y y}}}") => 14)
  (test (run "{with {x 5} {with {y {- x 3}} {+ y y}}}") => 4)
  (test (run "{with {x 5} {+ x {with {x 3} 10}}}") => 15)
  (test (run "{with {x 5} {+ x {with {x 3} x}}}") => 8)
  (test (run "{with {x 5} {+ x {with {y 3} x}}}") => 10)
  (test (run "{with {x 5} {with {y x} y}}") => 5)
  (test (run "{with {x 5} {with {x x} x}}") => 5)
  (test (run "{with {x 1} y}") =error> "free identifier")
  --------------------------------------------------------------------

========================================================================

Oops, this program still has problems that were caught by the tests --
we encounter unexpected free identifier errors.  What's the problem now?
In expressions like:

  {with {x 5}
    {with {y x}
      y}}

we forgot to substitute `x' in the expression that `y' is bound to.  We
need to the recursive substitute in both the with's body expression as
well as its named expression:

  ;; subst : WAE symbol WAE -> WAE
  ;; substitutes the second argument with the third argument in the
  ;; first argument, as per the rules of substitution; the resulting
  ;; expression contains no free instances of the second argument
  (define (subst expr from to)
    (cases expr
      [(Num n) expr]
      [(Add l r) (Add (subst l from to) (subst r from to))]
      [(Sub l r) (Sub (subst l from to) (subst r from to))]
      [(Mul l r) (Mul (subst l from to) (subst r from to))]
      [(Id name) (if (eq? name from) to expr)]
      [(With bound-id named-expr bound-body)
       (if (eq? bound-id from)
         expr
         (With bound-id
               (subst named-expr from to)       ; <-- new
               (subst bound-body from to)))]))

And *still* we have a problem...  Now it's

  {with {x 5}
    {with {x x}
      x}}

that halts with an error, but we want it to evaluate to 5!  Carefully
trying out our substitution code reveals the problem: when we substitute
`5' for the outer `x', we don't go inside the inner `with' because it
has the same name -- but we *do* need to go into its named expression.
We need to substitute in the named expression even if the identifier is
the *same* one we substituting:

  ;; subst : WAE symbol WAE -> WAE
  ;; substitutes the second argument with the third argument in the
  ;; first argument, as per the rules of substitution; the resulting
  ;; expression contains no free instances of the second argument
  (define (subst expr from to)
    (cases expr
      [(Num n) expr]
      [(Add l r) (Add (subst l from to) (subst r from to))]
      [(Sub l r) (Sub (subst l from to) (subst r from to))]
      [(Mul l r) (Mul (subst l from to) (subst r from to))]
      [(Id name) (if (eq? name from) to expr)]
      [(With bound-id named-expr bound-body)
       (With bound-id
             (subst named-expr from to)
             (if (eq? bound-id from)
               bound-body
               (subst bound-body from to)))]))

The complete (and, finally, correct) version of the code is now:

  ----------------------------------------------------------------------
  #| BNF for the WAE language:
       <WAE> ::= <num>
               | { + <WAE> <WAE> }
               | { - <WAE> <WAE> }
               | { * <WAE> <WAE> }
               | { with { <id> <WAE> } <WAE> }
               | <id>
  |#

  ;; WAE abstract syntax trees
  (define-type WAE
    [Num  (n number?)]
    [Add  (lhs WAE?) (rhs WAE?)]
    [Sub  (lhs WAE?) (rhs WAE?)]
    [Mul  (lhs WAE?) (rhs WAE?)]
    [Id   (name symbol?)]
    [With (name symbol?) (named WAE?) (body WAE?)])

  ;; parse-sexpr : s-expr -> WAE
  ;; to convert s-expressions into WAEs
  (define (parse-sexpr sexpr)
    (match sexpr
      [(number: n)    (Num n)]
      [(symbol: name) (Id name)]
      [(cons 'with more)
       (match sexpr
         [(list 'with (list (symbol: name) named) body)
          (With name (parse-sexpr named) (parse-sexpr body))]
         [else (error 'parse-sexpr "bad `with' syntax in ~s" sexpr)])]
      [(list op left right)
       (let ([make-node
              (match op
                ['+ Add]
                ['- Sub]
                ['* Mul]
                [else (error 'parse-sexpr "don't know about ~s" op)])])
         (make-node (parse-sexpr left)
                    (parse-sexpr right)))]
      [else (error 'parse-sexpr "bad syntax in ~s" sexpr)]))

  ;; parse : string -> WAE
  ;; parses a string containing a WAE expression to a WAE AST
  (define (parse str)
    (parse-sexpr (string->sexpr str)))

  ;; subst : WAE symbol WAE -> WAE
  ;; substitutes the second argument with the third argument in the
  ;; first argument, as per the rules of substitution; the resulting
  ;; expression contains no free instances of the second argument
  (define (subst expr from to)
    (cases expr
      [(Num n) expr]
      [(Add l r) (Add (subst l from to) (subst r from to))]
      [(Sub l r) (Sub (subst l from to) (subst r from to))]
      [(Mul l r) (Mul (subst l from to) (subst r from to))]
      [(Id name) (if (eq? name from) to expr)]
      [(With bound-id named-expr bound-body)
       (With bound-id
             (subst named-expr from to)
             (if (eq? bound-id from)
               bound-body
               (subst bound-body from to)))]))

  ;; eval : WAE -> number
  ;; evaluates WAE expressions by reducing them to numbers
  (define (eval expr)
    (cases expr
      [(Num n) n]
      [(Add l r) (+ (eval l) (eval r))]
      [(Sub l r) (- (eval l) (eval r))]
      [(Mul l r) (* (eval l) (eval r))]
      [(With bound-id named-expr bound-body)
       (eval (subst bound-body
                    bound-id
                    (Num (eval named-expr))))]
      [(Id name) (error 'eval "free identifier: ~s" name)]))

  ;; run : string -> number
  ;; evaluate a WAE program contained in a string
  (define (run str)
    (eval (parse str)))

  ;; tests
  (test (run "5") => 5)
  (test (run "{+ 5 5}") => 10)
  (test (run "{with {x {+ 5 5}} {+ x x}}") => 20)
  (test (run "{with {x 5} {+ x x}}") => 10)
  (test (run "{with {x {+ 5 5}} {with {y {- x 3}} {+ y y}}}") => 14)
  (test (run "{with {x 5} {with {y {- x 3}} {+ y y}}}") => 4)
  (test (run "{with {x 5} {+ x {with {x 3} 10}}}") => 15)
  (test (run "{with {x 5} {+ x {with {x 3} x}}}") => 8)
  (test (run "{with {x 5} {+ x {with {y 3} x}}}") => 10)
  (test (run "{with {x 5} {with {y x} y}}") => 5)
  (test (run "{with {x 5} {with {x x} x}}") => 5)
  ----------------------------------------------------------------------

========================================================================

Reminder:

* We started doing substitution, with a `let'-like form: `with'.

* Reasons for using bindings:
  - Avoid writing expressions twice.
    -> More expressive language (can express identity).
    -> Duplicating is bad!
    --> Static redundancy.
  - Avoid redundant computations.
    --> Dynamic redundancy.

* BNF:

  <WAE> ::= <num>
          | { + <WAE> <WAE> }
          | { - <WAE> <WAE> }
          | { * <WAE> <WAE> }
          | { with { <id> <WAE> } <WAE> }
          | <id>

  Note that we had to introduce two new rules: one for introducing an
  identifier, and one for using it.

* Type definition:

  (define-type WAE
    [Num  (n number?)]
    [Add  (lhs WAE?) (rhs WAE?)]
    [Sub  (lhs WAE?) (rhs WAE?)]
    [Mul  (lhs WAE?) (rhs WAE?)]
    [Id   (name symbol?)]
    [With (name symbol?) (named WAE?) (body WAE?)])

* Parser:

  ;; parse-sexpr : s-expr -> WAE
  ;; to convert s-expressions into WAEs
  (define (parse-sexpr sexpr)
    (match sexpr
      [(number: n)    (Num n)]
      [(symbol: name) (Id name)]
      [(cons 'with more)
       (match sexpr
         [(list 'with (list (symbol: name) named) body)
          (With name (parse-sexpr named) (parse-sexpr body))]
         [else (error 'parse-sexpr "bad `with' syntax in ~s" sexpr)])]
      [(list op left right)
       (let ([make-node
              (match op
                ['+ Add]
                ['- Sub]
                ['* Mul]
                [else (error 'parse-sexpr "don't know about ~s" op)])])
         (make-node (parse-sexpr left)
                    (parse-sexpr right)))]
      [else (error 'parse-sexpr "bad syntax in ~s" sexpr)]))

* We need to define substitution.
  Terms:
  1. Binding Instance.
  2. Scope.
  3. Bound Instance.
  4. Free Instance.

* After lots of attempts:

  e[v/i] -- To substitute an identifier `i' in an expression `e' with an
  expression `v', replace all instances of `i' that are free in `e' with
  the expression `v'.

* Implemented the code, and again, needed to fix a few bugs:

  ;; subst : WAE symbol WAE -> WAE
  ;; substitutes the second argument with the third argument in the
  ;; first argument, as per the rules of substitution; the resulting
  ;; expression contains no free instances of the second argument
  (define (subst expr from to)
    (cases expr
      [(Num n) expr]
      [(Add l r) (Add (subst l from to) (subst r from to))]
      [(Sub l r) (Sub (subst l from to) (subst r from to))]
      [(Mul l r) (Mul (subst l from to) (subst r from to))]
      [(Id name) (if (eq? name from) to expr)]
      [(With bound-id named-expr bound-body)
       (With bound-id
             (subst named-expr from to)
             (if (eq? bound-id from)
               bound-body
               (subst bound-body from to)))]))

  (Note that the bugs that we fixed clarify the exact way that our
  scopes work: in `{with {x 2} {with {x {+ x 2}} x}}', the scope of the
  first `x' is:                         ^^^^^^^)

* We then extended the AE evaluation rules:

    eval(...) = ... same as the AE rules ...
    eval({with {x E1} E2}) = eval(E2[eval(E1)/x])
    eval(id) = error!

  and noted the possible type problem.

* The above translated into a Scheme definition for an `eval' function
  (with a hack to avoid the type issue):

  ;; eval : WAE -> number
  ;; evaluates WAE expressions by reducing them to numbers
  (define (eval expr)
    (cases expr
      [(Num n) n]
      [(Add l r) (+ (eval l) (eval r))]
      [(Sub l r) (- (eval l) (eval r))]
      [(Mul l r) (* (eval l) (eval r))]
      [(With bound-id named-expr bound-body)
       (eval (subst bound-body
                    bound-id
                    (Num (eval named-expr))))]
      [(Id name) (error 'eval "free identifier: ~s" name)]))

========================================================================
>>> Formal Specs

A formal definition of `subst':

(`N' is a <num>, `E1', `E2' are <WAE>s, `x' is some <id>, `y' is a
*different* <id>)

  N[v/x]                = N

  {+ E1 E2}[v/x]        = {+ E1[v/x] E2[v/x]}

  {- E1 E2}[v/x]        = {- E1[v/x] E2[v/x]}

  {* E1 E2}[v/x]        = {* E1[v/x] E2[v/x]}

  y[v/x]                = y
  x[v/x]                = v

  {with {y E1} E2}[v/x] = {with {y E1[v/x]} E2[v/x]}
  {with {x E1} E2}[v/x] = {with {x E1[v/x]} E2}

And a formal definition of `eval':

  eval(N)         = N

  eval({+ E1 E2}) = eval(E1) + eval(E2)

  eval({- E1 E2}) = eval(E1) - eval(E2)

  eval({* E1 E2}) = eval(E1) * eval(E2)

  eval(id)        = error!

  eval({with {x E1} E2}) = eval(E2[eval(E1)/x])

========================================================================
>>> Lazy vs Eager Evaluation

As we have previously seen, there are two basic approaches for
evaluation: either eager or lazy.  In lazy evaluation, bindings are used
for sort of textual references -- it is only for avoiding writing an
expression twice, but the associated computation is done twice anyway.
In eager evaluation, we eliminate not only the textual redundancy, but
also the computation.

Which evaluation method did our evaluator use?  The relevant piece of
formalism is the treatment of `with':

  eval({with {x E1} E2}) = eval(E2[eval(E1)/x])

And the matching piece of code is:

  [(With bound-id named-expr bound-body)
   (eval (subst bound-body
                bound-id
                (Num (eval named-expr))))]

How do we make this lazy?

In the formal equation:

  eval({with {x E1} E2}) = eval(E2[E1/x])

and in the code:

  ;; eval : WAE -> number
  ;; evaluates WAE expressions by reducing them to numbers
  (define (eval expr)
    (cases expr
      [(Num n) n]
      [(Add l r) (+ (eval l) (eval r))]
      [(Sub l r) (- (eval l) (eval r))]
      [(Mul l r) (* (eval l) (eval r))]
      [(With bound-id named-expr bound-body)
       (eval (subst bound-body
                    bound-id
                    named-expr))] ; <- no eval and no Num wrapping
      [(Id name) (error 'eval "free identifier: ~s" name)]))

We can verify the way this works by tracing `eval' (compare the trace
you get for the two versions):

  > (trace eval)
  > (run "{with {x {+ 1 2}} {* x x}}")

Ignoring the traces for now, the modified WAE interpreter works as
before, specifically, all tests pass.  So the question is whether the
language we get is actually different than the one we had before.  One
difference is in execution speed, but we can't really notice a
difference, and we care more about meaning.  Is there any program that
will run differently in the two languages?

The main feature of the lazy evaluator is that it is not evaluating the
named expression until it is actually needed.  As we have seen, this
leads to duplicating computations if the bound identifier is used more
than once -- meaning that it does not eliminate the dynamic redundancy.
But what if the bound identifier is not used at all?  In that case the
named expression simply evaporates.  This is a good hint at an
expression that behaves differently in the two languages -- if we add
division to both languages, we get a different result when we try
running:

  {with {x {/ 8 0}} 7}

The eager evaluator stops with an error when it tries evaluating the
division -- and the lazy evaluator simply ignores it.

Even without division, we get a similar behavior for

  {with {x y} 7}

but it is questionable whether the fact that this evaluates to 7 is
correct behavior -- we really want to forbid program that use free
variable.

Furthermore, there is an issue with name capturing -- we don't want to
substitute an expression into a context that captures some of its free
variables.  But our substitution allows just that, which is usually not
a problem because by the time we do the substitution, the named
expression should not have free variables that need to be replaced.
However, consider evaluating this program:

  {with {y x}
    {with {x 2}
      {+ x y}}}

under the two evaluation regimens: the eager version stops with an
error, and the lazy version succeed.  This points at a bug in our
substitution, or rather not dealing with an issue that we do not
encounter.

So the summary is: as long as the initial program is correct, both
evaluation regimens produce the same results.  If a program contains
free variables, they might get captured in a naive lazy evaluator
implementation (but this is a bug that should be fixed).  Also, there
are some cases where eager evaluation runs into a run-time problem which
does not happen in a lazy evaluator because the expression is not used.
It is possible to prove that when you evaluate an expression, if there
is an error that can be avoided, lazy evaluation will always avoid it,
whereas an eager evaluator will always run into it.  On the other hand,
lazy evaluators are usually slower than eager evaluator, so it's a speed
vs. robustness trade-off.

Note that with lazy evaluation we say that an identifier is bound to an
expression rather than a value.  (Again, this is why the eager version
needed to wrap `eval's result in a `Num' and this one doesn't.)

========================================================================
>>> de Bruijn Indices

This whole story revolved around names, specifically, name capture is a
problem that should always be avoided (it is one of the biggest sources
of headaches in PL).

But are names the only way we can use bindings?

There is a least one alternative way: note that the only thing we used
names for are for references.  We don't really care what the name is,
which is pretty obvious when we consider the two WAE expressions:

  {with {x 5} {+ x x}}
  {with {y 5} {+ y y}}

and the two Scheme function definitions:

  (define (foo x) (list x x))
  (define (foo y) (list y y))

Both of these show a pair of expressions that we should consider as
equal in some sense (this is called "alpha-equality").  The only thing
we care about is what variable points where: the binding structure is
the only thing that matters.  In other words, as long as DrScheme
produces the same arrows when we use Check Syntax, we consider the
program to be the same, regardless of name choices (for argument names
and local names, not for global names like `foo' in the above).

The alternative idea uses this principle: if all we care about is where
the arrows go, then simply get rid of the names...  Instead of
referencing a binding through its name, just specify which of the
surrounding scopes we want to refer to.  For example, instead of:

  {with {x 5} {with {y 6} {+ x y}}}

we can use a new `reference' syntax -- "[N]" -- and use this instead of
the above:

  {with 5 {with 6 {+ [1] [0]}}}

So the rules for [N] are -- [0] is the value bound in the current scope,
[1] is the value from the next one up etc.

Of course, to do this translation, we have to know the precise scope
rules.  Two more complicated examples:

  {with {x 5} {+ x {with {y 6} {+ x y}}}}

is translated to:

  {with 5 {+ [0] {with 6 {+ [1] [0]}}}}

(note how `x' appears as a different reference based on where it
appeared in the original code.)  Even more subtle:

  {with {x 5} {with {y {+ x 1}} {+ x y}}}

is translated to:

  {with 5 {with {+ [0] 1} {+ [1] [0]}}}

because the inner `with' does not have its own named expression in its
scope, so the named expression is immediately in the scope of the outer
`with'.

This is called "de Bruijn Indices": instead of referencing identifiers
by their name, we use an index into the surrounding binding context.
The major disadvantage, as can be seen in the above examples, is that it
is not convenient for humans to work with.  Specifically, the same
identifier is referenced using different numbers, which makes it hard to
understand what some code is doing.

However, practically all compilers use this for compiled code (think
about stack pointers).  For example, GCC compiles this code:

  {
    int x = 5;
    {
      int y = x + 1;
      return x + y;
    }
  }

to:

  subl $8, %esp
  movl $5, -4(%ebp)
  movl -4(%ebp), %eax
  incl %eax
  movl %eax, -8(%ebp)
  movl -8(%ebp), %eax
  addl -4(%ebp), %eax

========================================================================
>>> Functions & First Class Function Values

Now that we have a form for local bindings, which forced us to deal with
proper substitutions and everything that is related, we can get to
functions.  The concept of a function is itself very close to
substitution, and to our `with' form.  For example, when we write:

  {with {x 5}
    {+ x x}}

then the "{+ x x}" body is itself parametrized over some value for `x'.
If we take this expression and take out the "5", we're left with
something that looks like a function:

  {with {x}
    {+ x x}}

We only need to replace `with' to indicate the difference from a real
`with' -- this form is missing a value:

  {fun {x}
    {+ x x}}

Now we have a new form in our language, one that should have a function
as its meaning.  As done with the `with' expression, we also need a form
to use these functions.  We can use `call' for this, so we want:

  {call {fun {x} {+ x x}} 5}

to be the same as the original thing we began with -- the `fun'
expression is like the `with' expression with no value, and applying it
on `5' is the same getting back to:

  {with {x 5} {+ x x}}

Of course, this did not help much.  So far, we just came up with a way
to use local bindings that is more verbose from what we started with.

What we're really missing is a way to name these functions.  If we get
the right evaluation rules, we can evaluate a `fun' expression to some
value -- which will allow us to bind it to a variable using `with'.
Something like this:

  {with {double {fun {x} {+ x x}}}
    {* {call double 5}
       {call double 6}}}

In this expression, we say that `x' is the formal parameter (or
argument), and the `5' and `6' are actual parameters (sometimes
abbreviated as formals and actuals).

[A different approach was used in the homework: a function definition is
much like a `with' form but without any value, and dealing with a
function application is much like dealing with a `with' form, except
that the value is from one place (the call site), and the body
expression and named variable are from a different place (the function
definition).]

========================================================================
>>> Implementing First Class Function Values

This is a simple plan, but it is directly related to how functions are
used in our language -- there are three basic approaches that classify
programming languages:

1. First order: functions are not real values.  They cannot be used or
   returned as values by other functions.  This means that they cannot
   be stored in data values.  This is what you are/will be implementing
   in homework 3, and what most `conventional' languages have.

2. Higher order: functions can receive and return other functions as
   values.  This is what you get in C.

3. First class: functions are values with all the rights of other
   values.  In particular, they can be supplied to other functions,
   returned from functions, stored in data structures, and new functions
   can be created at run-time.

The last category is the most interesting one.  Back in the old days,
complex expressions were not first-class in that they could not be
freely composed.  This is still the case in machine-code: as we've seen
earlier, to compute an expression such as

  (-b + sqrt(b^2 - 4*a*c)) / 2a

you have to do something like this:

  x = b * b
  y = 4 * a
  y = y * c
  x = x - y
  x = sqrt(x)
  y = -b
  x = y + x
  y = 2 * a
  s = x / y

In other words, every intermediate value needs to have its own name.
But with proper ("high-level") programming languages (at least most of
them...) you can just write the original expression, with no names for
these values.

With first-class functions something similar happens -- it is possible
to have complex expressions that consume and return functions, and they
do not need to be named.

What we get with our `fun' expression (if we can make it work) is
exactly this: it generates a function, and you can choose to either bind
it to a name, or not.

This has a major effect on the "personality" of a programming language
as we will see.  In fact, just adding this feature will make our
language much more advanced than some popular languages you know so far.

========================================================================

Now for the implementation -- we call this new language FLANG.

First, the BNF:

  <FLANG> ::= <num>
            | { + <FLANG> <FLANG> }
            | { - <FLANG> <FLANG> }
            | { * <FLANG> <FLANG> }
            | { / <FLANG> <FLANG> }
            | { with { <id> <FLANG> } <FLANG> }
            | <id>
            | { fun { <id> } <FLANG> }
            | { call <FLANG> <FLANG> }

And the matching type definition:

  (define-type FLANG
    [Num  (n number?)]
    [Add  (lhs FLANG?) (rhs FLANG?)]
    [Sub  (lhs FLANG?) (rhs FLANG?)]
    [Mul  (lhs FLANG?) (rhs FLANG?)]
    [Div  (lhs FLANG?) (rhs FLANG?)]
    [Id   (name symbol?)]
    [With (name symbol?) (named FLANG?) (body FLANG?)]
    [Fun  (name symbol?) (body FLANG?)]
    [Call (fun-expr FLANG?) (arg-expr FLANG?)])

The parser for this grammar is, as usual, straightforward:

  ;; parse-sexpr : s-expr -> FLANG
  ;; to convert s-expressions into FLANGs
  (define (parse-sexpr sexpr)
    (match sexpr
      [(number: n)    (Num n)]
      [(symbol: name) (Id name)]
      [(cons 'with more)
       (match sexpr
         [(list 'with (list (symbol: name) named) body)
          (With name (parse-sexpr named) (parse-sexpr body))]
         [else (error 'parse-sexpr "bad `with' syntax in ~s" sexpr)])]
      [(cons 'fun more)
       (match sexpr
         [(list 'fun (list (symbol: name)) body)
          (Fun name (parse-sexpr body))]
         [else (error 'parse-sexpr "bad `fun' syntax in ~s" sexpr)])]
      [(list op left right)
       (let ([make-node
              (match op
                ['+ Add]
                ['- Sub]
                ['* Mul]
                ['/ Div]
                ['call Call]
                [else (error 'parse-sexpr "don't know about ~s" op)])])
         (make-node (parse-sexpr left)
                    (parse-sexpr right)))]
      [else (error 'parse-sexpr "bad syntax in ~s" sexpr)]))

We also need to patch up the substitution function to deal with these
things.  The scoping rule for the new function form is, unsurprisingly,
similar to the rule of `with', except that there is no extra expression
now, and the scoping rule for `call' is the same as for the arithmetic
operators:

    N[v/x]                = N

    {+ E1 E2}[v/x]        = {+ E1[v/x] E2[v/x]}

    {- E1 E2}[v/x]        = {- E1[v/x] E2[v/x]}

    {* E1 E2}[v/x]        = {* E1[v/x] E2[v/x]}

    {/ E1 E2}[v/x]        = {/ E1[v/x] E2[v/x]}

    y[v/x]                = y
    x[v/x]                = v

    {with {y E1} E2}[v/x] = {with {y E1[v/x]} E2[v/x]}
    {with {x E1} E2}[v/x] = {with {x E1[v/x]} E2}

    {call E1 E2}[v/x]     = {call E1[v/x] E2[v/x]}

    {fun {y} E}[v/x]      = {fun {y} E[v/x]}
    {fun {x} E}[v/x]      = {fun {x} E}

And the matching code:

  ;; subst : FLANG symbol FLANG -> FLANG
  ;; substitutes the second argument with the third argument in the
  ;; first argument, as per the rules of substitution; the resulting
  ;; expression contains no free instances of the second argument
  (define (subst expr from to)
    (cases expr
      [(Num n) expr]
      [(Add l r) (Add (subst l from to) (subst r from to))]
      [(Sub l r) (Sub (subst l from to) (subst r from to))]
      [(Mul l r) (Mul (subst l from to) (subst r from to))]
      [(Div l r) (Div (subst l from to) (subst r from to))]
      [(Id name) (if (eq? name from) to expr)]
      [(With bound-id named-expr bound-body)
       (With bound-id
             (subst named-expr from to)
             (if (eq? bound-id from)
               bound-body
               (subst bound-body from to)))]
      [(Call l r) (Call (subst l from to)
                        (subst r from to))]
      [(Fun bound-id bound-body)
       (if (eq? bound-id from)
         expr
         (Fun bound-id (subst bound-body from to)))]))

========================================================================

Now, before we start working on an evaluator, we need to decide on what
exactly do we use to represent values of this language.  Before we had
functions, we had only numbers and we used (Scheme) numbers to represent
them.  Now we have two kinds of values -- numbers and functions.  It
seems easy enough to continue using Scheme numbers to represent numbers,
but what about functions?  What should be the result of evaluating

  {fun {x} {+ x 1}}

?  Well, this is the new toy we have: it is a function *value*, which is
something that can be used just like numbers, but instead of arithmetic
operations, we can `call' these things.

To accommodate this, we will change our implementation strategy a
little: we will use our syntax objects for numbers (`(Num n)' instead of
just `n'), which will be a little inconvenient when we do the arithmetic
operations, but it will simplify life by making it possible to evaluate
functions in a similar way: simply return their own syntax object as
their values.  This means that evaluating:

  (Add (Num 1) (Num 2))

now yields

  (Num 3)

and a number `(Num 5)' evaluates to `(Num 5)'.

In a similar way, `(Fun 'x (Num 2))' evaluates to `(Fun 'x (Num 2))'.

Why would this work?  Well, because `call' will be very similar to
`with' -- the only difference is that its arguments are ordered a little
differently, being retrieved from the function that is applied and the
argument.

The formal evaluation rules are therefore treating functions like
numbers, and use the syntax object to represent both values:

  eval(N)         = N

  eval({+ E1 E2}) = eval(E1) + eval(E2)

  eval({- E1 E2}) = eval(E1) - eval(E2)

  eval({* E1 E2}) = eval(E1) * eval(E2)

  eval({/ E1 E2}) = eval(E1) / eval(E2)

  eval(id)        = error!

  eval({with {x E1} E2}) = eval(E2[eval(E1)/x])

  eval(FUN)       = FUN ; assuming FUN is a function expression

  eval({call E1 E2})
                  = eval(Ef[eval(E2)/x])   if eval(E1)={fun {x} Ef}
                  = error!                 otherwise

but note that we have two kinds of values, so we need to check the
arithmetic operation's arguments too:

  eval({+ E1 E2}) = eval(E1) + eval(E2)
                      if eval(E1) & eval(E2) are numbers
                      otherwise error!
  ...

And the corresponding code is:

  ;; eval : FLANG -> FLANG                       ; <- note return type
  ;; evaluates FLANG expressions by reducing them to *expressions*
  (define (eval expr)
    (cases expr
      [(Num n) expr]                             ; <- change here
      [(Add l r) (arith-op + (eval l) (eval r))]
      [(Sub l r) (arith-op - (eval l) (eval r))]
      [(Mul l r) (arith-op * (eval l) (eval r))]
      [(Div l r) (arith-op / (eval l) (eval r))]
      [(With bound-id named-expr bound-body)
       (eval (subst bound-body
                    bound-id
                    (eval named-expr)))]         ; <- no `(Num ...)'
      [(Id name) (error 'eval "free identifier: ~s" name)]
      [(Fun bound-id bound-body) expr]           ; <- similar to `Num'
      [(Call (Fun bound-id bound-body) arg-expr) ; <- nested pattern
       (eval (subst bound-body                   ; <- just like `with'
                    bound-id
                    (eval arg-expr)))]
      [(Call something arg-expr)
       (error 'eval "`call' expects a function, got: ~s" something)]))

and we can make it easier to use if we make `run' convert the result to
a number:

  ;; run : string -> number
  ;; evaluate a FLANG program contained in a string
  (define (run str)
    (let ([result (eval (parse str))])
      (cases result
        [(Num n) n]
        [else (error 'run
                     "evaluation returned a non-number: ~s" result)])))

We only need this simple utility to make things work:

  ;; arith-op : (num num -> num) FLANG FLANG -> FLANG ; <- note H.O type
  ;; gets a Scheme numeric binary operator, and uses it within an FLANG
  ;; `Num' wrapper
  (define (arith-op op expr1 expr2)
    (define (Num->number e)
      (cases e
        [(Num n) n]
        [else (error 'arith-op "expects a number, got: ~s" e)]))
    (Num (op (Num->number expr1) (Num->number expr2))))

A few simple tests:

  (test (run "{call {fun {x} {+ x 1}} 4}")
        => 5)
  (test (run "{with {add3 {fun {x} {+ x 3}}}
                {call add3 1}}")
        => 4)
  (test (run "{with {add3 {fun {x} {+ x 3}}}
                {with {add1 {fun {x} {+ x 1}}}
                  {with {x 3}
                    {call add1 {call add3 x}}}}}")
        => 7)

There is still a problem with this version.  First a question -- if
`call' is similar to arithmetic operations (and to `with' in what it
actually does), then how come the code is different enough that it
doesn't even need an auxiliary function?

Second question: what *should* happen if we evaluate this:

  (run "{with {identity {fun {x} x}}
          {with {foo {fun {x} {+ x 1}}}
            {call {call identity foo} 123}}}")
  (run "{call {call {fun {x} {call x 1}}
                    {fun {x} {fun {y} {+ x y}}}}
              123}")

Third question, what *will* happen if we do the above?

The following simple fix takes care of this:

  ;; eval : FLANG -> FLANG
  ;; evaluates FLANG expressions by reducing them to *expressions*
  (define (eval expr)
    (cases expr
      [(Num n) expr]
      [(Add l r) (arith-op + (eval l) (eval r))]
      [(Sub l r) (arith-op - (eval l) (eval r))]
      [(Mul l r) (arith-op * (eval l) (eval r))]
      [(Div l r) (arith-op / (eval l) (eval r))]
      [(With bound-id named-expr bound-body)
       (eval (subst bound-body
                    bound-id
                    (eval named-expr)))]
      [(Id name) (error 'eval "free identifier: ~s" name)]
      [(Fun bound-id bound-body) expr]
      [(Call fun-expr arg-expr)
       (let ([fval (eval fun-expr)])        ; <- need to evaluate this!
         (cases fval
           [(Fun bound-id bound-body)
            (eval (subst bound-body
                         bound-id
                         (eval arg-expr)))]
           [else (error 'eval "`call' expects a function, got: ~s"
                              fval)]))]))

The complete code is:

  ----------------------------------------------------------------------
  (define-type FLANG
    [Num  (n number?)]
    [Add  (lhs FLANG?) (rhs FLANG?)]
    [Sub  (lhs FLANG?) (rhs FLANG?)]
    [Mul  (lhs FLANG?) (rhs FLANG?)]
    [Div  (lhs FLANG?) (rhs FLANG?)]
    [Id   (name symbol?)]
    [With (name symbol?) (named FLANG?) (body FLANG?)]
    [Fun  (name symbol?) (body FLANG?)]
    [Call (fun-expr FLANG?) (arg-expr FLANG?)])

  ;; parse-sexpr : s-expr -> FLANG
  ;; to convert s-expressions into FLANGs
  (define (parse-sexpr sexpr)
    (match sexpr
      [(number: n)    (Num n)]
      [(symbol: name) (Id name)]
      [(cons 'with more)
       (match sexpr
         [(list 'with (list (symbol: name) named) body)
          (With name (parse-sexpr named) (parse-sexpr body))]
         [else (error 'parse-sexpr "bad `with' syntax in ~s" sexpr)])]
      [(cons 'fun more)
       (match sexpr
         [(list 'fun (list (symbol: name)) body)
          (Fun name (parse-sexpr body))]
         [else (error 'parse-sexpr "bad `fun' syntax in ~s" sexpr)])]
      [(list op left right)
       (let ([make-node
              (match op
                ['+ Add]
                ['- Sub]
                ['* Mul]
                ['/ Div]
                ['call Call]
                [else (error 'parse-sexpr "don't know about ~s" op)])])
         (make-node (parse-sexpr left)
                    (parse-sexpr right)))]
      [else (error 'parse-sexpr "bad syntax in ~s" sexpr)]))

  ;; parse : string -> FLANG
  ;; parses a string containing an FLANG expression to a FLANG AST
  (define (parse str)
    (parse-sexpr (string->sexpr str)))

  ;; subst : FLANG symbol FLANG -> FLANG
  ;; substitutes the second argument with the third argument in the
  ;; first argument, as per the rules of substitution; the resulting
  ;; expression contains no free instances of the second argument
  (define (subst expr from to)
    (cases expr
      [(Num n) expr]
      [(Add l r) (Add (subst l from to) (subst r from to))]
      [(Sub l r) (Sub (subst l from to) (subst r from to))]
      [(Mul l r) (Mul (subst l from to) (subst r from to))]
      [(Div l r) (Div (subst l from to) (subst r from to))]
      [(Id name) (if (eq? name from) to expr)]
      [(With bound-id named-expr bound-body)
       (With bound-id
             (subst named-expr from to)
             (if (eq? bound-id from)
               bound-body
               (subst bound-body from to)))]
      [(Call l r) (Call (subst l from to) (subst r from to))]
      [(Fun bound-id bound-body)
       (if (eq? bound-id from)
         expr
         (Fun bound-id (subst bound-body from to)))]))

  ;; arith-op : (num num -> num) FLANG FLANG -> FLANG
  ;; gets a Scheme numeric binary operator, and uses it within an FLANG
  ;; `Num' wrapper
  (define (arith-op op expr1 expr2)
    (define (Num->number e)
      (cases e
        [(Num n) n]
        [else (error 'arith-op "expects a number, got: ~s" e)]))
    (Num (op (Num->number expr1) (Num->number expr2))))

  ;; eval : FLANG -> FLANG
  ;; evaluates FLANG expressions by reducing them to *expressions*
  (define (eval expr)
    (cases expr
      [(Num n) expr]
      [(Add l r) (arith-op + (eval l) (eval r))]
      [(Sub l r) (arith-op - (eval l) (eval r))]
      [(Mul l r) (arith-op * (eval l) (eval r))]
      [(Div l r) (arith-op / (eval l) (eval r))]
      [(With bound-id named-expr bound-body)
       (eval (subst bound-body
                    bound-id
                    (eval named-expr)))]
      [(Id name) (error 'eval "free identifier: ~s" name)]
      [(Fun bound-id bound-body) expr]
      [(Call fun-expr arg-expr)
       (let ([fval (eval fun-expr)])
         (cases fval
           [(Fun bound-id bound-body)
            (eval (subst bound-body
                         bound-id
                         (eval arg-expr)))]
           [else (error 'eval "`call' expects a function, got: ~s"
                              fval)]))]))

  ;; run : string -> number
  ;; evaluate a FLANG program contained in a string
  (define (run str)
    (let ([result (eval (parse str))])
      (cases result
        [(Num n) n]
        [else (error 'run
                     "evaluation returned a non-number: ~s" result)])))

  ;; tests
  (test (run "{call {fun {x} {+ x 1}} 4}")
        => 5)
  (test (run "{with {add3 {fun {x} {+ x 3}}}
                {call add3 1}}")
        => 4)
  (test (run "{with {add3 {fun {x} {+ x 3}}}
                {with {add1 {fun {x} {+ x 1}}}
                  {with {x 3}
                    {call add1 {call add3 x}}}}}")
        => 7)
  (test (run "{with {identity {fun {x} x}}
                {with {foo {fun {x} {+ x 1}}}
                  {call {call identity foo} 123}}}")
        => 124)
  (test (run "{call {call {fun {x} {call x 1}}
                          {fun {x} {fun {y} {+ x y}}}}
                    123}")
        => 124)
  ----------------------------------------------------------------------

========================================================================
>>> Introducing Scheme's `lambda'

fun & lambda
difference between lambda and simple values
scheme puzzle -- (+ ((?)) 3)

;; currify : (A B -> C) -> (A -> B -> C)
;; convert a double-argument function to a curried one
(define (currify f)
  (lambda (x) (lambda (y) (f x y))))
(define plus (currify +))
(test ((plus 1) 2) => 3)
(test (((currify +) 1) 2) => 3)
(test (map (plus 1) '(1 2 3)) => '(2 3 4))

not being able to do recursive functions with `let'
let* as a derived form
let with lambda in scheme --> can be a derived form
how `if' can be used to implement `and' `or' as derived forms

========================================================================
>>> More Lambdas: Functions as Objects, Currying

Get back quickly over the concept of a function in Scheme.  Newtonian
syntax vs. a lambda expression.

Don't be fooled into making a bogus connection between Scheme's syntax,
and its `unique' powers...  The fact is that it is not the only language
that has this capability.  For example, this:

  (define (f g) (g 2 3))
  (f +) ==> 5
  (f *) ==> 6
  (f (lambda (x y) (+ (square x) (square y)))) ==> 13

Can be written in JavaScript like this:

  function f(g) { return g(2,3); }
  function square(x) { return x*x; }
  window.alert(f(function (x,y) { return square(x) + square(y); }))

========================================================================
>>> Using Functions as Objects

A very important aspect of Scheme -- using "higher order" functions --
functions that get and return functions.  Here is a very simple example:

  (define (f x) (lambda () x))
  (define a (f 2))
  (a)  -->  2
  (define b (f 3))
  (b)  -->  3

Note - what we get is actually an object that remembers (by the
substitution we're doing) a number.
How about:

  (define aa (f a))
  (aa)    -->  #<procedure> (this is a)
  ((aa))  -->  2

Take this idea to the next level:

  (define (kons x y)
    (lambda (b)
      (if b x y)))
  (define (kar x) (x #t))
  (define (kdr x) (x #f))
  (define a (kons 1 2))
  (define b (kons 3 4))
  (list (kar a) (kdr a))
  (list (kar b) (kdr b))

Even more -- why should the internal function expect a boolean and
choose what to return?  We can simply expect a function that will take
the two values and return one:

  (define (kons x y)
    (lambda (s)
      (s x y)))
  (define (kar x) (x (lambda (x y) x)))
  (define (kdr x) (x (lambda (x y) y)))
  (define a (kons 1 2))
  (define b (kons 3 4))
  (list (kar a) (kdr a))
  (list (kar b) (kdr b))

Also in JavaScript:

  function kons(x,y) {
    return function(s) { return s(x, y); }
  }
  function kar(x) { return x(function(x,y){ return x; }); }
  function kdr(x) { return x(function(x,y){ return y; }); }
  a = kons(1,2);
  b = kons(3,4);
  window.alert('a = <' + kar(a) + ',' + kdr(a) + '>' );
  window.alert('b = <' + kar(b) + ',' + kdr(b) + '>' );

========================================================================
>>> Currying

How is this done?

Functions for translating between normal and curried versions.

  (define (currify f)
    (lambda (x)
      (lambda (y)
        (f x y))))

Usages -- common with H.O. functions like map, where we want to `fix'
one argument.

When dealing with such higher-order code, the types are very helpful,
since every arrow corresponds to a function:

  ;; currify : (A B -> C) -> (A -> (B -> C))

It is common to make a function `->' type associate to the right, so
this type can be written as:

  ;; currify : (A B -> C) -> (A -> B -> C)

(Which is also the same as:

  ;; currify : (A B -> C) -> A -> B -> C

but that's a little confusing...)

========================================================================
>>> Using Higher-Order & Anonymous Functions

Say that we have a function for estimating derivatives of a function at
a specific point:

  (define dx 0.01)

  ;; deriv : (num -> num) num -> num
  ;; compute the derivative of `f' at the given point `x'
  (define (deriv f x)
    (/ (- (f (+ x dx)) (f x)) dx))

  ;; integrate : (num -> num) num -> num
  ;; compute an integral of `f' at the given point `x'
  (define (integrate f x)
    (define (loop y acc)
      (if (> y x)
        (/ acc dx)
        (loop (+ y dx) (+ acc (f y)))))
    (loop 0 0))

And say that we want to try out various functions given some `plot-fun'
procedure that knows how to draw graphs of numeric functions, for
example:

  (plot-fun sin)

To actually try this out, write this:

  (require (lib "plot.ss" "plot"))
  (define (plot-fun fun)
    (plot (line fun (color 'red))))

The problem is that `plot-fun' expects a single `(num -> num)' function
-- if we want to try it with a derivative, we can do this:

  ;; sin-deriv : num -> num
  ;; the derivative of sin
  (define (sin-deriv x) (deriv sin x))
  (plot-fun sin-deriv)

But this will get very tedious very fast -- it is much simpler to use an
anonymous function:

  (plot-fun (lambda (x) (deriv sin x)))

we can even verify that our derivative is correct by comparing a known
function to its derivative

  (plot-fun (lambda (x) (- (deriv sin x) (cos x))))

But it's still not completely natural to do these things -- you need to
explicitly combine functions, which is not too convenient.  Instead of
doing this, we can write H.O. functions that will work with functional
inputs and outputs.  For example, we can write a function to subtract
functions:

  ;; fsub : (num -> num) (num -> num) -> (num -> num)
  ;; subtracts two numeric 1-argument functions
  (define (fsub f g)
    (lambda (x) (- (f x) (g x))))

and the same for the derivative:

  ;; fderiv : (num -> num) -> (num -> num)
  ;; compute the derivative function of `f'
  (define (fderiv f)
    (lambda (x) (deriv f x)))

Now we can try the same in a much easier way:

  (plot-fun (fsub (fderiv sin) cos))

More than that -- our `fderiv' could be created from `deriv'
automatically:

  ;; currify : (A B -> C) -> (A -> B -> C)
  (define (currify f)
    (lambda (x) (lambda (y) (f x y))))

  ;; fderiv : (num -> num) -> (num -> num)
  (define fderiv (currify deriv))

Same principle with `fsub':

  ;; binop->fbinop : (num num -> num)
  ;;                 -> (num -> num) (num -> num) -> (num -> num)
  ;; turns an arithmetic binary operator to a function operator
  (define (binop->fbinop op)
    (lambda (f g)
      (lambda (x) (op (f x) (g x)))))

  ;; fsub : (num -> num) (num -> num) -> (num -> num)
  (define fsub (binop->fbinop -))

We can do this with anything -- developing a rich library of functions
and functionals is extremely easy...  Here's a pretty extensive yet very
short library of functions:

  ----------------------------------------------------------------------
  (define (currify f)
    (lambda (x) (lambda (y) (f x y))))
  (define (binop->fbinop op)
    (lambda (f g)
      (lambda (x) (op (f x) (g x)))))
  (define (compose f g)
    (lambda (x) (f (g x))))

  (define dx 0.01)
  (define (deriv f x)
    (/ (- (f (+ x dx)) (f x)) dx))
  (define (integrate f x)
    (define over (if (< x 0) < >))
    (define step (if (< x 0) - +))
    (define add  (if (< x 0) - +))
    (define (loop y acc)
      (if (over y x)
        (* acc dx)
        (loop (step y dx) (add acc (f y)))))
    (loop 0 0))

  (define fadd (binop->fbinop +))
  (define fsub (binop->fbinop -))
  (define fmul (binop->fbinop *))
  (define fdiv (binop->fbinop /))
  (define fderiv     (currify deriv))
  (define fintegrate (currify integrate))
  ;; ...
  ----------------------------------------------------------------------

Examples:

  ;; want to verify that `integrate' is the opposite of `deriv':
  ;;   take a function, subtract it from its derivative's integral
  (plot-fun (fsub sin (fintegrate (fderiv sin))))

  ;; want to magnify the errors? -- here's how you magnify:
  (plot-fun (compose ((currify *) 5) sin))

  ;; so:
  (plot-fun (compose ((currify *) 20)
                     (fsub sin (fintegrate (fderiv sin)))))

All of this is similar to run-time code generation, but not really.  The
only thing that `fderiv' does is take a function and store it somewhere
in the returned function, then when that function receives a number, it
uses the stored function and send it to deriv with the number.  We could
simply write deriv as what `fderiv' is -- which is the *real* derivative
function:

  (define (deriv f)
    (lambda (x)
      (/ (- (f (+ x dx)) (f x)) dx)))

but again, this is not faster or slower than the plain deriv.  However,
there are some situations where we can do some of the computation on the
first-stage argument, saving work from the second stage.  Here is a
cooked-to-exaggeration example -- we want a function that receives two
inputs x,y and returns fib(x)*y, but we must use a stupid `fib':

  (define (fib n)
    (if (<= n 1)
      n
      (+ (fib (- n 1)) (fib (- n 2)))))

The function we want is:

  (define (bogus x y)
    (* (fib x) y))

If we currify it as usual (or just use `currify'), we get:

  (define (bogus x)
    (lambda (y)
      (* (fib x) y)))

And try this several times:

  (define bogus24 (bogus 24))
  (map bogus24 '(1 2 3 4 5))

But in the definition of `bogus', notice that `(fib x)' does not depend
on `y' -- so we can rewrite it a little differently:

  (define (bogus x)
    (let ([fibx (fib x)])
      (lambda (y)
        (* fibx y))))

and trying the above again is much faster now:

  (define bogus24 (bogus 24))
  (map bogus24 '(1 2 3 4 5))

========================================================================
>>> Substitution Caches

Evaluating using substitutions is very inefficient -- at each scope, we
copy a piece of the program AST.  This includes all function calls which
implies an impractical cost (function calls should be *cheap*!).

To get over this, we want to use a cache of substitutions.

Basic idea: we begin evaluating with no cached substitutions, then
collect them as we encounter bindings.

Implies another change for our evaluator: we don't really substitute
identifiers until we get there, so when we reach an identifier it is no
longer an error -- we must consult the substitution cache at that point.

========================================================================
>>> Initial Implementation of Cache Functionality

First, we need a type for a substitution cache.  For this we will use a
list of lists of two elements each -- a name and its value FLANG:

  ;; define a type called subst-cache to be:
  ;;   subst-cache := (list-of (list symbol FLANG))

(This is just a comment, not a real definition used for now.)

We need to have an empty substitution cache, a way to extend it, and a
way to look things up:

  ;; empty-subst : subst-cache
  (define empty-subst null)

  ;; extend : symbol FLANG subst-cache -> subst-cache
  (define (extend name val sc)
    (cons (list name val) sc))

  ;; lookup : symbol subst-cache -> FLANG
  (define (lookup name sc)
    (cond [(null? sc) (error 'lookup "no binding for ~s" name)]
          [(eq? name (first (first sc))) (second (first sc))]
          [else (lookup name (rest sc))]))

Actually, the reason to use such list of lists is that Scheme has a
built-in procedure called `assq' that will do this kind of search
(`assq' is a search in an association list using `eq?' for the key
comparison).  This is a version of `lookup' that uses `assq':

  ;; lookup : symbol subst-cache -> FLANG
  (define (lookup name sc)
    (let ([cell (assq name sc)])
      (if cell
        (second cell)
        (error 'lookup "no binding for ~s" name))))

========================================================================
>>> Formal Rules for Cached Substitutions

The formal evaluation rules are now different.  Evaluation carries along
a "substitution cache" that begins its life as empty: so `eval' needs an
extra argument.  We begin by writing the rules that deal with the cache,
and use the above function names for simplicity -- the behavior of the
three definitions can be summed up in a single rule for `lookup':

  lookup(x,empty-subst)     = error!
  lookup(x,extend(x,E,sc))  = E
  lookup(x,extend(y,E,sc))  = lookup(x,sc)  if `x' is not `y'

And now we can write the new rules for `eval'

  eval(N,sc)                = N
  eval({+ E1 E2},sc)        = eval(E1,sc) + eval(E2,sc)
  eval({- E1 E2},sc)        = eval(E1,sc) - eval(E2,sc)
  eval({* E1 E2},sc)        = eval(E1,sc) * eval(E2,sc)
  eval({/ E1 E2},sc)        = eval(E1,sc) / eval(E2,sc)
  eval(x,sc)                = lookup(x,sc)
  eval({with {x E1} E2},sc) = eval(E2,extend(x,eval(E1,sc),sc))
  eval({fun {x} E},sc)      = {fun {x} E}
  eval({call E1 E2},sc)
           = eval(Ef,extend(x,eval(E2,sc),sc))
                             if eval(E1,sc)={fun {x} Ef}
           = error!          otherwise

Note that there is no mention of `subst' -- the whole point is that we
don't really do substitution, but use the cache instead.  The `lookup'
rules, and the places where `extend' is used replaces `subst', and
therefore specifies our scoping rules.

Also note that the rule for `call' is still very similar to the rule for
`with', but it looks like we have lost something -- the interesting bit
with substituting into `fun' expressions.

========================================================================
>>> Evaluating with Substitution Caches

Implementing the new `eval' is easy now -- it is extended in the same
way that the formal `eval' rule is extended:

  ;; eval : FLANG subst-cache -> FLANG
  ;; evaluates FLANG expressions by reducing them to expressions
  (define (eval expr sc)
    (cases expr
      [(Num n) expr]
      [(Add l r) (arith-op + (eval l sc) (eval r sc))]
      [(Sub l r) (arith-op - (eval l sc) (eval r sc))]
      [(Mul l r) (arith-op * (eval l sc) (eval r sc))]
      [(Div l r) (arith-op / (eval l sc) (eval r sc))]
      [(With bound-id named-expr bound-body)
       (eval bound-body
             (extend bound-id (eval named-expr sc) sc))]
      [(Id name) (lookup name sc)]
      [(Fun bound-id bound-body) expr]
      [(Call fun-expr arg-expr)
       (let ([fval (eval fun-expr sc)])
         (cases fval
           [(Fun bound-id bound-body)
            (eval bound-body
                  (extend bound-id (eval arg-expr sc) sc))]
           [else (error 'eval "`call' expects a function, got: ~s"
                              fval)]))]))

Again, note that we don't need `subst' anymore, but the rest of the code
(the data type definition, parsing, and `arith-op') is exactly the same.

Finally, we need to make sure that `eval' is initially called with an
empty cache.  This is easy to change in our main `run' entry point:

  ;; run : string -> number
  ;; evaluate a FLANG program contained in a string
  (define (run str)
    (let ([result (eval (parse str) empty-subst)])
      (cases result
        [(Num n) n]
        [else (error 'run
                     "evaluation returned a non-number: ~s" result)])))

The full code (including the same tests) follows.  Note that one test
does not pass.

  ----------------------------------------------------------------------
  (define-type FLANG
    [Num  (n number?)]
    [Add  (lhs FLANG?) (rhs FLANG?)]
    [Sub  (lhs FLANG?) (rhs FLANG?)]
    [Mul  (lhs FLANG?) (rhs FLANG?)]
    [Div  (lhs FLANG?) (rhs FLANG?)]
    [Id   (name symbol?)]
    [With (name symbol?) (named FLANG?) (body FLANG?)]
    [Fun  (name symbol?) (body FLANG?)]
    [Call (fun-expr FLANG?) (arg-expr FLANG?)])

  ;; parse-sexpr : s-expr -> FLANG
  ;; to convert s-expressions into FLANGs
  (define (parse-sexpr sexpr)
    (match sexpr
      [(number: n)    (Num n)]
      [(symbol: name) (Id name)]
      [(cons 'with more)
       (match sexpr
         [(list 'with (list (symbol: name) named) body)
          (With name (parse-sexpr named) (parse-sexpr body))]
         [else (error 'parse-sexpr "bad `with' syntax in ~s" sexpr)])]
      [(cons 'fun more)
       (match sexpr
         [(list 'fun (list (symbol: name)) body)
          (Fun name (parse-sexpr body))]
         [else (error 'parse-sexpr "bad `fun' syntax in ~s" sexpr)])]
      [(list op left right)
       (let ([make-node
              (match op
                ['+ Add]
                ['- Sub]
                ['* Mul]
                ['/ Div]
                ['call Call]
                [else (error 'parse-sexpr "don't know about ~s" op)])])
         (make-node (parse-sexpr left)
                    (parse-sexpr right)))]
      [else (error 'parse-sexpr "bad syntax in ~s" sexpr)]))

  ;; parse : string -> FLANG
  ;; parses a string containing an FLANG expression to a FLANG AST
  (define (parse str)
    (parse-sexpr (string->sexpr str)))

  ;; define a type called subst-cache to be:
  ;;   subst-cache := (list-of (list symbol FLANG))

  ;; empty-subst : subst-cache
  (define empty-subst null)

  ;; extend : symbol FLANG subst-cache -> subst-cache
  (define (extend name val sc)
    (cons (list name val) sc))

  ;; lookup : symbol subst-cache -> FLANG
  (define (lookup name sc)
    (let ([cell (assq name sc)])
      (if cell
        (second cell)
        (error 'lookup "no binding for ~s" name))))

  ;; arith-op : (num num -> num) FLANG FLANG -> FLANG
  ;; gets a Scheme numeric binary operator, and uses it within an FLANG
  ;; `Num' wrapper
  (define (arith-op op expr1 expr2)
    (define (Num->number e)
      (cases e
        [(Num n) n]
        [else (error 'arith-op "expects a number, got: ~s" e)]))
    (Num (op (Num->number expr1) (Num->number expr2))))

  ;; eval : FLANG subst-cache -> FLANG
  ;; evaluates FLANG expressions by reducing them to expressions
  (define (eval expr sc)
    (cases expr
      [(Num n) expr]
      [(Add l r) (arith-op + (eval l sc) (eval r sc))]
      [(Sub l r) (arith-op - (eval l sc) (eval r sc))]
      [(Mul l r) (arith-op * (eval l sc) (eval r sc))]
      [(Div l r) (arith-op / (eval l sc) (eval r sc))]
      [(With bound-id named-expr bound-body)
       (eval bound-body
             (extend bound-id (eval named-expr sc) sc))]
      [(Id name) (lookup name sc)]
      [(Fun bound-id bound-body) expr]
      [(Call fun-expr arg-expr)
       (let ([fval (eval fun-expr sc)])
         (cases fval
           [(Fun bound-id bound-body)
            (eval bound-body
                  (extend bound-id (eval arg-expr sc) sc))]
           [else (error 'eval "`call' expects a function, got: ~s"
                              fval)]))]))

  ;; run : string -> number
  ;; evaluate a FLANG program contained in a string
  (define (run str)
    (let ([result (eval (parse str) empty-subst)])
      (cases result
        [(Num n) n]
        [else (error 'run
                     "evaluation returned a non-number: ~s" result)])))

  ;; tests

  (test (run "{call {fun {x} {+ x 1}} 4}")
        => 5)
  (test (run "{with {add3 {fun {x} {+ x 3}}}
                {call add3 1}}")
        => 4)
  (test (run "{with {add3 {fun {x} {+ x 3}}}
                {with {add1 {fun {x} {+ x 1}}}
                  {with {x 3}
                    {call add1 {call add3 x}}}}}")
        => 7)
  (test (run "{with {identity {fun {x} x}}
                {with {foo {fun {x} {+ x 1}}}
                  {call {call identity foo} 123}}}")
        => 124)
  (test (run "{call {call {fun {x} {call x 1}}
                          {fun {x} {fun {y} {+ x y}}}}
                    123}")
        => 124)
  (test (run "{with {x 3}
                {with {f {fun {y} {+ x y}}}
                  {with {x 5}
                    {call f 4}}}}")
        => ???)
  ----------------------------------------------------------------------

========================================================================
>>> Dynamic and Lexical Scopes

This seems like it should work, and it even worked on a few examples,
except for one which was hard to follow.  Seems like we have a bug...

Now we get at a tricky issue that managed to be a problem for *lots* of
language implementors, including the first version of Lisp.  Lets try to
run the following expression -- try to figure out what it will evaluate
to:

  (run "{with {x 3}
          {with {f {fun {y} {+ x y}}}
            {with {x 5}
              {call f 4}}}}")

We expect it to return 7 (at least I do!), but instead it returns 9...
The question is -- *should* it return 9?

What we have arrived to is called "dynamic scope".  Scope is determined
by the dynamic run-time environment (which is represented by our
substitution cache).  This is *almost always* undesirable, as I hope to
convince you.

Before we start, we define two options for a programming language:

* Static Scope (also called Lexical Scope): In a language with static
  scope, each identifier gets its value from the scope of its
  definition, not its use.

* Dynamic Scope: In a language with dynamic scope, each identifier gets
  its value from the scope of its use, not its definition.

Scheme uses lexical scope, our new evaluator uses dynamic, the old
substitution-based evaluator was static etc.

As a side-remark, Lisp began its life as a dynamically-scoped language.
The artifacts of this were (sort-of) dismissed as an implementation bug.
When Scheme was introduced, it was the first Lisp dialect that used
strictly lexical scoping.  (Some Lisp implementations used dynamic scope
for interpreted code and lexical scope for compiled code!)  Emacs Lisp
one of the only alive dialects of Lisp that is still dynamically scoped
by default.  Too see this, compare a version of the above code in
Scheme:

  (let ((x 3))
    (let ([f (lambda (y) (+ x y))])
      (let ((x 5))
        (f 4))))

and the Emacs Lisp version (which looks almost the same):

  (let ((x 3))
    (let ((f (lambda (y) (+ x y))))
      (let ((x 5))
        (funcall f 4))))

which also happens when we use another function on the way:

  (let ((x 3))
    (let ((f (lambda (y) (+ x y))))
      (let ((x 5))
        (blah f 4))))

  (defun blah (func val)
    (funcall func val))

and note that renaming identifiers can lead to different code -- change
that `val' to `x':

  (let ((x 3))
    (let ((f (lambda (y) (+ x y))))
      (let ((x 5))
        (blah f 4))))

  (defun blah (func x)
    (funcall func x))

and you get 8 because the argument name changed the `x' that the
internal function sees!

Consider also this Emacs Lisp function:

  (defun return-x ()
    x)

which has no meaning by itself (`x' is unbound),

  (return-x)

but can be given a dynamic meaning using a `let':

  (let ((x 5)) (return-x))

or a function application:

  (defun foo (x)
    (return-x))

  (foo 5)

========================================================================
>>> Dynamic vs Lexical Scope

And back to the discussion of whether we should use dynamic or lexical
scope:

* The most important fact is that we want to view programs as executed
  by the normal substituting evaluator.  Our original motivation was to
  optimize evaluation only -- not to *change* the semantics!  It follows
  that we want the result of this optimization to behave in the same
  way.  All we need is to evaluate:

    (run "{with {x 3}
            {with {f {fun {y} {+ x y}}}
              {with {x 5}
                {call f 4}}}}")

  in the original evaluator to get convinced that 7 should be the
  correct result (note also that the same code, when translated into
  Scheme, evaluates to 7).

  (Yet, this is a very important optimization, which without it lots of
  programs become too slow to be feasible, so you might claim that
  you're fine with the modified semantics...)

* It does not allow using functions as objects, for example, we have
  seen that we have a functional representation for pairs:

    (define (kons x y)
      (lambda (n)
        (match n
          [1 x]
          [2 y]
          [else (error ...)])))

    (define my-pair (kons 1 2))

  If this is evaluated in a dynamically-scoped language, we do get a
  function as a result, but the values bound to x and y are now gone!
  Using the substitution model we substituted these values in, but now
  they were only held in a cache which no has no entries for them...

  In the same way, currying would not work, our nice `deriv' function
  would not work etc etc etc.

  (Try this in Emacs Lisp -- the last Lisp dialect that is in real use
  and uses dynamic scoping.)

* Makes reasoning impossible, because any piece of code behaves in a way
  that *cannot* be predicted until run-time.  For example, if dynamic
  scoping was used in Scheme, then you wouldn't be able to know what
  this function is doing:

    (define (foo)
      x)

  As it is, it will cause a run-time error, but if you call it like
  this:

    (let ([x 1])
      (foo))

  then it will return 1, and if you later do this:

    (define (bar x)
      (foo))

    (let ([x 1])
      (bar 2))

  then you would get 2!

  These problems can be demonstrated in Emacs Lisp too, but Scheme goes
  one step further -- it uses the same rule for evaluating a function as
  well as its values (Lisp uses a different name-space for functions).
  Because of this, you cannot even rely on the following function:

    (define (add x y)
      (+ x y))

  to always add x and y!  -- A similar example to the above:

    (let ([+ -])
      (add 1 2))

  would return -1!

* Many so-called "scripting" languages begin their lives with dynamic
  scoping.  The main reason, as we've seen, is that implementing it is
  extremely simple (no, *nobody* does substitution in the real world!
  (Well, *almost* nobody...)).

  Another reason is that these problems make life impossible if you want
  to use functions as object like you do in Scheme, so you notice them
  very fast -- but in a `normal' language without first-class functions,
  problems are not as obvious.

* For example, bash has `local' variables, but they have dynamic scope:

    x="the global x"
    print_x() { echo "The current value of x is \"$x\""; }
    foo() { local x="x from foo"; print_x; }
    print_x; foo; print_x

  Perl began its life with dynamic scope for variables that are declared
  `local':

    $x="the global x";
    sub print_x { print "The current value of x is \"$x\"\n"; }
    sub foo { local($x); $x="x from foo"; print_x; }
    print_x; foo; print_x;

  When faced with this problem, "the Perl way" was, obviously, not to
  remove or fix features, but to pile them up -- so local *still*
  behaves in this way, and now there is a `my' declaration which
  achieves proper lexical scope...

  There are other examples of languages that changed, and languages that
  want to change (e.g, nobody likes dynamic scope in Emacs Lisp, but
  there's just too much code now).

* This is still a tricky issue, like any other issue with bindings.  For
  example, googling got me quickly to this site:

    http://www.hetland.org/python/instant-python.php

  which is confused about what "dynamic scoping" is...  It claims that
  Python uses dynamic scope (Search for "Python uses dynamic as opposed
  to lexical scoping"), yet python always used lexical scope rules, as
  can be seen by translating their code to Scheme (ignore side-effects
  in this computation):

    (define (orange-juice)
      (* x 2))
    (define x 3)
    (define y (orange-juice)) ; y is now 6
    (define x 1)
    (define y (orange-juice)) ; y is now 2

  or by trying this in Python:

    def orange_juice():
      return x*2
    def foo(x):
      return orange_juice()
    foo(2)

  The real problem of python (pre 2.1, and pre 2.2 without the funny
    from __future__ import nested_scope
  line) is that it didn't create closures, which we will talk about
  shortly.

========================================================================
>>> Implementing Lexical Scope: Closures and Environments

So how do we fix this?

Lets go back to the root of the problem: the new evaluator does not
behave in the same way as the substituting evaluator.  In the old
evaluator, it was easy to see how functions can behave as objects that
remember values.  For example, when we do this:

  {with {x 1}
    {fun {y}
      {+ x y}}}

the result was a function value, which actually was the syntax object
for this:

  {fun {y} {+ 1 y}}

Now if we call this function from someplace else like:

  {with {f {with {x 1} {fun {y} {+ x y}}}}
    {with {x 2}
      {call f 3}}}

it is clear what the result will be: f is bound to a function that adds
1 to its input, so in the above the later binding for `x' has no effect
at all.

But with the caching evaluator, the value of

  {with {x 1}
    {fun {y}
      {+ x y}}}

is simply:

  {fun {y} {+ x y}}

and there is no place where we save the 1 -- *that's* the root of our
problem.  (That's also what makes people suspect that using `lambda' in
Scheme involves some inefficient code-recompiling magic.)  In fact, we
can verify that by inspecting the returned value, and see that it does
contain a free identifier.

Clearly, we need to create an object that contains the body and the
argument list, like the function syntax object -- but we don't do any
substitution, so in addition to the body an argument name(s) we need to
remember that we still need to substitute x by 1.  This means that the
pieces of information we need to know are:

  - formal argument(s):   {y}
  - body:                 {+ x y}
  - substitutions we owe: [1/x]

and that last bit has the missing 1.  The resulting object is called a
`closure' because it closes the function body over the substitutions
that are still pending (its environment).

So, the first change is in the value of functions which now need all
these pieces, unlike the `Fun' case for the syntax object.

A second place that needs changing is the when functions are called.
When we're done evaluating the `call' arguments (the function value and
the argument value) but before we apply the function we have two
*values* -- there is no more use for the current substitution cache at
this point: we have finished dealing with all substitutions that were
necessary over the current expression -- we now continue with evaluating
the body of the function, with the new substitutions for the formal
arguments and actual values given.  But the body itself is the same one
we had before -- which is the previous body with its suspended
substitutions that we *still* did not do.

Rewrite the evaluation rules -- all are the same except for evaluating a
`fun' form and a `call' form:

  eval(N,sc)                = N
  eval({+ E1 E2},sc)        = eval(E1,sc) + eval(E2,sc)
  eval({- E1 E2},sc)        = eval(E1,sc) - eval(E2,sc)
  eval({* E1 E2},sc)        = eval(E1,sc) * eval(E2,sc)
  eval({/ E1 E2},sc)        = eval(E1,sc) / eval(E2,sc)
  eval(x,sc)                = lookup(x,sc)
  eval({with {x E1} E2},sc) = eval(E2,extend(x,eval(E1,sc),sc))
  eval({fun {x} E},sc)      = <{fun {x} E},sc>
  eval({call E1 E2},sc1)
           = eval(Ef,extend(x,eval(E2,sc1),sc2))
                             if eval(E1,sc1)=<{fun {x} Ef},sc2>
           = error!          otherwise

(The algorithm for evaluating a `call' is:
  1. f := evaluate E1 in sc1
  2. if f is not a <{fun ...},...> closure then error!
  3. a := evaluate E2 in sc1
  4. new_sc := extend sc_of(f) by mapping arg_of(f) to a
  5. evaluate (and return) body_of(f) in new_sc
)

Note how the scoping rules that are implied by this definition match the
scoping rules that were implied by the substitution-based rules.  (It
should be possible to prove that they are the same.)

The changes to the code are almost trivial, except that we need a way to
represent <{fun {x} Ef},sc> pairs.

========================================================================

The implication of this change is that we now cannot use the same type
for function syntax and function values since function values have more
than just syntax.  There is a simple solution to this -- we never do any
substitutions now, so we don't need to translate values into expressions
-- we can come up with a new type for values, separate from the type of
abstract syntax trees.

When we do this, we will also fix our hack of using FLANG as the type of
values: this was merely a convenience since the AST type had cases for
all kinds of values that we needed.  (In fact, you should have noticed
that Scheme does this too: numbers, strings, booleans, etc are all used
by both programs, and in syntax representation (s-expressions) -- but
note that procedure values are *not* used in syntax.)

As a side note, these substitution caches are a little more than just a
cache now -- they actually hold an "environment" of substitutions in
which the expression should be evaluated.  So the usual name used for
them is an environment, we will use this name.

First, we need now an actual predicate for such environments -- we can
use `list-of' for this:

  ;; define a type called ENV to be:
  ;;   ENV := (list-of (list symbol VAL))
  (define ENV?
    (list-of (lambda (x)
               (and (list? x)
                    (= 2 (length x))
                    (symbol? (first x))
                    (VAL? (second x))))))

but since we will be using this in a type definition, it will be easier
if we define a new type for environments:

  (define-type ENV
    [EmptyEnv]
    [Extend (id symbol?) (v VAL?) (rest-env ENV?)])

Reimplementing `lookup' is now simple:

  ;; lookup : symbol ENV -> VAL
  (define (lookup name env)
    (cases env
      [(EmptyEnv) (error 'lookup "no binding for ~s" name)]
      [(Extend id val rest-env)
       (if (eq? id name) val (lookup name rest-env))]))

... we don't need `extend' because we get `Extend' from the type
definition, and we also get `(EmptyEnv)' instead of `empty-subst'.

We now use this with the new type for values -- two variants of these:

  (define-type VAL
    [NumV (n number?)]
    [FunV (name symbol?) (body FLANG?) (env ENV?)])

And now the new implementation of `eval' which uses the new type and
implements lexical scope:

  ;; eval : FLANG env -> VAL
  ;; evaluates FLANG expressions by reducing them to values
  (define (eval expr env)
    (cases expr
      [(Num n) (NumV n)]
      [(Add l r) (arith-op + (eval l env) (eval r env))]
      [(Sub l r) (arith-op - (eval l env) (eval r env))]
      [(Mul l r) (arith-op * (eval l env) (eval r env))]
      [(Div l r) (arith-op / (eval l env) (eval r env))]
      [(With bound-id named-expr bound-body)
       (eval bound-body
             (Extend bound-id (eval named-expr env) env))]
      [(Id name) (lookup name env)]
      [(Fun bound-id bound-body)
       (FunV bound-id bound-body env)]
      [(Call fun-expr arg-expr)
       (let ([fval (eval fun-expr env)])
         (cases fval
           [(FunV bound-id bound-body f-env)
            (eval bound-body
                  (Extend bound-id (eval arg-expr env) f-env))]
           [else (error 'eval "`call' expects a function, got: ~s"
                              fval)]))]))

We also need to update `arith-op' to use VAL objects.  The full code
follows -- it now passes all tests, including the example that we used
to find the problem.

  ----------------------------------------------------------------------
  #|
  The grammar:
    <FLANG> ::= <num>
              | { + <FLANG> <FLANG> }
              | { - <FLANG> <FLANG> }
              | { * <FLANG> <FLANG> }
              | { / <FLANG> <FLANG> }
              | { with { <id> <FLANG> } <FLANG> }
              | <id>
              | { fun { <id> } <FLANG> }
              | { call <FLANG> <FLANG> }

  Evaluation rules:
    eval(N,env)                = N
    eval({+ E1 E2},env)        = eval(E1,env) + eval(E2,env)
    eval({- E1 E2},env)        = eval(E1,env) - eval(E2,env)
    eval({* E1 E2},env)        = eval(E1,env) * eval(E2,env)
    eval({/ E1 E2},env)        = eval(E1,env) / eval(E2,env)
    eval(x,env)                = lookup(x,env)
    eval({with {x E1} E2},env) = eval(E2,extend(x,eval(E1,env),env))
    eval({fun {x} E},env)      = <{fun {x} E},env>
    eval({call E1 E2},env1)
             = eval(Ef,extend(x,eval(E2,env1),env2))
                               if eval(E1,env1)=<{fun {x} Ef},env2>
             = error!          otherwise
  |#

  (define-type FLANG
    [Num  (n number?)]
    [Add  (lhs FLANG?) (rhs FLANG?)]
    [Sub  (lhs FLANG?) (rhs FLANG?)]
    [Mul  (lhs FLANG?) (rhs FLANG?)]
    [Div  (lhs FLANG?) (rhs FLANG?)]
    [Id   (name symbol?)]
    [With (name symbol?) (named FLANG?) (body FLANG?)]
    [Fun  (name symbol?) (body FLANG?)]
    [Call (fun-expr FLANG?) (arg-expr FLANG?)])

  ;; parse-sexpr : s-expr -> FLANG
  ;; to convert s-expressions into FLANGs
  (define (parse-sexpr sexpr)
    (match sexpr
      [(number: n)    (Num n)]
      [(symbol: name) (Id name)]
      [(cons 'with more)
       (match sexpr
         [(list 'with (list (symbol: name) named) body)
          (With name (parse-sexpr named) (parse-sexpr body))]
         [else (error 'parse-sexpr "bad `with' syntax in ~s" sexpr)])]
      [(cons 'fun more)
       (match sexpr
         [(list 'fun (list (symbol: name)) body)
          (Fun name (parse-sexpr body))]
         [else (error 'parse-sexpr "bad `fun' syntax in ~s" sexpr)])]
      [(list op left right)
       (let ([make-node
              (match op
                ['+ Add]
                ['- Sub]
                ['* Mul]
                ['/ Div]
                ['call Call]
                [else (error 'parse-sexpr "don't know about ~s" op)])])
         (make-node (parse-sexpr left)
                    (parse-sexpr right)))]
      [else (error 'parse-sexpr "bad syntax in ~s" sexpr)]))

  ;; parse : string -> FLANG
  ;; parses a string containing an FLANG expression to a FLANG AST
  (define (parse str)
    (parse-sexpr (string->sexpr str)))

  ;; Types for environments, values, and a lookup function

  (define-type ENV
    [EmptyEnv]
    [Extend (id symbol?) (v VAL?) (rest-env ENV?)])

  (define-type VAL
    [NumV (n number?)]
    [FunV (name symbol?) (body FLANG?) (env ENV?)])

  ;; lookup : symbol ENV -> VAL
  (define (lookup name env)
    (cases env
      [(EmptyEnv) (error 'lookup "no binding for ~s" name)]
      [(Extend id val rest-env)
       (if (eq? id name) val (lookup name rest-env))]))

  ;; arith-op : (num num -> num) VAL VAL -> VAL
  ;; gets a Scheme numeric binary operator, and uses it within a NumV
  ;; wrapper
  (define (arith-op op val1 val2)
    (define (NumV->number v)
      (cases v
        [(NumV n) n]
        [else (error 'arith-op "expects a number, got: ~s" v)]))
    (NumV (op (NumV->number val1) (NumV->number val2))))

  ;; eval : FLANG env -> VAL
  ;; evaluates FLANG expressions by reducing them to values
  (define (eval expr env)
    (cases expr
      [(Num n) (NumV n)]
      [(Add l r) (arith-op + (eval l env) (eval r env))]
      [(Sub l r) (arith-op - (eval l env) (eval r env))]
      [(Mul l r) (arith-op * (eval l env) (eval r env))]
      [(Div l r) (arith-op / (eval l env) (eval r env))]
      [(With bound-id named-expr bound-body)
       (eval bound-body
             (Extend bound-id (eval named-expr env) env))]
      [(Id name) (lookup name env)]
      [(Fun bound-id bound-body)
       (FunV bound-id bound-body env)]
      [(Call fun-expr arg-expr)
       (let ([fval (eval fun-expr env)])
         (cases fval
           [(FunV bound-id bound-body f-env)
            (eval bound-body
                  (Extend bound-id (eval arg-expr env) f-env))]
           [else (error 'eval "`call' expects a function, got: ~s"
                              fval)]))]))

  ;; run : string -> number
  ;; evaluate a FLANG program contained in a string
  (define (run str)
    (let ([result (eval (parse str) (EmptyEnv))])
      (cases result
        [(NumV n) n]
        [else (error 'run
                     "evaluation returned a non-number: ~s" result)])))

  ;; tests

  (test (run "{call {fun {x} {+ x 1}} 4}")
        => 5)
  (test (run "{with {add3 {fun {x} {+ x 3}}}
                {call add3 1}}")
        => 4)
  (test (run "{with {add3 {fun {x} {+ x 3}}}
                {with {add1 {fun {x} {+ x 1}}}
                  {with {x 3}
                    {call add1 {call add3 x}}}}}")
        => 7)
  (test (run "{with {identity {fun {x} x}}
                {with {foo {fun {x} {+ x 1}}}
                  {call {call identity foo} 123}}}")
        => 124)
  (test (run "{with {x 3}
                {with {f {fun {y} {+ x y}}}
                  {with {x 5}
                    {call f 4}}}}")
        => 7)
  (test (run "{call {call {fun {x} {call x 1}}
                          {fun {x} {fun {y} {+ x y}}}}
                    123}")
        => 124)
  ----------------------------------------------------------------------

========================================================================
>>> Implementing Lexical Scope using Scheme Closures and Environments

An alternative representation for an environment

We've already seen how first-class functions can be used to implement
"objects" that contain some information.  We can use the same idea to
represent an environment.  The basic intuition is -- an environment is a
*mapping* (a function) between an identifier and some value.  For
example, we can represent the environment that maps 'a to 1 and 'b to 2
(using just Scheme numbers for simplicity) using this function:

  ;; my-map : symbol -> number
  (define (my-map id)
    (cond [(eq? 'a id) 1]
          [(eq? 'b id) 2]
          [else (error ...)]))

An empty mapping that is implemented in this way is:

  (define (empty-mapping id)
    (error ...))

We can use this idea to implement our environments: we only need to
define three things -- `EmptyEnv', `Extend', and `lookup'.  If we manage
to keep the contract to these functions intact, we will be able to
simply plug it into the same evaluator code with no other changes.  One
technicality is that we also need to define `ENV?' for the VAL type
definition.  Since we will be using Scheme procedures, we simply define
it as follows:

  (define (ENV? x) (procedure? x))

which is actually the same as

  ;; Define a type for functional environments
  (define ENV? procedure?)

Note that this is not an exact type -- not *all* Scheme procedures
behave like environments.

  ;; These should actually be something like:
  ;; ENV := symbol -> VAL

But there's not much we can do about this (since there is no way to
*know* how a certain procedure behaves, even if we use it) so we keep it
this way.

Now we get to `EmptyEnv' -- this is expected to be a procedure that
expects no arguments and creates an empty environment, one that behaves
like the `empty-mapping' procedure defined above.  We could define it
like this:

  (define (EmptyEnv) empty-mapping)

but we can skip the need for an extra definition and simply return an
empty mapping procedure:

  (define (EmptyEnv)
    (lambda (id) (error ...)))

(The un-Schemely name is to avoid replacing previous code that used the
`EmptyEnv' name for the constructor that was created by the type
definition.)

The next thing we tackle is `lookup'.  The previous definition that was
used is:

  ;; lookup : symbol ENV -> VAL
  (define (lookup name env)
    (cases env
      [(EmptyEnv) (error 'lookup "no binding for ~s" name)]
      [(Extend id val rest-env)
       (if (eq? id name) val (lookup name rest-env))]))

How should it be modified now?  Easy -- an environment is a mapping: a
Scheme procedure that will do the searching job itself.  We don't need
to modify the contract since we're still using `ENV', except a different
implementation for it.  The new definition is:

  ;; lookup : symbol ENV -> VAL
  (define (lookup name env)
    (env name))

Note that `lookup' does almost nothing -- it simply delegates the real
work to the `env' argument.  This is a good hint for the error message
that empty mappings should throw --

  (define (EmptyEnv)
    (lambda (id) (error 'lookup "no binding for ~s" id)))

Finally, `Extend' -- this was previously created by the variant case of
the ENV type definition:

  [Extend (id symbol?) (v VAL?) (rest-env ENV?)]

keeping the same contract that is implied by this variant means that the
new `Extend' should look like this:

  ;; Extend : symbol VAL ENV -> ENV
  (define (Extend id v rest-env)
    ...)

The question is -- how do we extend a given environment?  Well, first,
we know that the result should be mapping -- a `symbol -> VAL' function
that expects an identifier to look for:

  ;; Extend : symbol VAL ENV -> ENV
  (define (Extend id v rest-env)
    (lambda (name)
      ...))

Next, we know that in the generated mapping, if we look for `id' then
the result should be `v':

  ;; Extend : symbol VAL ENV -> ENV
  (define (Extend id v rest-env)
    (lambda (name)
      (if (eq? name id)
        v
        ...)))

If the `name' that we're looking for is not the same as `id', then we
need to search through the previous environment, eg: (lookup name rest).
But we know what `lookup' does -- it simply delegates back to the
mapping function (which is our `rest' argument), so we can take a direct
route:

  ;; Extend : symbol VAL ENV -> ENV
  (define (Extend id v rest-env)
    (lambda (name)
      (if (eq? name id)
        v
        (rest-env name))))

(Note that the last line is simply `(lookup name rest-env)', but we know
that we have a functional implementation.)

To see how all this works, try out extending a empty environment a few
times and examine the result.  For example, the environment that we
began with:

  (define (my-map id)
    (cond [(eq? 'a id) 1]
          [(eq? 'b id) 2]
          [else (error ...)]))

behaves in the same way as

  (Extend 'a 1 (Extend 'b 2 (EmptyEnv)))

The new code is now the same, except for the environment code:

  ----------------------------------------------------------------------
  #|
  The grammar:
    <FLANG> ::= <num>
              | { + <FLANG> <FLANG> }
              | { - <FLANG> <FLANG> }
              | { * <FLANG> <FLANG> }
              | { / <FLANG> <FLANG> }
              | { with { <id> <FLANG> } <FLANG> }
              | <id>
              | { fun { <id> } <FLANG> }
              | { call <FLANG> <FLANG> }

  Evaluation rules:
    eval(N,env)                = N
    eval({+ E1 E2},env)        = eval(E1,env) + eval(E2,env)
    eval({- E1 E2},env)        = eval(E1,env) - eval(E2,env)
    eval({* E1 E2},env)        = eval(E1,env) * eval(E2,env)
    eval({/ E1 E2},env)        = eval(E1,env) / eval(E2,env)
    eval(x,env)                = lookup(x,env)
    eval({with {x E1} E2},env) = eval(E2,extend(x,eval(E1,env),env))
    eval({fun {x} E},env)      = <{fun {x} E},env>
    eval({call E1 E2},env1)
             = eval(Ef,extend(x,eval(E2,env1),env2))
                               if eval(E1,env1)=<{fun {x} Ef},env2>
             = error!          otherwise
  |#

  (define-type FLANG
    [Num  (n number?)]
    [Add  (lhs FLANG?) (rhs FLANG?)]
    [Sub  (lhs FLANG?) (rhs FLANG?)]
    [Mul  (lhs FLANG?) (rhs FLANG?)]
    [Div  (lhs FLANG?) (rhs FLANG?)]
    [Id   (name symbol?)]
    [With (name symbol?) (named FLANG?) (body FLANG?)]
    [Fun  (name symbol?) (body FLANG?)]
    [Call (fun-expr FLANG?) (arg-expr FLANG?)])

  ;; parse-sexpr : s-expr -> FLANG
  ;; to convert s-expressions into FLANGs
  (define (parse-sexpr sexpr)
    (match sexpr
      [(number: n)    (Num n)]
      [(symbol: name) (Id name)]
      [(cons 'with more)
       (match sexpr
         [(list 'with (list (symbol: name) named) body)
          (With name (parse-sexpr named) (parse-sexpr body))]
         [else (error 'parse-sexpr "bad `with' syntax in ~s" sexpr)])]
      [(cons 'fun more)
       (match sexpr
         [(list 'fun (list (symbol: name)) body)
          (Fun name (parse-sexpr body))]
         [else (error 'parse-sexpr "bad `fun' syntax in ~s" sexpr)])]
      [(list op left right)
       (let ([make-node
              (match op
                ['+ Add]
                ['- Sub]
                ['* Mul]
                ['/ Div]
                ['call Call]
                [else (error 'parse-sexpr "don't know about ~s" op)])])
         (make-node (parse-sexpr left)
                    (parse-sexpr right)))]
      [else (error 'parse-sexpr "bad syntax in ~s" sexpr)]))

  ;; parse : string -> FLANG
  ;; parses a string containing an FLANG expression to a FLANG AST
  (define (parse str)
    (parse-sexpr (string->sexpr str)))

  ;; Types for environments, values, and a lookup function

  (define-type VAL
    [NumV (n number?)]
    [FunV (name symbol?) (body FLANG?) (env ENV?)])

  ;; Define a type for functional environments
  (define ENV? procedure?)
  ;; These should actually be something like:
  ;; ENV := symbol -> VAL

  ;; EmptyEnv : -> ENV
  (define (EmptyEnv)
    (lambda (id) (error 'lookup "no binding for ~s" id)))

  ;; lookup : symbol ENV -> VAL
  (define (lookup name env)
    (env name))

  ;; Extend : symbol VAL ENV -> ENV
  (define (Extend id v rest-env)
    (lambda (name)
      (if (eq? name id)
        v
        (rest-env name))))

  ;; arith-op : (num num -> num) VAL VAL -> VAL
  ;; gets a Scheme numeric binary operator, and uses it within a NumV
  ;; wrapper
  (define (arith-op op val1 val2)
    (define (NumV->number v)
      (cases v
        [(NumV n) n]
        [else (error 'arith-op "expects a number, got: ~s" v)]))
    (NumV (op (NumV->number val1) (NumV->number val2))))

  ;; eval : FLANG env -> VAL
  ;; evaluates FLANG expressions by reducing them to values
  (define (eval expr env)
    (cases expr
      [(Num n) (NumV n)]
      [(Add l r) (arith-op + (eval l env) (eval r env))]
      [(Sub l r) (arith-op - (eval l env) (eval r env))]
      [(Mul l r) (arith-op * (eval l env) (eval r env))]
      [(Div l r) (arith-op / (eval l env) (eval r env))]
      [(With bound-id named-expr bound-body)
       (eval bound-body
             (Extend bound-id (eval named-expr env) env))]
      [(Id name) (lookup name env)]
      [(Fun bound-id bound-body)
       (FunV bound-id bound-body env)]
      [(Call fun-expr arg-expr)
       (let ([fval (eval fun-expr env)])
         (cases fval
           [(FunV bound-id bound-body f-env)
            (eval bound-body
                  (Extend bound-id (eval arg-expr env) f-env))]
           [else (error 'eval "`call' expects a function, got: ~s"
                              fval)]))]))

  ;; run : string -> number
  ;; evaluate a FLANG program contained in a string
  (define (run str)
    (let ([result (eval (parse str) (EmptyEnv))])
      (cases result
        [(NumV n) n]
        [else (error 'run
                     "evaluation returned a non-number: ~s" result)])))

  ;; tests

  (test (run "{call {fun {x} {+ x 1}} 4}")
        => 5)
  (test (run "{with {add3 {fun {x} {+ x 3}}}
                {call add3 1}}")
        => 4)
  (test (run "{with {add3 {fun {x} {+ x 3}}}
                {with {add1 {fun {x} {+ x 1}}}
                  {with {x 3}
                    {call add1 {call add3 x}}}}}")
        => 7)
  (test (run "{with {identity {fun {x} x}}
                {with {foo {fun {x} {+ x 1}}}
                  {call {call identity foo} 123}}}")
        => 124)
  (test (run "{with {x 3}
                {with {f {fun {y} {+ x y}}}
                  {with {x 5}
                    {call f 4}}}}")
        => 7)
  (test (run "{call {call {fun {x} {call x 1}}
                          {fun {x} {fun {y} {+ x y}}}}
                    123}")
        => 124)
  ----------------------------------------------------------------------

========================================================================
>>> More Closures (on both levels)

Scheme closures (=functions) can be used in other places too, and as we
have seen, they can do more than encapsulate various values -- they can
also hold the behavior that is expected of these values.

To demonstrate this we will deal with closures in our language.  We
currently use a variant that holds the three pieces of relevant
information:

    [FunV (name symbol?) (body FLANG?) (env ENV?)]

We can replace this by a functional object, which will hold the three
values.  First, change the VAL type to hold these objects:

  (define-type VAL
    [NumV (n number?)]
    [FunV (p procedure?)])

And note that the procedure should somehow hold the information that
encapsulates previous contents, but we cannot enforce that completely in
the same way that we could not force a specific procedure type for the
functional environment representation.  This information plays a role in
two places in our evaluator -- generating a closure in the `Fun' case,
and using it in the `Call' case:

      [(Fun bound-id bound-body)
       (FunV bound-id bound-body env)]
      [(Call fun-expr arg-expr)
       (let ([fval (eval fun-expr env)])
         (cases fval
           [(FunV bound-id bound-body f-env)
            (eval bound-body                   ;*
                  (Extend bound-id             ;*
                          (eval arg-expr env)  ;*
                          f-env))]             ;*
           [else (error 'eval "`call' expects a function, got: ~s"
                              fval)]))]

we can simply fold the marked functionality bit of `Call' into a Scheme
function that will be stored in a `FunV' object -- this piece of
functionality takes an argument value, extends the closure's environment
with its value and the function's name, and continues to evaluate the
function body.  Folding all of this into a function gives us:

  (lambda (arg-val)
    (eval bound-body (Extend bound-id arg-val env)))

where the values of `bound-body', `bound-id', and `val' are known at the
time that the FunV is *constructed*.  Doing this gives us the following
code for the two cases:

      [(Fun bound-id bound-body)
       (FunV (lambda (arg-val)
               (eval bound-body (Extend bound-id arg-val env))))]
      [(Call fun-expr arg-expr)
       (let ([fval (eval fun-expr env)])
         (cases fval
           [(FunV proc) (proc (eval arg-expr env))]
           [else (error 'eval "`call' expects a function, got: ~s"
                              fval)]))]

And again, the rest of the code is unmodified:

  ----------------------------------------------------------------------
  (define-type FLANG
    [Num  (n number?)]
    [Add  (lhs FLANG?) (rhs FLANG?)]
    [Sub  (lhs FLANG?) (rhs FLANG?)]
    [Mul  (lhs FLANG?) (rhs FLANG?)]
    [Div  (lhs FLANG?) (rhs FLANG?)]
    [Id   (name symbol?)]
    [With (name symbol?) (named FLANG?) (body FLANG?)]
    [Fun  (name symbol?) (body FLANG?)]
    [Call (fun-expr FLANG?) (arg-expr FLANG?)])

  ;; parse-sexpr : s-expr -> FLANG
  ;; to convert s-expressions into FLANGs
  (define (parse-sexpr sexpr)
    (match sexpr
      [(number: n)    (Num n)]
      [(symbol: name) (Id name)]
      [(cons 'with more)
       (match sexpr
         [(list 'with (list (symbol: name) named) body)
          (With name (parse-sexpr named) (parse-sexpr body))]
         [else (error 'parse-sexpr "bad `with' syntax in ~s" sexpr)])]
      [(cons 'fun more)
       (match sexpr
         [(list 'fun (list (symbol: name)) body)
          (Fun name (parse-sexpr body))]
         [else (error 'parse-sexpr "bad `fun' syntax in ~s" sexpr)])]
      [(list op left right)
       (let ([make-node
              (match op
                ['+ Add]
                ['- Sub]
                ['* Mul]
                ['/ Div]
                ['call Call]
                [else (error 'parse-sexpr "don't know about ~s" op)])])
         (make-node (parse-sexpr left)
                    (parse-sexpr right)))]
      [else (error 'parse-sexpr "bad syntax in ~s" sexpr)]))

  ;; parse : string -> FLANG
  ;; parses a string containing an FLANG expression to a FLANG AST
  (define (parse str)
    (parse-sexpr (string->sexpr str)))

  ;; Types for environments, values, and a lookup function

  (define-type VAL
    [NumV (n number?)]
    [FunV (p procedure?)])

  ;; Define a type for functional environments
  (define ENV? procedure?)
  ;; These should actually be something like:
  ;; ENV := symbol -> VAL

  ;; EmptyEnv : -> ENV
  (define (EmptyEnv)
    (lambda (id) (error 'lookup "no binding for ~s" id)))

  ;; lookup : symbol ENV -> VAL
  (define (lookup name env)
    (env name))

  ;; Extend : symbol VAL ENV -> ENV
  (define (Extend id v rest-env)
    (lambda (name)
      (if (eq? name id)
        v
        (rest-env name))))

  ;; arith-op : (num num -> num) VAL VAL -> VAL
  ;; gets a Scheme numeric binary operator, and uses it within a NumV
  ;; wrapper
  (define (arith-op op val1 val2)
    (define (NumV->number v)
      (cases v
        [(NumV n) n]
        [else (error 'arith-op "expects a number, got: ~s" v)]))
    (NumV (op (NumV->number val1) (NumV->number val2))))

  ;; eval : FLANG env -> VAL
  ;; evaluates FLANG expressions by reducing them to values
  (define (eval expr env)
    (cases expr
      [(Num n) (NumV n)]
      [(Add l r) (arith-op + (eval l env) (eval r env))]
      [(Sub l r) (arith-op - (eval l env) (eval r env))]
      [(Mul l r) (arith-op * (eval l env) (eval r env))]
      [(Div l r) (arith-op / (eval l env) (eval r env))]
      [(With bound-id named-expr bound-body)
       (eval bound-body
             (Extend bound-id (eval named-expr env) env))]
      [(Id name) (lookup name env)]
      [(Fun bound-id bound-body)
       (FunV (lambda (arg-val)
               (eval bound-body (Extend bound-id arg-val env))))]
      [(Call fun-expr arg-expr)
       (let ([fval (eval fun-expr env)])
         (cases fval
           [(FunV proc) (proc (eval arg-expr env))]
           [else (error 'eval "`call' expects a function, got: ~s"
                              fval)]))]))

  ;; run : string -> number
  ;; evaluate a FLANG program contained in a string
  (define (run str)
    (let ([result (eval (parse str) (EmptyEnv))])
      (cases result
        [(NumV n) n]
        [else (error 'run
                     "evaluation returned a non-number: ~s" result)])))

  ;; tests

  (test (run "{call {fun {x} {+ x 1}} 4}")
        => 5)
  (test (run "{with {add3 {fun {x} {+ x 3}}}
                {call add3 1}}")
        => 4)
  (test (run "{with {add3 {fun {x} {+ x 3}}}
                {with {add1 {fun {x} {+ x 1}}}
                  {with {x 3}
                    {call add1 {call add3 x}}}}}")
        => 7)
  (test (run "{with {identity {fun {x} x}}
                {with {foo {fun {x} {+ x 1}}}
                  {call {call identity foo} 123}}}")
        => 124)
  (test (run "{with {x 3}
                {with {f {fun {y} {+ x y}}}
                  {with {x 5}
                    {call f 4}}}}")
        => 7)
  (test (run "{call {call {fun {x} {call x 1}}
                          {fun {x} {fun {y} {+ x y}}}}
                    123}")
        => 124)
  ----------------------------------------------------------------------

========================================================================
>>> Types of Evaluators

What we did just now is implement lexical environments and closures in
the language we implement using lexical environments and closures in our
own language (Scheme)!

This is another example of embedding a feature of the host language in
the implemented language, an issue that we have already discussed.

There are many examples of this, even when the two languages involved
are different.  For example, if we have this bit in a C implementation
of Scheme:

  Scheme_Object *eval_and( int argc, Scheme_Object *argv[] )
  {
    Scheme_Object *tmp;
    if ( argc != 2 )
      signal_scheme_error("bad number of arguments");
    else if ( scheme_eval(argv[0]) != scheme_false &&
              (tmp = scheme_eval(argv[1])) != scheme_false )
      return tmp;
    else
      return scheme_false;
  }

then the special semantics of evaluating a Scheme `and' form is being
inherited from C's special treatment of `&&'.  You can see this by the
fact that if there is a bug in the C compiler, then it will propagate to
the resulting Scheme implementation too.

We have seen a few different implementations of evaluators that are
quite different in flavor.  They suggest the following taxonomy.

* A <<syntactic evaluator>> is one that uses its own language to
  represent only expressions of the evaluated language, implementing all
  the corresponding behavior explicitly.

* A <<meta evaluator>> is an evaluator that uses language features of
  its own language to directly implement behavior of the evaluated
  language.

While our substitution-based FLANG evaluator was close to being a
syntactic evaluator, we haven't written any purely syntactic evaluators
so far: we still relied on things like Scheme arithmetics etc.  The most
recent evaluator that we have studied, is distinctly a meta evaluator.

With a good match between the evaluated language and the implementation
language, writing a meta evaluator can be very easy.  With a bad match,
though, it can be very hard.  With a syntactic evaluator, implementing
each semantic feature will be somewhat hard, but in return you don't
have to worry as much about how well the implementation and the
evaluated languages match up.  In particular, if there is a particularly
strong mismatch between the implementation and the evaluated language,
it may take less effort to write a syntactic evaluator than a meta
evaluator.  As an exercise, we can build upon our latest evaluator to
remove the encapsulation of the evaluator's response in the VAL type.
The resulting evaluator is shown below.  This is a true meta evaluator:
it uses Scheme closures to implement FLANG closures, Scheme procedure
application for FLANG function application, Scheme numbers for FLANG
numbers, and Scheme arithmetic for FLANG arithmetic.  In fact, ignoring
some small syntactic differences between Scheme and FLANG, this latest
evaluator can be classified as something more specific than a meta
evaluator:

* A <<meta-circular evaluator>> is a meta evaluator in which the
  implementation and the evaluated languages are the same.

(Put differently, the trivial nature of the evaluator clues us in to the
deep connection between the two languages, whatever their syntactic
differences may be.)

========================================================================
>>> Feature Embedding

We saw that the difference between lazy evaluation and eager evaluation
is in the evaluation rules for `with' forms, function applications, etc:

  eval({with {x E1} E2}) = eval(E2[eval(E1)/x])

is eager, and

  eval({with {x E1} E2}) = eval(E2[E1/x])

is lazy.  But is the first rule *really* eager?  The fact is that the
only thing that makes it eager is the fact that our understanding of the
mathematical notation is eager -- if we were to take math as lazy, then
the description of the rule becomes a description of lazy evaluation.

Another way to look at this is -- take the piece of code that implements
this evaluation:

  ;; eval : FLANG -> number
  ;; evaluates FLANG expressions by reducing them to numbers
  (define (eval expr)
    (cases expr
      ...
      [(With bound-id named-expr bound-body)
       (eval (subst bound-body
                    bound-id
                    (Num (eval named-expr))))]
      ...))

and the same question applies: is this really implementing eager
evaluation?  We know that this is indeed eager -- we can simply try it
and check that it is, but it is only eager because we are using an eager
language for the implementation!  If Scheme itself was a lazy language,
then our own code would evaluate in a lazy way, so the above
applications of the the `eval' and the `subst' functions would also be
lazy, making our evaluator lazy as well.

This is a general phenomena where some of the semantic features of the
language we use (math in the formal description, Scheme in our code)
gets *embedded* into the language we implement.

Here's another example -- consider the code that implements arithmetics:

  ;; eval : FLANG -> number
  ;; evaluates FLANG expressions by reducing them to numbers
  (define (eval expr)
    (cases expr
      [(Num n) n]
      [(Add l r) (+ (eval l) (eval r))]
      ...))

what if it was written like this:

  FLANG eval(FLANG expr) {
    if (is_Num(expr))
      return num_of_Num(expr);
    else if (is_Add(expr))
      return eval(lhs_of_Add(expr)) + eval(rhs_of_Add(expr));
    else if ...
    ...
  }

Would it still implement unlimited integers and exact fractions?  That
depends on the language that was used to implement it: the above syntax
suggests C, C++, Java, or some other relative, which usually come with
limited integers and no exact fractions.  But this really depends on the
language -- even our own code has unlimited integers and exact rationals
only because our Scheme implementation has them.  If we were using a
Scheme that didn't have such features (such implementations do exist),
then our implemented language would absorb these (lack of) features too,
and its own numbers would be limited in just the same way.  (And this
includes the syntax for numbers, which we embedded intentionally, like
the syntax for identifiers).

The bottom line is that we should be aware of such issues, and be very
careful when we talk about semantics.  Even the language that we use to
communicate (semi-formal logic) can mean different things.

========================================================================

Aside: read "Reflections on Trusting Trust" by Ken Thompson

  http://www.acm.org/classics/sep95/

(You can skip to the "Stage II" part to get to the interesting stuff.)

========================================================================
Here is yet another variation of our evaluator that is even closer to a
meta-circular evaluator.  It uses Scheme values directly to implement
values, so arithmetic operations become straightforward.  Note
especially how the case for function application is similar to
arithmetics: a FLANG function application translates to a Scheme
function application.  In both cases (applications and arithmetics) we
don't even check the objects since they are simple Scheme objects -- if
our Scheme implementation happens to have some meaning for arithmetics
with functions, or for applying numbers, then we will inherit the same
semantics in our language.  This means that we now specify less behavior
and simply fall back on what Scheme does.

  ----------------------------------------------------------------------
  (define-type FLANG
    [Num  (n number?)]
    [Add  (lhs FLANG?) (rhs FLANG?)]
    [Sub  (lhs FLANG?) (rhs FLANG?)]
    [Mul  (lhs FLANG?) (rhs FLANG?)]
    [Div  (lhs FLANG?) (rhs FLANG?)]
    [Id   (name symbol?)]
    [With (name symbol?) (named FLANG?) (body FLANG?)]
    [Fun  (name symbol?) (body FLANG?)]
    [Call (fun-expr FLANG?) (arg-expr FLANG?)])

  ;; parse-sexpr : s-expr -> FLANG
  ;; to convert s-expressions into FLANGs
  (define (parse-sexpr sexpr)
    (match sexpr
      [(number: n)    (Num n)]
      [(symbol: name) (Id name)]
      [(cons 'with more)
       (match sexpr
         [(list 'with (list (symbol: name) named) body)
          (With name (parse-sexpr named) (parse-sexpr body))]
         [else (error 'parse-sexpr "bad `with' syntax in ~s" sexpr)])]
      [(cons 'fun more)
       (match sexpr
         [(list 'fun (list (symbol: name)) body)
          (Fun name (parse-sexpr body))]
         [else (error 'parse-sexpr "bad `fun' syntax in ~s" sexpr)])]
      [(list op left right)
       (let ([make-node
              (match op
                ['+ Add]
                ['- Sub]
                ['* Mul]
                ['/ Div]
                ['call Call]
                [else (error 'parse-sexpr "don't know about ~s" op)])])
         (make-node (parse-sexpr left)
                    (parse-sexpr right)))]
      [else (error 'parse-sexpr "bad syntax in ~s" sexpr)]))

  ;; parse : string -> FLANG
  ;; parses a string containing an FLANG expression to a FLANG AST
  (define (parse str)
    (parse-sexpr (string->sexpr str)))

  ;; Environments and a lookup function

  ;; Define a type for functional environments
  (define ENV? procedure?)
  ;; These should actually be something like:
  ;; ENV := symbol -> (union-of number procedure)

  ;; EmptyEnv : -> ENV
  (define (EmptyEnv)
    (lambda (id) (error 'lookup "no binding for ~s" id)))

  ;; lookup : symbol ENV -> (union-of number procedure)
  (define (lookup name env)
    (env name))

  ;; Extend : symbol (union-of number procedure) ENV -> ENV
  (define (Extend id v rest-env)
    (lambda (name)
      (if (eq? name id)
        v
        (rest-env name))))

  ;; eval : FLANG env -> (union-of number procedure) ;* Scheme values!
  ;; evaluates FLANG expressions by reducing them to values
  (define (eval expr env)
    (cases expr
      [(Num n) n]
      [(Add l r) (+ (eval l env) (eval r env))]
      [(Sub l r) (- (eval l env) (eval r env))]
      [(Mul l r) (* (eval l env) (eval r env))]
      [(Div l r) (/ (eval l env) (eval r env))]
      [(With bound-id named-expr bound-body)
       (eval bound-body
             (Extend bound-id (eval named-expr env) env))]
      [(Id name) (lookup name env)]
      [(Fun bound-id bound-body)
       (lambda (arg-val)
         (eval bound-body (Extend bound-id arg-val env)))]
      [(Call fun-expr arg-expr)
       ((eval fun-expr env)      ;* trivial like the arithmetic cases! *
        (eval arg-expr env))]))

  ;; run : string -> (union-of number procedure)
  ;; evaluate a FLANG program contained in a string
  (define (run str)
    (eval (parse str) (EmptyEnv)))

  ;; tests

  (test (run "{call {fun {x} {+ x 1}} 4}")
        => 5)
  (test (run "{with {add3 {fun {x} {+ x 3}}}
                {call add3 1}}")
        => 4)
  (test (run "{with {add3 {fun {x} {+ x 3}}}
                {with {add1 {fun {x} {+ x 1}}}
                  {with {x 3}
                    {call add1 {call add3 x}}}}}")
        => 7)
  (test (run "{with {identity {fun {x} x}}
                {with {foo {fun {x} {+ x 1}}}
                  {call {call identity foo} 123}}}")
        => 124)
  (test (run "{with {x 3}
                {with {f {fun {y} {+ x y}}}
                  {with {x 5}
                    {call f 4}}}}")
        => 7)
  (test (run "{call {call {fun {x} {call x 1}}
                          {fun {x} {fun {y} {+ x y}}}}
                    123}")
        => 124)
  ----------------------------------------------------------------------

========================================================================
>>> The Nature of Recursion

There is one major feature that is still missing from our language: we
have no way to perform recursion (therefore no kind of loops).  So far,
we could only use recursion when we had *names*.  In FLANG, the only way
we can have names is through `with' which not good enough for recursion.

To discuss the issue of recursion, we switch to a "broken" version of
Scheme -- one where a `define' has a different scoping rules: the scope
of the defined name does *not* cover the defined expression.
Specifically, in this version, this doesn't work:

  (define (fact n)
    (if (zero? n)
      1
      (* n (fact (- n 1)))))
  (fact 120)

The `define' form is more similar to a mathematical definition now.  For
example, when we write:

  (define (F x) x)
  (define (G y) (F y))
  (G F)

which is actually shorthand for

  (define F (lambda (x) x))
  (define G (lambda (y) (F y)))
  (G F)

we really mean that this is again shorthand notation for the real thing
you want to write which is:

  ((lambda (y) ((lambda (x) x) y)) (lambda (x) x))

This means that the above `fact' definition is similar to writing:

  fact := (lambda (n)
            (if (zero? n) 1 (* n (fact (- n 1)))))
  (fact 120)

which is not a well-formed definition -- it is *meaningless* (this is a
formal use of the word "meaningless").  What we'd really want, is to
take the *equation* (using `=' instead of `:=')

  fact = (lambda (n)
           (if (zero? n) 1 (* n (fact (- n 1)))))

and find a solution which will be a value for `fact' that makes this
true.

If you look at the Scheme evaluation rules handout on the web page, you
will see that this problem is related to the way that we introduced the
Scheme `define': there is a hand-wavy explanation that talks about
*knowing* things.

The big question is: can we define recursive functions without Scheme's
magical `define' form?

========================================================================
>>> Recursion: Implementing It

Lets start now with with an example: a simple recursive function
definition:

  (define (fact n)
    (if (zero? n)
      1
      (* n (fact (- n 1)))))

or

  (define fact
    (lambda (n)
      (if (zero? n)
        1
        (* n (fact (- n 1))))))

When we look at the *value* of `fact', we see that by itself, it doesn't
make any sense because `fact' is a free variable if you look at the body
in isolation:

  (lambda (n)
    (if (zero? n)
      1
      (* n (fact (- n 1)))))

We will now make our way to a recursive function, beginning with the
broken definition:

  (define fact
    (lambda (n)
      (if (zero? n)
        1
        (* n (fact (- n 1))))))

and try to fix it in steps.

First of all, the above does not have a recursive call -- we don't have
a value for `fact', so we can just as well write anything we want
instead of `fact' to make it a valid definition:

  (define fact
    (lambda (n)
      (if (zero? n)
        1
        (* n (666 (- n 1)))))) ;***

This function will not work in the general case, but there is one case
where it *will* work: when the input value is 0 (since then we do not
reach that bogus application).  Note this by naming this function
`fact0':

  (define fact0 ;***
    (lambda (n)
      (if (zero? n)
        1
        (* n (666 (- n 1))))))

Now that we have that, we can use it to write `fact1' which is the
same as the real factorial function for arguments of 0 or 1:

  (define fact0
    (lambda (n)
      (if (zero? n)
        1
        (* n (666 (- n 1))))))
  (define fact1
    (lambda (n)
      (if (zero? n)
        1
        (* n (fact0 (- n 1))))))

But remember that this is actually just shorthand for:

  (define fact1
    (lambda (n)
      (if (zero? n)
        1
        (* n ((lambda (n)
                (if (zero? n)
                  1
                  (* n (666 (- n 1)))))
              (- n 1))))))

We can continue in this way and write `fact2' that will work for n<=2:

  (define fact2
    (lambda (n)
      (if (zero? n)
        1
        (* n (fact1 (- n 1))))))

or, in full form:

  (define fact2
    (lambda (n)
      (if (zero? n)
        1
        (* n ((lambda (n)
                (if (zero? n)
                  1
                  (* n ((lambda (n)
                          (if (zero? n)
                            1
                            (* n (666 (- n 1)))))
                        (- n 1)))))
              (- n 1))))))

If we continue this way, we *will* get the true factorial function,

but the problem is that to handle *any* possible integer argument, it
will have to be an infinite definition!  Here is what it is supposed to
look like:

  (define fact0 (lambda (n) (if (zero? n) 1 (* n (666 (- n 1))))))
  (define fact1 (lambda (n) (if (zero? n) 1 (* n (fact0 (- n 1))))))
  (define fact2 (lambda (n) (if (zero? n) 1 (* n (fact1 (- n 1))))))
  (define fact3 (lambda (n) (if (zero? n) 1 (* n (fact2 (- n 1))))))
  ...

And our `fact' is actually `fact-infinity', with an infinite size.  So,
we're back at the original problem...

There is hope though -- the bigger and bigger definitions all use
instances of the same original `fact' code, so we can try to abstract it
away -- pull the value that is being used as the internal call as an
argument to a function.

  Rule#1:
    (... y ...)
    <==> (let ([x y]) (... x ...))
    <==> ((lambda (x) (... x ...)) y)

Using this, `fact1' becomes:

  (define fact1
    (let ([fact fact0])
      (lambda (n)
        (if (zero? n)
          1
          (* n (fact (- n 1)))))))

which is

  (define fact1
    ((lambda (fact)
       (lambda (n)
         (if (zero? n)
           1
           (* n (fact (- n 1))))))
     fact0))

which, in turn, is actually:

  (define fact1
    ((lambda (fact)
       (lambda (n)
         (if (zero? n)
           1
           (* n (fact (- n 1))))))
     ((lambda (fact)
        (lambda (n)
          (if (zero? n)
            1
            (* n (fact (- n 1))))))
      666)))

This way we get something that looks better, but we still repeat
ourselves.

To solve this problem, we'll use a function that will take the
`(lambda (n) ...)' expression and will apply that on `666', `fact0', or
whatever.

  Rule#2:
    (f x) <==> ((lambda (g) (g x)) f)
  (This is actually an instance of Rule#1.)

Use this to create a function that gets `make-fact':

  (define fact0
    ((lambda (make-fact)
       (make-fact 666)) ;***
     (lambda (fact)
       (lambda (n)
         (if (zero? n)
           1
           (* n (fact (- n 1))))))))

Now `fact1' can be written easily:

  (define fact1
    ((lambda (make-fact)
       (make-fact (make-fact 666)))
     (lambda (fact)
       (lambda (n)
         (if (zero? n)
           1
           (* n (fact (- n 1))))))))

And the principle is clear.

We can now continue by working on the real factorial, which is still
infinite at this stage:

  (define fact
    ((lambda (make-fact)
       (make-fact
        (make-fact
         (... (make-fact 666) ...))))
     (lambda (fact)
       (lambda (n)
         (if (zero? n)
           1
           (* n (fact (- n 1))))))))

But the infiniteness problem is now localized: we look for a *finite*
expression that will evaluate to

  (f (f (f (... (f x) ...))))

Now, examine the `(lambda (make-fact) ...)' -- all it does is get
something and apply it to the result of applying it to the result of
applying it ... to 666.

So, if we succeed, `make-fact' does what we want:

  (make-fact f) --> (f (f (f (... (f x) ...))))

We can now use this idea: pass `make-fact' itself to `make-fact', and
have it do the extra calls itself when needed.

Now the second closure gets `make-fact' itself, so the internal `fact'
variable is renamed to make this clearer, and we initially apply it on
666:

  (define fact
    ((lambda (make-fact)
       (make-fact make-fact))    ;***
     (lambda (make-fact)         ;***
       (lambda (n)
         (if (zero? n)
           1
           (* n ((make-fact 666) ;***
                 (- n 1))))))))

That will make this function do the same as `fact1' -- if we try to
continue, we'll bump into 666, a reduction will demonstrate this (try
it).

Instead -- use `make-fact' instead of 666 and we'll be able to do as
many calls as needed:

  (define fact
    ((lambda (make-fact)
       (make-fact make-fact))
     (lambda (make-fact)
       (lambda (n)
         (if (zero? n)
           1
           (* n ((make-fact make-fact) ;***
                 (- n 1))))))))

Now, we have something which *is* the true factorial function (convince
yourself by fixing the reductions made with 666).  It is therefore
possible to write recursive functions using finite expressions!  -- But
we still have some problems to overcome...

First, there is still the problem of having a solution which is quite
different from the original factorial function.

To make things more clear, we use more abstractions.

First, abstract the second lambda expression, putting the
`(make-fact make-fact)' call outside the expression (Rule#1) so we get
the `fact's original body in one piece:

  (define fact
    ((lambda (make-fact)
       (make-fact make-fact))
     (lambda (make-fact)
       ((lambda (fact)                ;***
          (lambda (n)
            (if (zero? n)
              1
              (* n (fact (- n 1)))))) ;***
        (make-fact make-fact)))))     ;***

This was easy to solve, but there is a more important problem -- it will
get stuck in an infinite loop...

========================================================================
>>> Recursion: Infinity (and beyond?)

This is because we use an eager language -- you evaluate the function
and its arguments first, and then do the actual application step.  But
when you try to evaluate the argument, you end up evaluating an infinite
loop.

What we just did is write an expression that looks like:

  ((lambda (x) (x x))
   (lambda (x) (f (x x))))

which is a variation on the well-known and much loved expression:

  ((lambda (x) (x x)) (lambda (x) (x x)))

...which evaluates to itself ... forever...

This expression is the key for creating a loop -- we use it to create
the recursion.  The original expression evaluates as follows:

  ((lambda (x) (x x)) (lambda (x) (f (x x))))
  ((lambda (x) (f (x x))) (lambda (x) (f (x x))))
  (f ((lambda (x) (f (x x))) (lambda (x) (f (x x)))))
  (f (f ((lambda (x) (f (x x))) (lambda (x) (f (x x))))))
  (f (f (f ((lambda (x) (f (x x))) (lambda (x) (f (x x)))))))
  ...

The problem is that we must *delay* the evaluation of the looping
expression until we actually need more `f's to avoid an infinite loop.

The solution for this is to use `lambda' to delay evaluation.  Use this
rule:

  Rule#3:
    f <==> (lambda (z) (f z))
  -- as long as f is a one-arg function.

So we will use this wrapper on the `(x x)' (which does evaluate to a
one-argument function):

  ((lambda (x) (x x))
   (lambda (x) (f (lambda (z) ((x x) z)))))

and when we evaluate this we get to something similar to this:

  (f (lambda (z)
       (((lambda (x) (f (x x)))
         (lambda (x) (f (x x))))
        z)))

Except that we have `(lambda (z) ((x x) z))' instead of the original
`(x x)' so this is really:

  (f (lambda (z)
       (((lambda (x)
           (f (lambda (z) ((x x) z))))
         (lambda (x)
           (f (lambda (z) ((x x) z)))))
        z)))

... Now the loop is deferred inside the lambda expression -- and only
when we need to use it, we apply it and evaluate its body.  The result
will still be the same.

Note that this wouldn't be a problem if we would use lazy evaluation
which is the common case when dealing with the Lambda Calculus.

We can also note that nothing changes if we modify the first part of:

  ((lambda (x) (x x))
   (lambda (x) (f (lambda (z) ((x x) z)))))

to be identical with the second part for the sake of symmetry -- the
evaluation still looks the same except for skipping the first step now:

  ((lambda (x) (f (lambda (z) ((x x) z))))
   (lambda (x) (f (lambda (z) ((x x) z)))))

========================================================================
>>> Recursion: Solution

Back to the factorial problem: applying the delay fix to the above
factorial definition gives:

  (define fact
    ((lambda (make-fact)
       (make-fact make-fact))
     (lambda (make-fact)
       ((lambda (fact)
          (lambda (n)
            (if (zero? n)
              1
              (* n (fact (- n 1))))))
        (lambda (z)                      ;***
          ((make-fact make-fact) z)))))) ;***

And the symmetric version is:

  (define fact
    ((lambda (make-fact)
       ((lambda (fact)                 ;***
          (lambda (n)                  ;***
            (if (zero? n)              ;***
              1                        ;***
              (* n (fact (- n 1))))))  ;***
        (lambda (z)
          ((make-fact make-fact) z)))) ;***
     (lambda (make-fact)
       ((lambda (fact)
          (lambda (n)
            (if (zero? n)
              1
              (* n (fact (- n 1))))))
        (lambda (z)
          ((make-fact make-fact) z))))))

This does look more complex -- but it is actually simpler since the two
parts are the identical.

Now take the `(lambda (fact) ...)' thing, and call it `fact-maker' -- we
get:

  (define fact-maker
    (lambda (fact)
      (lambda (n)
        (if (zero? n)
          1
          (* n (fact (- n 1)))))))
  (define fact
    ((lambda (make-fact)
       (fact-maker         ;***
        (lambda (z)
          ((make-fact make-fact) z))))
     (lambda (make-fact)
       (fact-maker         ;***
        (lambda (z)
          ((make-fact make-fact) z))))))

Using Rule#1, make `fact-maker' an argument for a `make-real-fact'
function:

  (define fact-maker
    (lambda (fact)
      (lambda (n)
        (if (zero? n)
          1
          (* n (fact (- n 1)))))))
  (define (make-real-fact maker) ;***
    ((lambda (make-fact)         ;***
       (maker
        (lambda (z)
          ((make-fact make-fact) z))))
     (lambda (make-fact)
       (maker                    ;***
        (lambda (z)
          ((make-fact make-fact) z))))))

And now the *real* `fact' can be defined with:

  (define fact (make-real-fact fact-maker))

This works -- and the whole thing is not defined recursively!  (It
generates a recursive computation, but the definition uses a well formed
finite expression).

The last thing to note is that `make-real-fact' is totally independent
of `fact', so we can redefine it as a general function:

  (define (make-recursive f)
    ((lambda (x) (f (lambda (z) ((x x) z))))
     (lambda (x) (f (lambda (z) ((x x) z))))))
  (define fact (make-recursive fact-maker))

And we now have general recursion!  -- This also work for other
recursive functions:

  (define make-fib
    (lambda (fib)
      (lambda (n)
        (if (<= n 1)
          n
          (+ (fib (- n 1))
             (fib (- n 2)))))))
  (define fib (make-recursive make-fib))

And another example, without an explicit `make-length' definition:

  (define length
    (make-recursive
      (lambda (length)
        (lambda (l)
          (if (null? l)
            0
            (+ (length (cdr l)) 1))))))

If we have a way to add rewrite rules to the language, we could even
specify a rewrite rule that will create recursive definitions for us:

  (rewrite (define-rec f E)
           => (define f
                (make-recursive (lambda (f) E))))

  (define-rec fact
    (lambda (n)
      (if (<= n 1)
          1
          (* n (fact (- n 1))))))

Finally, note that make-recursive is limited to 1-argument functions
only because of the protection from eager evaluation.  In any case, it
can be used in any way you want, for example,

  (make-recursive (lambda (f) (lambda (x) f)))

is a function that *returns* itself rather than calling itself.  Using
the rewrite rule,

  (define-rec f (lambda (x) f))

is the same as:

  (define (f x) f)

in normal Scheme.

========================================================================
>>> Recursion: the Y Combinator

Our `make-recursive' function is usually called the "fixpoint operator"
or the "Y combinator".

It looks really simple when using the lazy version (remember: our
version is the eager one):

  (define Y
    (lambda (f)
      ((lambda (x) (f (x x)))
       (lambda (x) (f (x x))))))

And this all comes from the loop generated by:

  ((lambda (x) (x x)) (lambda (x) (x x)))

((lambda (x) (x x)) (lambda (x) (x x))), which is also called `omega',
is also the idea behind many deep mathematical facts.  As an example for
what it does, follow the next rule:

  I will say the next sentence twice:
    "I will say the next sentence twice".

(Note the usage of colon for the first and quotes for the second -- what
is the equivalent of that in the lambda expression?)

========================================================================
>>> Recursion: Alternative Explanation

If we go back to where we started,

  (define (fact n)
    (if (zero? n)
      1
      (* n (fact (- n 1)))))
  (fact 120)

We can note that by the time we get to the body of the function, we *do*
have some binding for `fact' -- the one that we have called.  So we can
send that value back to `fact' to make it able to call itself:

  (define (fact self n) ;***
    (if (zero? n)
      1
      (* n (self (- n 1)))))
  (fact fact 120)       ;***

except that now the recursive call should still send itself along:

  (define (fact self n)
    (if (zero? n)
      1
      (* n (self self (- n 1))))) ;***
  (fact fact 120)

The problem is that this required rewriting fact, something we wish to
avoid when we write programs.  We'll try to make it better again -- we
need something with just a `(lambda (n) ...)' for the actual function.
Begin with currying:

  (define (fact self)                  ;***
    (lambda (n)                        ;***
      (if (zero? n)
        1
        (* n ((self self) (- n 1)))))) ;***
  ((fact fact) 120)                    ;***

Now we want to use a real recursive call instead of that "(self self)"
thing:

  (define (fact self)
    (let ([fact (self self)])      ;***
      (lambda (n)
        (if (zero? n)
          1
          (* n (fact (- n 1))))))) ;***
  ((fact fact) 120)

But the problem is that we get into an infinite loop because we're
trying to evaluate "(self self)" too early -- ignoring the body of the
`let' and other details, we basically do this:

  (define (fact self) (self self)) (fact fact)
  --replace-let-with-lambda-->
  (define fact (lambda (self) (self self))) (fact fact)
  --replace-definition-->
  ((lambda (self) (self self)) (lambda (self) (self self)))
  --rename-->
  ((lambda (x) (x x)) (lambda (x) (x x)))

Going back to the same problem with infinity -- what's the solution?  We
know that "(self self)" is ultimately used as a one-argument function,
so we can protect its evaluation until needed, using `lambda' and the
fact that if `f' is a one-argument function, then (lambda (x) (f x)) is
the same function:

  (define (fact self)
    (let ([fact (lambda (x) ((self self) x))]) ;***
      (lambda (n)
        (if (zero? n)
          1
          (* n (fact (- n 1)))))))
  ((fact fact) 120)

Now, since `let' is just a syntactic sugar for a lambda application,
turn that inner `let' to a `lambda':

  (define (fact self)
    ((lambda (fact)                 ;***
       (lambda (n)
         (if (zero? n)
           1
           (* n (fact (- n 1))))))
     (lambda (x) ((self self) x)))) ;***
  ((fact fact) 120)

The resulting `(lambda (fact) ...)' has a binding for the recursive call
(the `fact' argument), and it has the `(lambda (n) ...)' function that
is the body of the factorial function.  So it's actually a kind of a
`fact-maker'.  Call it that:

  (define (fact-maker fact)                    ;***
    (lambda (n)
      (if (zero? n)
        1
        (* n (fact (- n 1))))))
  (define (fact self)
    (fact-maker (lambda (x) ((self self) x)))) ;***
  ((fact fact) 120)

Now, the outer-most `fact' is not really the factorial function, it's
something that *will* be the factorial function when applied to itself,
so why not just apply it to itself, and bind the result of that to
`fact' ? --

  (define (fact-maker fact)
    (lambda (n)
      (if (zero? n)
        1
        (* n (fact (- n 1))))))
  (define fact
    (let ([x (lambda (self) ;***
               (fact-maker
                (lambda (x) ((self self) x))))])
      (x x)))               ;***
  (fact 120)

Again, convert that `let' to a `lambda':

  (define (fact-maker fact)
    (lambda (n)
      (if (zero? n)
        1
        (* n (fact (- n 1))))))
  (define fact
    ((lambda (x) (x x)) ;***
     (lambda (self)
       (fact-maker
        (lambda (x) ((self self) x))))))
  (fact 120)

Rename `self' -> `x':

  (define (fact-maker fact)
    (lambda (n)
      (if (zero? n)
        1
        (* n (fact (- n 1))))))
  (define fact
    ((lambda (x) (x x))
     (lambda (x)                              ;***
       (fact-maker (lambda (z) ((x x) z)))))) ;***
  (fact 120)

and now abstract the recursion-making functionality into a separate
function:

  (define (fact-maker fact)
    (lambda (n)
      (if (zero? n)
        1
        (* n (fact (- n 1))))))
  (define (make-recursive maker)            ;***
    ((lambda (x) (x x))
     (lambda (x) (maker (lambda (z) ((x x) z))))))
  (define fact (make-recursive fact-maker)) ;***
  (fact 120)

And now the resulting `make-recursive' is the same as the version that
was derive above.

========================================================================
>>> Recursion: The Main Property of Y

`fact-maker' is a function that given any limited factorial, will
generates a factorial that is good for one more integer input.  Begin
with `666' which is a factorial that is good for nothing (because it's
not a function), and you can get `fact0' as

  fact0 == (fact-maker 666)

and that's a good factorial function only for an input of 0.  Use that
with `fact-maker' again, and you get

  fact1 == (fact-maker fact0) == (fact-maker (fact-maker 666))

which is the factorial function when you only look at input values of 0
or 1.  In a similar way

  fact2 == (fact-maker fact1)

is good for 0..2 -- and we can continue as much as we want, except that
we need to have an infinite number of applications -- in the general
case, we have:

  fact-n == (fact-maker (fact-maker (fact-maker ... 666)))

which is good for 0..n.  The *real* factorial would be the result of
running fact-maker on itself infinitely, it *is* fact-infinity .  In
other words (here `fact' is the *real* factorial):

  fact = fact-infinity == (fact-maker (fact-maker ...infinitely...))

but note that since this is really infinity, then

  fact = (fact-maker (fact-maker ...infinitely...))
       = (fact-maker fact)

so we get an equation:

  fact = (fact-maker fact)

and a solution for this is going to be the real factorial.  The solution
is the fixed-point of the `fact-maker' function, in the same sense that
0 is the fixed point of the `sin' function because

  0 = (sin 0)

And the Y combinator does just that -- it has this property:

  (make-recursive f) = (f (make-recursive f))

or, using the more common name:

  (Y f) = (f (Y f))

This property encapsulates the real magical power of Y.  You can see how
it works -- because:       (Y f)  =    (f (Y f))
you can also say that:  (f (Y f)) = (f (f (Y f)))
so we get:

  (Y f) = (f (Y f)) = (f (f (Y f))) = (f (f (f (Y f)))) = ...
        = (f (f (f ...)))

and we can conclude that

  (Y fact-maker) = (fact-maker (fact-maker ...infinitely...))
                 = fact

========================================================================
>>> Minimal Language: Lambda Calculus

We know that many constructs that are usually thought of as primitives
are not really needed -- we can implement them ourselves given enough
tools.  The question is how far can we go?

The answer: as far as we want.  For example:

  (define foo((lambda(f)((lambda(x)(x x))(lambda(x)(f(x x)))))(lambda(f
  )(lambda(x)(((x(lambda(x)(lambda(x y) y))(lambda(x y)x))(x(lambda(x)(
  lambda(x y)y))(lambda(x y)x))(((x(lambda(p)(lambda(s)(s(p(lambda(x y)
  y))(lambda(f x)(f((p(lambda(x y)y))f x))))))(lambda(s)(s(lambda(f x)x
  )(lambda(f x)x))))(lambda(x y)x))(lambda(x)(lambda(x y)y))(lambda(x y
  )x)))(lambda(f x)(f x))((f((x(lambda(p)(lambda(s)(s(p(lambda(x y)y))(
  lambda(f x)(f((p(lambda(x y)y))f x))))))(lambda(y s)(s(lambda(f x)x)(
  lambda(f x)x))))(lambda(x y)x)))(lambda(n)(lambda(f x)(f(n f x))))(f(
  (((x(lambda(p)(lambda(s)(s(p(lambda(x y)y))(lambda(f x)(f((p(lambda(x
  y)y))f x))))))(lambda(s)(s(lambda(f x)x)(lambda(f x)x))))(lambda(x y)
  x))(lambda(p)(lambda(s)(s(p(lambda (x y)y))(lambda(f x)(f((p(lambda(x
  y)y))f x))))))(lambda(s)(s(lambda(f x)x)(lambda(f x)x))))(lambda(x y)
  x)))))))))(define foo*(lambda(n)(->nat(foo(nat-> n)))))

We begin with a very minimal language, which is based on the Lambda
Calculus.  In this language we get a very minimal set of constructs and
values.

In DrScheme, this we will use the Schlac language level (for "Scheme as
Lambda Calculus").  This language uses a Scheme-like syntax, but don't
be confused -- it is *very* different from Scheme.  The only constructs
that are available in this language are: lambda expressions of at least
one argument, function application (again, at least one argument), and
simple definition forms which are similar to the ones in the "Broken
define" language -- definitions are used as shorthand, and cannot be
used for recursive function definition.  The BNF is therefore:

  <SCHLAC> ::= <id>
             | (<SCHLAC> <SCHLAC> <SCHLAC> ...)
             | (lambda (<id> <id> ...) <SCHLAC>)
             | (define <id> <SCHLAC>)

Since this language has no primitive values (other than functions),
Scheme numbers and booleans are also considered identifiers, and have no
built-in value that come with the language.  In addition, all functions
and function calls are curried, so

  (lambda (x y z) (z y x))

is actually shorthand for

  (lambda (x) (lambda (y) (lambda (z) ((z y) x))))

The rules for evaluation are simple, there is one very important rule
for evaluation which is called "beta reduction":

  ((lambda (x) E1) E2) --> E1[E2/x]

where substitution in this context requires being careful so you won't
capture names.  This requires you to be able to do another kind of
transformation which is called "alpha conversion", which basically says
that you can rename identifiers as long as you keep the same binding
structure (eg, a valid renaming does not change the de-bruijn form of
the expression).  There is one more rule that can be used, "eta
conversion" which says that `(lambda (x) (f x))' is the same as `f' (we
used this rule above when deriving the Y combinator).

One last difference between Schlac and Scheme is that Schlac is a *lazy*
language.  This will be important since we do not have any built-in
special forms like `if'.

Here is a Schlac definition for the identity function:

  (define identity (lambda (x) x))

and there is not much that we can do with this now:

  > identity
  #<procedure:identity>
  > (identity identity)
  #<procedure:identity>
  > (identity identity identity)
  #<procedure:identity>

(In the last expression, note that `(id id id)' is shorthand for
`((id id) id)', and since `(id id)' is the identity, applying that on
`id' returns it again.)

========================================================================
>>> Lambda Calculus: Church Numerals

So far, it seems like it is impossible to do anything useful in this
language, since all we have are functions and applications.  We know how
to write the identity function, but what about other values?  For
example, can you write code that evaluates to zero?

** What's zero?  I only know how to write functions!
   (Turing Machine programmer: "What's a function?  I only know how to
   write 0s and 1s!")

The first thing we therefore need is to be able to *encode* numbers as
functions.  For zero, we will use a function of two arguments that
simply returns its second value:

  (define 0 (lambda (f) (lambda (x) x)))

or, more concisely

  (define 0 (lambda (f x) x))

This is the first step in an encoding that is known as "Church
Numerals": an encoding of natural numbers as functions.  The number zero
is encoded as a function that takes in a function and a second value,
and applies the function zero times on the argument (which is really
what the above definition is doing).  Following this view, the number
one is going to be a function of two arguments, that applies the first
on the second one time:

  (define 1 (lambda (f x) (f x)))

and note that `1' is just like the identity function (as long as you
give it a function as its first input, but this is always the case in
Schlac).  The next number on the list is two -- which applies the first
argument on the second one twice:

  (define 2 (lambda (f x) (f (f x))))

We can go on doing this, but what we really want is a way to perform
arbitrary arithmetic.  The first requirement for that is an `add1'
function that increments its input (an encoded natural number) by one.
To do this, we write a function that expects an encoded number:

  (define add1 (lambda (n) ...))

and this function is expected to return an encoded number, which is
always a function of `f' and `x':

  (define add1 (lambda (n) (lambda (f x) ...)))

Now, in the body, we need to apply `f' on `x' n+1 times -- but remember
that `n' is a function that will do n applications of its first argument
on its second:

  (define add1 (lambda (n) (lambda (f x) ... (n f x) ...)))

and all we have left to do now is to apply `f' one more time, yielding
this definition for `add1':

  (define add1 (lambda (n) (lambda (f x) (f (n f x)))))

Using this, we can define a few useful numbers:

  (define 1 (add1 0))
  (define 2 (add1 1))
  (define 3 (add1 2))
  (define 4 (add1 3))
  (define 5 (add1 4))

This is all nice theoretically, but how can we make sure that it is
correct?  Well, Schlac has a few additional special forms that translate
Church numerals into Scheme numbers.  To try our definitions we use the
`->nat' (read: to natural number):

  (->nat 0)
  (->nat 5)
  (->nat (add1 (add1 5)))

You can now verify that the identity function is really the same as the
number 1:

  (->nat identity)

We can even write a test case, since Schlac contains the `test' special
form, but we have to be careful in that -- first of all, we cannot test
whether functions are equal (why?) so we must use `->nat', but

  (test (->nat (add1 (add1 5))) => 7)

will not work since `7' is undefined.  To overcome this, Schlac has a
`back-door' for primitive Scheme values -- just use a quote:

  (test (->nat (add1 (add1 5))) => '7)

We can now define natural number addition -- the idea is that we get two
encoded numbers `m' and `n', and what we want to do is begin with `n'
and increment it by 1 m times -- and `m' is itself a function that can
do that: `(m f x)' is m applications of `f' on `x', so `(m add1 n)' is m
applications of `add1' on `n', which is exactly the encoding of m+n:

  (define + (lambda (m n) (m add1 n)))
  (->nat (+ 4 5))

We can also define multiplication of `m' and `n' quite easily -- begin
with addition -- `(lambda (x) (+ n x))' is a function that expects an
`x' and returns x+n -- it's an increment-by-n function.  But since all
functions and applications are curried, this is actually the same as
`(lambda (x) ((+ n) x))' which is the same as `(+ n)'.  Now, what we
want to do is repeat this operation m times over zero, which will add n
to zero m times, which will result in m*n.  The definition is therefore:

  (define * (lambda (m n) (m (+ n) 0)))
  (->nat (* 4 5))
  (->nat (+ 4 (* (+ 2 5) 5)))

An alternative approach is to consider

  (lambda (x) (n f x))

for some encoded number `n' and a function `f' -- this function is like
f^n (f composed n times with itself).  But remember that this is
shorthand for

  (lambda (x) ((n f) x))

and we know that `(lambda (x) (foo x))' is just like `foo' (if it is a
function), so this is equivalent to just

  (n f)

So `(n f)' is f^n, and in the same way `(m g)' is g^m -- if we use
`(n f)' for `g', we get `(m (n f))' which is n self-compositions of `f',
self-composed m times.  In other words, `(m (n f))' is a function that
is like m*n applications of `f', so we can define multiplication as:

  (define * (lambda (m n) (lambda (f) (m (n f)))))

which is the same as

  (define * (lambda (m n f) (m (n f))))

The same principle can be used to define exponentiation (but now we have
to be careful of the order since exponentiation is not commutative):

  (define ^ (lambda (m n) (n (* m) 1)))
  (->nat (^ 3 4))

And there is a similar alternative here too --
* a Church numeral `m' is the m-self-composition function,
* and `(1 m)' is just like m^1 which is the same as `m' (1=identity)
* and `(2 m)' is just like m^2 -- it takes a function `f', self composes
  it m times, and self composes the result m times -- for a total of
  f^m*m
* and `(3 m)' is similarly f^m*m*m
* so `(n m)' is f^(m^n) (note that the first "^" is self-compositions,
  and the second one is a mathematical exponent)
* so `(n m)' is a function that returns m^n self-compositions of an
  input function,
Which means that `(n m)' is the Church numeral for n^m, so we get:

  (define ^ (lambda (m n) (n m)))

which basically says that any number encoding `n' is also the ?^n
operation.

All of this is was too complicated -- but all of these functions did was
increment their inputs in various ways.  What about `sub1'?  For that,
we need to do some more work -- we will need to encode booleans.

========================================================================
>>> Lambda Calculus: More Encodings

Our choice of encoding numbers makes sense -- the idea is that the main
feature of a natural number is repeating something a number of times.
For booleans, the main property we're looking for is choosing between
two values.  So we can encode true and false by functions of two
arguments that return either the first or the second argument:

  (define #t (lambda (x y) x))
  (define #f (lambda (x y) y))

Note that this encoding of `#f' is really the same as the encoding of
`0', so we have to know what type to expect an use the proper operations
(this is similar to C, where everything is just integers).  Now that we
have these two, we can define `if':

  (define if (define (c t e) (c t e)))

it expects a boolean which is a function of two arguments, and passes it
the two expressions.  The #t boolean will simply return the first, and
the #f boolean will return the second.  Strictly speaking, we don't
really need this definition, since instead of writing `(if c t e)', we
can simply write `(c t e)'.  In any case, we need the language to be
lazy for this to work.  To demonstrate this, we'll intentionally use the
quote back-door to use a non-functional value, using this will normally
result in an error:

  (+ '1 '2)

But testing our `if' definition, things work just fine:

  (if #t (+ 4 5) (+ '1 '2))

and we see that DrScheme leaves the second addition expression in red,
which indicates that it was not executed.

How about `and' and `or'?  Simple, `or' takes two arguments, and returns
either true or false if one of the inputs is true:

  (define or (lambda (a b) (if a #t (if b #t #f))))

but `(if b #t #f)' is really the same as just `b' because it's a
boolean:

  (define or (lambda (a b) (if a #t b)))

also, if `a' is true, we want to return #t, but that is exactly the
value of `a', so:

  (define or (lambda (a b) (if a a b)))

and finally, we can get rid of the `if':

  (define or (lambda (a b) (a a b)))

Similarly, convince yourself that the definition of `and' is:

  (define and (lambda (a b) (a b a)))

Schlac has to-Scheme conversion forms for booleans too:

  (->bool (or #f #f))
  (->bool (or #f #t))
  (->bool (or #t #f))
  (->bool (or #t #t))

and

  (->bool (and #f #f))
  (->bool (and #f #t))
  (->bool (and #t #f))
  (->bool (and #t #t))

A `not' function is quite simple -- one alternative is to choose from
true and false in the usual way:

  (define not (lambda (a) (a #f #t)))

and another is to return a function that switches the inputs to an input
boolean:

  (define not (lambda (a) (lambda (x y) (a y x))))

which is the same as

  (define not (lambda (a x y) (a y x)))

We can now put numbers and booleans together: we define a `zero?'
function.

  (define zero? (lambda (n) (n (lambda (x) #f) #t)))
  (test (->bool (and (zero? 0) (not (zero? 3)))) => '#t)

The idea is simple -- if `n' is the encoding of zero, it will return
it's second argument which is #t:

  (zero? 0) --> ((lambda (f n) n) (lambda (x) #f) #t) -> #t

if `n' is an encoding of a bigger number, then it is a self-composition,
and the function that we give it is one that always returns #f, no
matter how many times it is self-composed.  Try 2 for example:

  (zero? 2) --> ((lambda (f n) (f (f n))) (lambda (x) #f) #t)
            --> ((lambda (x) #f) ((lambda (x) #f) #t))
            --> #f

Now, how about an encoding for compound values?  A minimal approach is
what we use in Scheme -- a way to generate pairs (cons), and encode
lists as chains of pairs with a special value at the end (null).  There
is a natural encoding for pairs that we have previously seen -- a pair
is a function that expects a selector, and will apply that on the two
values:

  (define cons (lambda (x y) (lambda (s) (s x y))))

Or, equivalently:

  (define cons (lambda (x y s) (s x y)))

To extract the two values from a pair, we need to pass a selector that
consumes two values and returns one of them.  In our framework, this is
exactly what the two boolean values do, so we get:

  (define car (lambda (x) (x #t)))
  (define cdr (lambda (x) (x #f)))

We can even do this:

  (define 1st car)
  (define 2nd (lambda (l) (car (cdr l))))
  (define 3rd (lambda (l) (car (cdr (cdr l)))))
  (define 4th (lambda (l) (car (cdr (cdr (cdr l))))))
  (define 5th (lambda (l) (car (cdr (cdr (cdr (cdr l)))))))

We now need a special `null' value to mark list ends.  This value should
have the same number of arguments as a `cons' value (one: a
selector/boolean function), and it should be convenient to distinguish
it from other values.  We choose

  (define null (lambda (s) #t))

Testing the list encoding:

  (define l123 (cons 1 (cons 2 (cons 3 null))))
  (->nat (second l123))

And as with natural numbers and booleans, Schlac has built-in facility
to convert encoded lists to Scheme values, except that this requires
specifying the type of values in a list:

  (->list ->nat l123)

We can even do this:

  (->list ->list ->nat (cons l123 (cons l123 null)))

Defining `null?' is now relatively easy -- the following definition

  (define null? (lambda (x) (x (lambda (x y) #f))))

works because if `x' is null, then it simply ignores its argument and
returns #t, and if it's a pair, then it uses the input selector, which
always returns #f in its turn:

  (null? (cons a b))
    --> ((lambda (x) (x (lambda (x y) #f))) (lambda (s) (s a b)))
    --> ((lambda (s) (s a b)) (lambda (x y) #f))
    --> ((lambda (x y) #f) a b)
    --> #f
  (null? null)
    --> ((lambda (x) (x (lambda (x y) #f))) (lambda (s) #t))
    --> ((lambda (s) #t) (lambda (x y) #f))
    --> #t

We can use the Y combinator to create recursive functions -- we can even
use the rewrite rules facility that Schlac contains (the same one that
we have previously seen):

  (define Y
    (lambda (f)
      ((lambda (x) (x x)) (lambda (x) (f (x x))))))
  (rewrite (define/rec f E) => (define f (Y (lambda (f) E))))

and using it:

  (define/rec length
    (lambda (l)
      (if (null? l)
        0
        (add1 (length (cdr l))))))
  (->nat (length l123))

And to complete this, um, journey -- we're still missing subtraction.
There are many ways to solve the problem of subtraction, and for a
challenge try to come up with some way yourself.  One of the clearer
solutions uses a simple `trick' -- begin with a pair of two zeroes
<0,0>, and repeat this transformation n times: <a,b> -> <b,b+1>.  After
n steps, we will have <n-1,n> -- so we get:

  (define inccons (lambda (p) (cons (cdr p) (add1 (cdr p)))))
  (define sub1 (lambda (n) (car (n inccons (cons 0 0)))))
  (->nat (sub1 5))

And from this the road is short to general subtraction, m-n is simply n
applications of `sub1' on m:

  (define - (lambda (m n) (n sub1 m)))
  (test (->nat (- 3 2)) => '1)
  (test (->nat (- (* 4 (* 5 5)) 5)) => '95)

We now have a normal-looking language, and we're ready to do anything we
want.  Here are two popular examples:

  (define/rec fact
    (lambda (x)
      (if (zero? x) 1 (* x (fact (sub1 x))))))
  (test (->nat (fact 5)) => '120)

  (define/rec fib
    (lambda (x)
      (if (or (zero? x) (zero? (sub1 x)))
        1
        (+ (fib (sub1 x)) (fib (sub1 (sub1 x)))))))
  (test (->nat (fib (* 5 2))) => '89)

To get generalized arithmetic capability, Schlac has yet another
built-in facility for translating Scheme natural numbers into Church
numerals:

  (define fib* (lambda (n) (->nat (fib (nat-> n)))))
  (fib* '10)

... and to get to that frightening expression in the beginning, all you
need to do is replace all definitions in the `fib' definition over and
over again until you're left with nothing but lambda expressions and
applications, then reformat the result into some cute shape.  For extra
fun, you can look for immediate applications of lambda expressions and
reduce them manually.

Finally, note that this is just one way to encode things -- other
encodings are possible.  One alternative encoding is available on the
resources page -- it uses a list of N falses as the encoding for N.
This encoding makes it easier to `add1' (just `cons' another `#f'), and
to `sub1' (simply `cdr').  The tradeoff is that arithmetics in general
becomes more complicated, for example, the definition of `+' requires
the fixpoint combinator.  (As expected, some people want to see what can
we do with a language without recursion, so they don't like jumping to Y
too fast.)

========================================================================
>>> Recursive Environments

What we really need for recursion, is a special kind of an environment,
one that can refer to itself.  So instead of doing (note: `call's
removed for readability):

  {with {fact {fun {n}
                {if {zero? n} 1 {* n {fact {- n 1}}}}}}
    {fact 5}}

which does not work for the usual reasons, we want to use some

  {rec {fact {fun {n}
               {if {zero? n} 1 {* n {fact {- n 1}}}}}}
    {fact 5}}

that will do the necessary magic.

One way to achieve this is using the Y combinator as we have seen -- a
kind of a "constructor" for recursive functions.  We can do that in a
similar way to the `rewrite' rule that we have seen in Schlac --
translate the above expression to:

  {with {fact {make-rec
                {fun {fact}
                  {fun {n}
                    {if {zero? n} 1 {* n {fact {- n 1}}}}}}}}
    {fact 5}}

or even:

  {with {fact {{fun {f} {{fun {x} {f {x x}}} {fun {x} {f {x x}}}}}
               {fun {fact}
                 {fun {n}
                   {if {zero? n} 1 {* n {fact {- n 1}}}}}}}}
    {fact 5}}

Now, we will see how it can be used in *our* code to implement a
recursive environment.

If we look at what `with' does in

  {with {fact {fun {n}
                {if {zero? n} 1 {* n {fact {- n 1}}}}}}
    {fact 5}}

then we can say that to evaluate this expression, we evaluate the body
expression in an extended environment that contains `fact', even if a
bogus one that is good for 0 only -- the new environment is created with
something like this:

  extend("fact", make-fact-closure(), env)

so we can take this whole thing as an operation over `env'

  add-fact(env) := extend("fact", make-fact-closure(), env)

This gives us the first-level fact.  But `fact' itself is still
undefined in `env', so it cannot call itself.  We can try this:

  add-fact(add-fact(env))

but that still doesn't work, and it will never work no matter how far we
go:

  add-fact(add-fact(add-fact(add-fact(add-fact(...env...)))))

What we really want is infinity: a place where add-fact works and the
result is the same as what we've started with -- we want to create a
"magical" environment that makes this possible:

  let magic-env = ???
  such that:
     add-fact(magic-env) = magic-env

which basically gives us the illusion of being at the infinity point.
This magic-env thing is exactly the *fixed-point* of the `add-fact'
operation.  We can use:

  magic-env = rec(add-fact)

and following the main property of the Y combinator, we know that:

  magic-env = rec(add-fact)           ; def. of magic-env
            = add-fact(rec(add-fact)) ; Y(f) = f(Y(f))
            = add-fact(magic-env)     ; def. of magic-env

If we want to turn this into an implementation strategy, we can use a Y
combinator in Scheme, but its easier to use Scheme's equivalent: its
ability to create recursive functions.  This will make it a more
practical solution.

There are two ways that make it possible to write recursive functions in
Scheme.  One is to define a function, and use its name to do a recursive
call -- using the Scheme formal rules, we can see that we said that we
mark that we now *know* that a variable is bound to a value.  This is
essentially a side-effect -- we modify what we know, which corresponds
to modifying the global environment.  The second way is a new form:
`letrec'.  This form is similar to `let', except that the scope that is
established includes the named expressions -- it is exactly what we want
`bindrec' to do.  A third way is using recursive local definitions, but
that is equivalent to using `letrec', more on this soon.

========================================================================

Looking at the arrows in the environment diagrams, what we're really
looking for is a closure that has an environment pointer which is the
same environment in which it was defined.  This will make it possible
for `fact' to be bound to a closure that can refer to *itself* since its
environment is the same one in which it is defined.  However, so far we
have no tools that makes it possible to do this.

What we need is to create a "cycle of pointers", and so far we do not
have a way of achieving that: when we create a closure, we begin with an
environment which is saved in the slot's environment slot, but we want
that closure to be the value of a binding in that same environment.

========================================================================
>>> Recursion: Scheme's `letrec'

So we want to add recursion to our language, practically.  We already
know that Scheme makes it possible to write recursive functions, which
is possible because of the way it implements its "global environment":
our evaluator can only *extend* an environment, while Scheme *modifies*
its global environment.  This means that whenever a function is defined
in the global environment, the resulting closure will have it as its
environment "pointer", but the global environment was not extended -- it
stays the same, and was just modified with one additional binding.

But Scheme has another, a bit more organized way of using recursion:
there is a special local-binding construct that is similar to `let', but
allows a function to refer to itself.  It is called `letrec':

  (letrec ([fact (lambda (n)
                   (if (zero? n)
                     1
                     (* n (fact (- n 1)))))])
    (fact 5))

Some people may remember that there was a third way for creating
recursive functions: using local definition in function bodies.  For
example, we have seen things like:

  (define (length list)
    (define (helper list len)
      (if (null? list)
        len
        (helper (cdr list) (+ len 1))))
    (helper list 0))

This looks like the same kind of environment magic that happens with a
global `define' -- but actually, Scheme defines the meaning of internal
definitions using `letrec' -- so the above code is exactly the same as:

  (define (length list)
    (letrec ([helper (lambda (list len)
                       (if (null? list)
                         len
                         (helper (cdr list) (+ len 1))))])
      (helper list 0)))

The scoping rules for a `letrec' is that the scope of the bound name
covers both the body *and* the named expression.  Furthermore, multiple
names can be bound to multiple expressions, and the scope of each name
covers all named expression as well as the body.  This makes it easy to
define mutually recursive functions, such as:

  (letrec ([even? (lambda (n) (if (zero? n) #t (odd?  (- n 1))))]
           [odd?  (lambda (n) (if (zero? n) #f (even? (- n 1))))])
    (even? 99))

But it is not a required functionality -- it could be done with a single
recursive binding that contains several procedures:

  (letrec ([even+odd
            (list (lambda (n)
                    (if (zero? n) #t ((second even+odd) (- n 1))))
                  (lambda (n)
                    (if (zero? n) #f ((first  even+odd) (- n 1)))))])
    ((first even+odd) 99))

This is basically the same problem we face if we want to use the Y
combinator for mutually recursive bindings.  The above solution is
inconvenient, but it can be improved using more `let's to have easier
name access.  For example:

  (letrec ([even+odd
            (list (lambda (n)
                    (let ([even? (first  even+odd)]
                          [odd?  (second even+odd)])
                      (if (zero? n) #t (odd? (- n 1)))))
                  (lambda (n)
                    (let ([even? (first  even+odd)]
                          [odd?  (second even+odd)])
                      (if (zero? n) #f (even? (- n 1))))))])
    (let ([even? (first  even+odd)]
          [odd?  (second even+odd)])
      (even? 99)))

========================================================================
>>> Implementing Recursion using `letrec'

We will see how to add a similar construct to our language -- for
simplicity, we will add a `rec' form that handles a single binding:

  {rec {fact {fun {n}
               {if {= 0 n}
                 1
                 {* n {fact {- n 1}}}}}}
    {fact 5}}

Using this, things can get a little tricky.  What should we get if we
do:

  {rec {x x} x}

?  Currently, it seems like there is no point in using any expression
except for a *function* expression in a `rec' expression, so we will
handle only these cases.

(BTW, under what circumstances would non-function values be useful in a
letrec?)

========================================================================

One way to achieve this is to use the same trick that we have recently
seen: instead of re-implementing Scheme features, we can use existing
features and hope that if Scheme has the right functionality, then it
can be re-used to in our evaluator.

Previously, we have seen a way to implement environments using Scheme
closures:

  ;; Define a type for functional environments
  (define ENV? procedure?)
  ;; These should actually be something like:
  ;; ENV := symbol -> (union-of number procedure)

  ;; empty-env : -> ENV
  (define (empty-env)
    (lambda (id) (error 'lookup "no binding for ~s" id)))

  ;; lookup : symbol ENV -> (union-of number procedure)
  (define (lookup name env)
    (env name))

  ;; extend : symbol (union-of number procedure) ENV -> ENV
  (define (extend id v rest-env)
    (lambda (name)
      (if (eq? name id)
        v
        (rest-env name))))

We can use this implementation, and create circular environments using
Scheme's `letrec'.  The code for handling a `with' expressions is:

  [(With name expr bound-body)
   (eval bound-body
         (extend name (eval expr env) env))]

It looks like we should be able to handle `Rec' in a similar way:

  [(Rec name expr bound-body)
   (eval bound-body
         (extend name (eval expr env) env))]

but this won't work because the named expression is evaluated
prematurely, in the previous environment.  Instead, we will move
everything that needs to be done, including evaluation, to a separate
`extend-rec' function:

  [(Rec name expr bound-body)
   (eval bound-body
         (extend-rec name expr env))]

Now, the `extend-rec' function needs to provide the new, "magically
circular" environment.  Following what we know about the arguments to
`extend-rec', and the fact that it returns a new environment (= a lookup
procedure), we can sketch a rough definition:

  ;; extend-rec : symbol FLANG ENV -> ENV
  (define (extend-rec id expr rest-env)
    (lambda (name)
      (if (eq? name id)
        ... something that uses expr to get a value ...
        (rest-env name))))

What should the missing expression be?  It can simply evaluate the
object given itself:

  ;; extend-rec : symbol FLANG ENV -> ENV
  (define (extend-rec id expr rest-env)
    (lambda (name)
      (if (eq? name id)
        (eval expr ...this environment...)
        (rest-env name))))

But how do we get "this environment", before it is defined?  Well, the
environment is itself a Scheme *function*, so we can use Scheme's
`letrec' to make the function refer to itself recursively:

  ;; extend-rec : symbol FLANG ENV -> ENV
  (define (extend-rec id expr rest-env)
    (letrec ([rec-env (lambda (name)
                        (if (eq? name id)
                          (eval expr rec-env)
                          (rest-env name)))])
      rec-env))

There are several problems here:

1. First, we no longer do a simple lookup in the new environment,
   instead, we evaluate the expression on every such lookup.  This seems
   like a technical point, because we do not have side-effects in our
   language (also because we said that we want to handle only function
   expressions).  Still, it wastes space since each evaluation will
   allocate a new closure.

2. Second, a related problem -- what happens if we try to run this:

     {rec {x x} x}

   ?  Well, we do that stuff to extend the current environment, then
   evaluate the body in the new environment, this body is a single
   variable reference:
     (eval (Id 'x) the-new-env)
   so we look up the value:
     (lookup 'x the-new-env)
   which is:
     (the-new-env 'x)
   which goes into the function which implements this environment, there
   we see that `name' is the same as `name1', so we return:
     (eval expr rec-env)
   but the `expr' here is the original named-expression which is itself
   (Id 'x), and we're in an infinite loop.

We can try to get over these problems using another binding.  Scheme
allows several bindings in a single `letrec' expression, so we change
`rec-extend' to:

  ;; extend-rec : symbol FLANG ENV -> ENV
  (define (extend-rec id expr rest-env)
    (letrec ([rec-env (lambda (name)
                        (if (eq? name id)
                          val
                          (rest-env name)))]
             [val (eval expr rec-env)])
      rec-env))

and it seems to work fine with `fact', but it raises more questions,
beginning with: what is the meaning of:

  (letrec ([x ...]
           [y ...x...])
    ...)

?  Well, DrScheme seems to do the "right thing" in this case, but what
about:

  (letrec ([y ...x...]
           [x ...])
    ...)

?  As a hint, see what happens when we now try to evaluate the
problematic

  {rec {x x} x}

expression (and compare that with the result that you'd get from
Scheme).

It should be clear now why we want to restrict usage to just binding
recursive functions.  There are no problems with such definitions
because when we evaluate a `fun' expression, there is no evaluation of
the body, which is the only place where there are potential references
to the same procedure that is defined -- a function's body is *delayed*,
and executed only when the function is applied later.

But the biggest question that is still open: we just implemented a
circular environment using Scheme's own circular environment
implementation, and that does not explain how they are actually
implemented.  The cycle of pointers that we've implemented depends on
the cycle of pointers that Scheme uses, and that is a black box we want
to open up.

========================================================================
>>> Implementing Circularities

To actually implement a circular structure, we will now use
*side-effects*, using a new kind of Scheme value which supports
mutation: a box.  A box value is built with the `box' constructor:

  (define my-thing (box 7))

the value is retrieved with the `unbox' function,

  (* 6 (unbox my-thing))

and finally, the value can be changed with the `set-box!' function.

  (set-box! my-thing 17)

An important thing to note is that `set-box!' is much like `display'
etc, it returns a value that is not printed in the Scheme REPL, because
there is no point in using the result of a `set-box!', it is called for
the side-effect it generates.  (Languages like C blur this distinction
between returning a value and a side-effect with its assignment
statement.)

As a side note, we now have side effects of two kinds: mutation of
state, and I/O (at least the O part).  (Actually, there is also infinite
looping that can be viewed as another form of a side effect.)  This
means that we're now in a completely different world, and lots of new
things can make sense now.  A few things that you should know about:

* We never used more than one expression in a function body because
  there was no point in it, but now there is.  To evaluate a sequence of
  Scheme expressions, you wrap them in a `begin' expression.

* There are a few places where there is an implicit begin: the body of a
  function (or any lambda expression), the body of a `let' (and
  `let'-relatives), the consequence positions in `cond', `match', and
  `cases' clauses and more.  One of the common places where a `begin' is
  used is in an `if' expression (and some people prefer using `cond'
  instead when there is more than a single expression).

* `if' could get a single expression which is executed when the
  condition is true (and an unspecified value is used otherwise), but
  the language that we are using in this class always forbids this --
  there are convenient special forms for a one-sided `if's: `when' &
  `unless', they can have any number of expressions (they have an
  implicit `begin').

* There is a function called `for-each' which is just like `map', except
  that it doesn't collect the list of results, it is used only for
  performing side effects.

When any one of these things is used (in Scheme or other languages), you
can tell that side-effects are involved, because there is no point in
any of these otherwise.  In addition, any name that ends with a `!'
(bang) is used to mark a function that changes state (usually a function
that only changes state).

So how do we create a cycle?  Simple, boxes can have any value, and they
can be put in other values like lists, so we can do this:

  (define foo (list 1 2 (box 3)))
  (set-box! (third foo) foo)

and we have a circular value.  We use this now to implement `rec' in the
following way:

1. Change environments so that instead of values they hold boxes of
   values: (box-of VAL) instead of VAL, and whenever `lookup' is used,
   the resulting boxed value is unboxed,

2. In a Rec case, create the new environment with some temporary binding
   for the identifier -- any value will do since it should not be used
   (when named expressions are always `fun' expressions),

3. Evaluate the expression in the new environment,

4. Change the binding of the identifier (the box) to the result of this
   evaluation.

The resulting definition is:

  ;; extend-rec : symbol FLANG ENV -> ENV
  (define (extend-rec id expr rest-env)
    (let ([new-cell (box (NumV 42))])
      (let ([new-env (Extend id new-cell rest-env)])
        (let ([value (eval expr new-env)])
          (set-box! new-cell value)
          new-env))))

Scheme has another `let' relative for such cases of multiple-nested
`let's -- `let*'.  This form is a derived form -- it is defined as a
shorthand for using nested `let's.  The above is therefore exactly the
same as this code:

  ;; extend-rec : symbol FLANG ENV -> ENV
  (define (extend-rec id expr rest-env)
    (let* ([new-cell (box (NumV 42))]
           [new-env  (Extend id new-cell rest-env)]
           [value    (eval expr new-env)])
      (set-box! new-cell value)
      new-env))

A complete hacked version of FLANG follows:

  ----------------------------------------------------------------------
  (define-type FLANG
    [Num  (n number?)]
    [Add  (lhs FLANG?) (rhs FLANG?)]
    [Sub  (lhs FLANG?) (rhs FLANG?)]
    [Mul  (lhs FLANG?) (rhs FLANG?)]
    [Div  (lhs FLANG?) (rhs FLANG?)]
    [Id   (name symbol?)]
    [With (name symbol?) (named FLANG?) (body FLANG?)]
    [Rec  (name symbol?) (named FLANG?) (body FLANG?)]
    [Fun  (name symbol?) (body FLANG?)]
    [Call (fun-expr FLANG?) (arg-expr FLANG?)])

  ;; parse-sexpr : s-expr -> FLANG
  ;; to convert s-expressions into FLANGs
  (define (parse-sexpr sexpr)
    (match sexpr
      [(number: n)    (Num n)]
      [(symbol: name) (Id name)]
      [(cons (or 'with 'rec) more)
       (match sexpr
         [(list 'with (list (symbol: name) named) body)
          (With name (parse-sexpr named) (parse-sexpr body))]
         [(list 'rec (list (symbol: name) named) body)
          (Rec name (parse-sexpr named) (parse-sexpr body))]
         [else (error 'parse-sexpr
                      "bad `~s' syntax in ~s" (first sexpr) sexpr)])]
      [(cons 'fun more)
       (match sexpr
         [(list 'fun (list (symbol: name)) body)
          (Fun name (parse-sexpr body))]
         [else (error 'parse-sexpr "bad `fun' syntax in ~s" sexpr)])]
      [(list op left right)
       (let ([make-node
              (match op
                ['+ Add]
                ['- Sub]
                ['* Mul]
                ['/ Div]
                ['call Call]
                [else (error 'parse-sexpr "don't know about ~s" op)])])
         (make-node (parse-sexpr left)
                    (parse-sexpr right)))]
      [else (error 'parse-sexpr "bad syntax in ~s" sexpr)]))

  ;; parse : string -> FLANG
  ;; parses a string containing an FLANG expression to a FLANG AST
  (define (parse str)
    (parse-sexpr (string->sexpr str)))

  ;; Types for environments, values, and a lookup function

  (define-type ENV
    [EmptyEnv]
    [Extend (id symbol?) (v (box-of VAL?)) (rest-env ENV?)])

  (define-type VAL
    [NumV (n number?)]
    [FunV (name symbol?) (body FLANG?) (env ENV?)])

  ;; lookup : symbol ENV -> (box-of VAL)
  (define (lookup name env)
    (cases env
      [(EmptyEnv) (error 'lookup "no binding for ~s" name)]
      [(Extend id boxed-val rest-env)
       (if (eq? id name) boxed-val (lookup name rest-env))]))

  ;; extend-rec : symbol FLANG ENV -> ENV
  (define (extend-rec id expr rest-env)
    (let* ([new-cell (box (NumV 42))]
           [new-env  (Extend id new-cell rest-env)]
           [value    (eval expr new-env)])
      (set-box! new-cell value)
      new-env))

  ;; arith-op : (num num -> num) VAL VAL -> VAL
  ;; gets a Scheme numeric binary operator, and uses it within a NumV
  ;; wrapper
  (define (arith-op op val1 val2)
    (define (NumV->number v)
      (cases v
        [(NumV n) n]
        [else (error 'arith-op "expects a number, got: ~s" v)]))
    (NumV (op (NumV->number val1) (NumV->number val2))))

  ;; eval : FLANG env -> VAL
  ;; evaluates FLANG expressions by reducing them to values
  (define (eval expr env)
    (cases expr
      [(Num n) (NumV n)]
      [(Add l r) (arith-op + (eval l env) (eval r env))]
      [(Sub l r) (arith-op - (eval l env) (eval r env))]
      [(Mul l r) (arith-op * (eval l env) (eval r env))]
      [(Div l r) (arith-op / (eval l env) (eval r env))]
      [(With bound-id named-expr bound-body)
       (eval bound-body
             (Extend bound-id (box (eval named-expr env)) env))]
      [(Rec bound-id named-expr bound-body)
       (eval bound-body
             (extend-rec bound-id named-expr env))]
      [(Id name) (unbox (lookup name env))]
      [(Fun bound-id bound-body)
       (FunV bound-id bound-body env)]
      [(Call fun-expr arg-expr)
       (let ([fval (eval fun-expr env)])
         (cases fval
           [(FunV bound-id bound-body f-env)
            (eval bound-body
                  (Extend bound-id (box (eval arg-expr env)) f-env))]
           [else (error 'eval "`call' expects a function, got: ~s"
                              fval)]))]))

  ;; run : string -> number
  ;; evaluate a FLANG program contained in a string
  (define (run str)
    (let ([result (eval (parse str) (EmptyEnv))])
      (cases result
        [(NumV n) n]
        [else (error 'run
                     "evaluation returned a non-number: ~s" result)])))

  ;; tests

  (test (run "{call {fun {x} {+ x 1}} 4}")
        => 5)
  (test (run "{with {add3 {fun {x} {+ x 3}}}
                {call add3 1}}")
        => 4)
  (test (run "{with {add3 {fun {x} {+ x 3}}}
                {with {add1 {fun {x} {+ x 1}}}
                  {with {x 3}
                    {call add1 {call add3 x}}}}}")
        => 7)
  (test (run "{with {identity {fun {x} x}}
                {with {foo {fun {x} {+ x 1}}}
                  {call {call identity foo} 123}}}")
        => 124)
  (test (run "{with {x 3}
                {with {f {fun {y} {+ x y}}}
                  {with {x 5}
                    {call f 4}}}}")
        => 7)
  (test (run "{call {call {fun {x} {call x 1}}
                          {fun {x} {fun {y} {+ x y}}}}
                    123}")
        => 124)
  ----------------------------------------------------------------------

========================================================================
>>> Variable Mutation

The code that we now have implements recursion by *changing* bindings,
and to make that possible we made environments hold boxes for all
bindings, therefore bindings are *all* mutable now.  We can use this to
add more functionality to our evaluator, by allowing changing any
variable -- we can add a `set!' form:

  {set! <id> <FLANG>}

to the evaluator that will modify the value of a variable.  To implement
this functionality, all we need to do is to use `lookup' to retrieve
some box, then evaluate the expression and put the result in that box.
The actual implementation is left as a homework exercise.

One thing that should be considered here is -- all of the expressions in
our language evaluate to some value, the question is what should be the
value of a `set!' expression?  There are three obvious choices:

1. return some bogus value,

2. return the value that was assigned,

3. return the value that was previously in the box.

Each one of these has its own advantage -- for example, C uses the
second option to `chain' assignments (eg, "x = y = 0") and to allow side
effects where an expression is expected (eg, "while (x = x-1) ...").

The third one is useful in cases where you might use the old value that
is overwritten -- for example, if C had this behavior, you could `pop' a
value from a linked list using something like:

  car(l = cdr(l));

because the argument to `car' will be the old value of `l', before it
changed to be its cdr.  You could also swap two variables in a single
expression: "x = y = x".

(Note that the expression "x = x + 1" has the meaning of C's "++x" when
option (2) is used, and "x++" when option (3) is used.)

Scheme chooses the first option, and we will do the same in our
language.  The advantage here is that you get no discounts, therefore
you must be explicit about what values you want to return in situations
where there is no obvious choice.  This leads to more robust programs
since you do not get other programmers that will rely on a feature of
your code that you did not plan on.

In any case, the modification that introduces mutation is small, but it
has a tremendous effect on our language: it was true for Scheme, and it
is true for FLANG.  We have seen how mutation affects the Scheme subset
that we use, and in the extension of our FLANG the effect is even
stronger: since *any* variable can change (there is no need for an
explicit `box' value).  In other words, a binding is not always the same
-- in can change as a result of a `set!' expression.  Of course, we
could extend our language with boxes (using Scheme boxes to implement
FLANG boxes), but that will be a little more verbose.

(Note that Scheme does have a `set!' form, also, fields in structs and
lists are modifiable.  For example, `set-car!' and `set-cdr!' can be
used to modify lists.  However, we do not use any of these.  At least
not for now.)

========================================================================
>>> Substitution vs. Environments

A quick example of how mutation can be used:

  (define counter
    (let ([counter (box 0)])
      (lambda ()
        (set-box! counter (+ 1 (unbox counter)))
        (unbox counter))))

and compare that to:

  (define (make-counter)
    (let ([counter (box 0)])
      (lambda ()
        (set-box! counter (+ 1 (unbox counter)))
        (unbox counter))))

It is a good idea if you follow the exact evaluation of

  (define foo (make-counter))
  (define bar (make-counter))

and see how both bindings have separate environment so each one gets its
own private state.  The equivalent TOY code that can be used once you
extend it doesn't need boxes:

  {bind {{make-counter
           {fun {}
             {bind {{counter 0}}
               {fun {}
                 {set! counter {+ counter 1}}
                 counter}}}}}
    {bind {{foo {make-counter}}
           {bar {make-counter}}}
      ...}}

(To see multiple values from a single expression you can extend the TOY
language with a `list' binding.)  Note that we cannot describe this
behavior with substitution rules!  We now use the environments to make
it possible to change bindings -- so finally an environment is actually
an environment rather than a substitution cache.

When you look at the above, note that we still use lexical scope -- in
fact, the local binding is actually a private state that nobody can
access.  For example, if we write this:

  (define counter
    (let ([counter (box 0)])
      (lambda ()
        (set-box! counter (+ 1 (unbox counter)))
        (if (zero? (modulo (unbox counter) 4)) 'tock 'tick))))

then the resulting function that us bound to `counter' keeps a local
integer state which no other code can access -- you cannot modify it,
reset it, or even know if it is really an integer that is used in there.

========================================================================
>>> Implementing Objects

We have already seen how several pieces of information can be
encapsulate in a Scheme closure that keeps them all; now we can do a
little more -- we can actually have mutable state, which leads to a
natural way to implement objects.  For example:

  (define (make-point x y)
    (let ([xbox (box x)]
          [ybox (box y)])
      (lambda (msg)
        (match msg
          ['getx (unbox xbox)]
          ['gety (unbox ybox)]
          ['incx (set-box! xbox (add1 (unbox xbox)))]))))

implements a constructor for `point' objects which keep two values and
can move one of them.  Note that the messages act as a form of methods,
and that the values themselves are hidden and are accessible only
through the interface that these messages make.  For example, if these
points correspond to some graphic object on the screen, we can easily
incorporate a necessary screen update:

  (define (make-point x y)
    (let ([xbox (box x)]
          [ybox (box y)])
      (lambda (msg)
        (match msg
          ['getx (unbox xbox)]
          ['gety (unbox ybox)]
          ['incx (set-box! xbox (add1 (unbox xbox)))
                 (update-screen)]))))

and be sure that this is always done when the value changes -- since
there is no way to change the value except through this interface.

A more complete example would define functions that actually send these
messages -- here is a better implementation of a point object and the
corresponding accessors and mutators:

  (define (make-point x y)
    (let ([xbox (box x)]
          [ybox (box y)])
      (lambda (msg)
        (match msg
          ['getx (unbox xbox)]
          ['gety (unbox ybox)]
          ['setx (lambda (newx)
                   (set-box! xbox newx)
                   (update-screen))]
          ['sety (lambda (newy)
                   (set-box! ybox newy)
                   (update-screen))]))))
  (define (point-x p) (p 'getx))
  (define (point-y p) (p 'gety))
  (define (set-point-x! p x) ((p 'setx) x))
  (define (set-point-y! p y) ((p 'sety) y))

========================================================================
>>> Toy

A quick note: from now on, we will work with a variation of our language
-- it will change the syntax to look a little more like Scheme, and we
will use Scheme values for values in our language and Scheme procedures
for built-ins in our language.

  ----------------------------------------------------------------------
  ;;; ==================================================================
  ;;; Syntax

  #| The BNF:
     <TOY> ::= <num>
             | <id>
             | { bind {{ <id> <TOY> } ... } <TOY> }
             | { fun { <id> ... } <TOY> }
             | { if <TOY> <TOY> <TOY> }
             | { <TOY> <TOY> ... }
  |#

  ;; A matching abstract syntax tree datatype:
  (define-type TOY
    [Num  (n number?)]
    [Id   (name symbol?)]
    [Bind (names unique-names?) (exprs (list-of TOY?)) (body TOY?)]
    [Fun  (names unique-names?) (body TOY?)]
    [Call (fun-expr TOY?) (arg-exprs (list-of TOY?))]
    [If   (cond-expr TOY?) (then-expr TOY?) (else-expr TOY?)])

  ;; unique-list? : list -> bool
  ;; Tests whether a list is unique, used to make `unique-names?' below.
  (define (unique-list? xs)
    (or (null? xs)
        (and (not (member (first xs) (rest xs)))
             (unique-list? (rest xs)))))

  ;; unique-names? : any -> bool
  ;; A predicate that is used to specify a type of unique symbol lists.
  (define unique-names?
    (intersection-of (list-of symbol?) unique-list?))

  ;; parse-sexpr : s-expr -> TOY
  ;; to convert s-expressions into TOYs
  (define (parse-sexpr sexpr)
    (match sexpr
      [(number: n)    (Num n)]
      [(symbol: name) (Id name)]
      [(cons 'bind more)
       (match sexpr
         [(list 'bind (list (list (symbol: names) nameds) ...) body)
          (Bind names (map parse-sexpr nameds) (parse-sexpr body))]
         [else (error 'parse-sexpr "bad `bind' syntax in ~s" sexpr)])]
      [(cons 'fun more)
       (match sexpr
         [(list 'fun (list (symbol: names) ...) body)
          (Fun names (parse-sexpr body))]
         [else (error 'parse-sexpr "bad `fun' syntax in ~s" sexpr)])]
      [(cons 'if more)
       (match sexpr
         [(list 'if cond then else)
          (If (parse-sexpr cond) (parse-sexpr then) (parse-sexpr else))]
         [else (error 'parse-sexpr "bad `if' syntax in ~s" sexpr)])]
      [(list fun args ...) ; other lists are applications
       (Call (parse-sexpr fun)
             (map parse-sexpr args))]
      [else (error 'parse-sexpr "bad syntax in ~s" sexpr)]))

  ;; parse : string -> TOY
  ;; Parses a string containing an TOY expression to a TOY AST.
  (define (parse str)
    (parse-sexpr (string->sexpr str)))

  ;;; ==================================================================
  ;;; Values and environments

  (define-type ENV
    [EmptyEnv]
    [FrameEnv (frame frame?) (rest ENV?)])

  (define-type VAL
    [ScmV  (x any?)]
    [FunV  (names unique-names?) (body TOY?) (env ENV?)]
    [PrimV (prim procedure?)])

  ;; a frame is an association list of names and values.
  (define frame?
    (list-of (lambda (x)
               (and (list? x)
                    (= 2 (length x))
                    (symbol? (first x))
                    (VAL? (second x))))))

  ;; extend : (list-of symbol) (list-of VAL) ENV -> ENV
  ;; extends an environment with a new frame.
  (define (extend names values env)
    (if (= (length names) (length values))
      (FrameEnv (map list names values) env)
      (error 'extend "arity mismatch for names: ~s" names)))

  ;; lookup : symbol ENV -> VAL
  ;; looks a name in an environment, searching through each frame.
  (define (lookup name env)
    (cases env
      [(EmptyEnv) (error 'lookup "no binding for ~s" name)]
      [(FrameEnv frame rest)
       (let ([cell (assq name frame)])
         (if cell
           (second cell)
           (lookup name rest)))]))

  ;; scheme-func->prim-val : (any ... -> any) -> VAL
  ;; converts a scheme function to a primitive evaluator function which
  ;; is a PrimV holding a ((list-of any) -> any) procedure.  (the result
  ;; procedure doesn't check for types and arity.)
  (define (scheme-func->prim-val scheme-func)
    (PrimV (lambda (args)
             (let ([args (map (lambda (a)
                                (cases a
                                  [(ScmV v) v]
                                  [else (error 'scheme-func
                                               "bad input: ~s" a)]))
                              args)])
               (ScmV (apply scheme-func args))))))

  ;; The global environment has a few primitives:
  (define global-environment
    (FrameEnv (list (list '+ (scheme-func->prim-val +))
                    (list '- (scheme-func->prim-val -))
                    (list '* (scheme-func->prim-val *))
                    (list '/ (scheme-func->prim-val /))
                    (list '< (scheme-func->prim-val <))
                    (list '> (scheme-func->prim-val >))
                    (list '= (scheme-func->prim-val =))
                    ;; values
                    (list 'true  (ScmV #t))
                    (list 'false (ScmV #f)))
              (EmptyEnv)))

  ;;; ==================================================================
  ;;; Evaluation

  ;; eval : TOY env -> VAL
  ;; evaluates TOY expressions.
  (define (eval expr env)
    (cases expr
      [(Num n)   (ScmV n)]
      [(Id name) (lookup name env)]
      [(Bind names exprs bound-body)
       (eval bound-body
             (extend names
                     (map (lambda (e) (eval e env)) exprs)
                     env))]
      [(Fun names bound-body)
       (FunV names bound-body env)]
      [(Call fun-expr arg-exprs)
       (let ([fval (eval fun-expr env)]
             [arg-vals (map (lambda (e) (eval e env)) arg-exprs)])
         (cases fval
           [(PrimV proc) (proc arg-vals)]
           [(FunV names body fun-env)
            (eval body (extend names arg-vals fun-env))]
           [else (error 'eval "function call with a non-function: ~s"
                        fval)]))]
      [(If cond-expr then-expr else-expr)
       (eval (if (cases (eval cond-expr env)
                   [(ScmV v) v] ; Scheme value => use as boolean
                   [else #t])   ; other values are always true
               then-expr
               else-expr)
             env)]))

  ;; run : string -> any
  ;; evaluate a TOY program contained in a string
  (define (run str)
    (let ([result (eval (parse str) global-environment)])
      (cases result
        [(ScmV v) v]
        [else (error 'run
                     "evaluation returned a bad value: ~s" result)])))

  ;;; ==================================================================
  ;;; Tests

  (test (run "{{fun {x} {+ x 1}} 4}")
        => 5)
  (test (run "{bind {{add3 {fun {x} {+ x 3}}}} {add3 1}}")
        => 4)
  (test (run "{bind {{add3 {fun {x} {+ x 3}}}
                     {add1 {fun {x} {+ x 1}}}}
                {bind {{x 3}} {add1 {add3 x}}}}")
        => 7)
  (test (run "{bind {{identity {fun {x} x}}
                     {foo {fun {x} {+ x 1}}}}
                {{identity foo} 123}}")
        => 124)
  (test (run "{bind {{x 3}}
                {bind {{f {fun {y} {+ x y}}}}
                  {bind {{x 5}}
                    {f 4}}}}")
        => 7)
  (test (run "{{{fun {x} {x 1}}
                {fun {x} {fun {y} {+ x y}}}}
               123}")
        => 124)

  ;;; ==================================================================
  ----------------------------------------------------------------------

========================================================================
>>> "Compilation" and Partial Evaluation

Instead of interpreting an expression, which is performing a full
evaluation, we can think about "compiling" it, which is translating it
to a different language which we can later run more easily.  Another
feature that is usually associated with compilation is that a lot more
work was done at the compilation stage, making the actual running of the
code faster.

For example, translating an AST into one that has de-Bruijn indices
instead of identifier names is a form of compilation -- not only is it
translating one language into another, it does the work involved in name
lookup before the program starts running.

This is something that we can experiment with now.  An easy way to
achieve this is start with our evaluation function:

  ;; eval : TOY env -> VAL
  ;; evaluates TOY expressions
  (define (eval expr env)
    (cases expr
      [(Num n) (ScmV n)]
      [(Bind names exprs bound-body)
       (eval bound-body
             (Extend names
                     (map (lambda (e) (eval e env)) exprs)
                     env))]
      [(Id name) (lookup name env)]
      [(Fun bindings body) (FunV bindings body env)]
      [(Call fun-expr arg-exprs)
       (let ([arg-vals (map (lambda (e) (eval e env)) arg-exprs)])
         (cases (eval fun-expr env)
           [(PrimV p) (p arg-vals)]
           [(FunV bindings body fun-env)
            (eval body (extend bindings arg-vals fun-env))]
           [else (error 'eval "call got a non-function value")]))]
      [(If cond-expr then-expr else-expr)
       (eval (if (cases (eval cond-expr env)
                   [(ScmV v) v]   ; any value => also boolean
                   [(PrimV p) #t] ; other values are always true
                   [(FunV bs body env) #t])
               then-expr
               else-expr)
             env)]))

and change it so it compiles a given expression to a Scheme function.
(This is, of course, just to demonstrate a conceptual point, it is only
the tip of what compilers actually do...)  This means that we need to
turn it into a function that receives a TOY expression.  This means that
we get one part of the input, but no environment -- but this is fine
because the environment is determined at run-time.  So we split the two
arguments into a compile-time and run-time, which can be done by simply
currying this function:

  ;; eval : TOY -> (env -> VAL) ; note the different type
  ;; evaluates TOY expressions
  (define (eval expr)
    (lambda (env)
      (cases expr
        [(Num n) (ScmV n)]
        [(Bind names exprs bound-body)
         ((eval bound-body)
          (Extend names
                  (map (lambda (e) ((eval e) env)) exprs)
                  env))]
        [(Id name) (lookup name env)]
        [(Fun bindings body) (FunV bindings body env)]
        [(Call fun-expr arg-exprs)
         (let ([arg-vals (map (lambda (e) ((eval e) env))
                              arg-exprs)])
           (cases ((eval fun-expr) env)
             [(PrimV p) (p arg-vals)]
             [(FunV bindings body fun-env)
              ((eval body) (extend bindings arg-vals fun-env))]
             [else (error 'eval "call got a non-function value")]))]
        [(If cond-expr then-expr else-expr)
         ((eval (if (cases ((eval cond-expr) env)
                      [(ScmV v) v]   ; any value => also boolean
                      [(PrimV p) #t] ; other values always true
                      [(FunV bs body env) #t])
                  then-expr
                  else-expr))
          env)])))

Now instead of:

  ;; run : s-expr -> VAL
  (define (run expr)
    (eval (parse expr) global-environment))

We need to first "compile" the parsed expression, then run the result in
the global environment:

  ;; run : s-expr -> VAL
  (define (run expr)
    ((eval (parse expr)) global-environment))

And also change places where `eval' calls itself recursively.

Not much has changed, but if we need to run a program several times,
then we wouldn't want to parse it over and over again -- so we'd keep a
single parsed version of it.  Now we went one step further by making it
possible to do more work ahead and keep the result of the first `stage'
of eval around:

  ;; run : s-expr -> VAL
  (define (run expr)
    (let ([compiled (eval (parse expr))])
      (compiled global-environment))) ; run the program

and we should really rename `eval' to `compile':

  ;; compile : TOY -> (env -> VAL)
  ;; compiles a TOY expression to a Scheme procedure
  (define (compile expr)
    (lambda (env)
      (cases expr
        [(Num n) (ScmV n)]
        [(Bind names exprs bound-body)
         ((compile bound-body)
          (extend names
                  (map (lambda (e) ((compile e) env)) exprs)
                  env))]
        [(Id name) (lookup name env)]
        [(Fun bindings body) (FunV bindings body env)]
        [(Call fun-expr arg-exprs)
          (let ([arg-vals (map (lambda (e) ((compile e) env))
                               arg-exprs)])
            (cases ((compile fun-expr) env)
              [(PrimV p) (p arg-vals)]
              [(FunV bindings body fun-env)
               ((compile body) (extend bindings arg-vals fun-env))]
              [else (error 'compile
                           "call got a non-function value")]))]
        [(If cond-expr then-expr else-expr)
         ((compile (if (cases ((compile cond-expr) env)
                         [(ScmV v) v]   ; any value=> also boolean
                         [(PrimV p) #t] ; other values always true
                         [(FunV bs body env) #t])
                     then-expr
                     else-expr))
          env)])))

  ;; run : s-expr -> VAL
  (define (run expr)
    (let ([compiled (compile (parse expr))])
      (compiled global-environment)))

========================================================================

So far, nothing much changed.  We curried the `eval' function and
renamed it to `compile'.  But when we actually call compile, then almost
nothing happens.  We now know that the only thing that happens when we
call `compile' is a Scheme closure is generated, it remembers the `expr'
object, and the code that begins with `(lambda (env) ...)', but that's
all.  Running this "compiled" code is going to be very much like the
previous usage of `eval', except a little *slower*, because now every
recursive call involves calling `compile' which generates a closure, and
then immediately use this closure -- so we just added some allocations
at recursive call points!

However, the conceptual change is dramatic -- we now have a function
that works using two stages -- the part that gets an expression which
does compile-time stuff, and the part that does the run-time stuff.  The
only thing is that right now, we do almost nothing in the compilation
stage (remember: only creating a closure, not actually doing anything).
But because we have two stages, we can now shift work from one stage
(ie, run-time) to the other (compile-time).

For example, consider this simple example -- begin with `foo', and
`bar' which uses it:

  (define (foo x y)
    (* x y))

  (define (bar c)
    (letrec ([loop (lambda (n acc)
                     (if (< 0 n)
                       (loop (- n 1) (+ (foo c n) acc))
                       acc))])
      (loop 10000000 0)))

We do the same thing -- separate it into two stages using currying, and
modify `bar' appropriately:

  (define (foo x)
    (lambda (y)
      (* x y)))

  (define (bar c)
    (let ([foo-c (foo c)])
      (letrec ([loop (lambda (n acc)
                       (if (< 0 n)
                         (loop (- n 1) (+ (foo-c n) acc))
                         acc))])
        (loop 10000000 0))))

Now instead of a simple multiplication, lets expand it a little, for
example, do a case split on common cases where x is 0, 1, or 2:

  (define (foo x)
    (lambda (y)
      (cond [(= x 0) 0]
            [(= x 1) y]
            [(= x 2) (bitwise-shift y 1)] ; assume this is much faster
            [else (* x y)])))

(This is not faster, since MzScheme already optimizes multiplication in
a similar way.)

Now comes the real magic: deciding what branch of the cond to take
depends *only* on x, so we can `push' the lambda inside:

  (define (foo x)
    (cond [(= x 0) (lambda (y) 0)]
          [(= x 1) (lambda (y) y)]
          [(= x 2) (lambda (y) (bitwise-shift y 1))]
          [else (lambda (y) (* x y))]))

We just made an improvement -- the comparisons for the common cases are
now done as soon as (foo x) is called, they're not delayed to when the
resulting function is used.  Now go back to the way this is used in
`bar':

  (define (bar c)
    (let ([foo-c (foo c)])
      (... (foo-c i) ...)))

it used the same c, so now foo-c is generated once.  If `c' happens to
be one of the three common cases, we're very lucky since we don't do any
multiplications at all.  (And if we hit the default case, then we're
doing the same thing we did before.)

Common template example:

  (define (foo flag? list)
    (map (lambda (n) (if flag? ...)) list))

  (define (foo flag? list)
    (let ([f (if flag?
               (lambda (n) E1)
               (lambda (n) E2))])
      (map f list)))

(Question: when can you do that?)

========================================================================

Getting our thing closer to a compiler is done in a similar way -- we
push the `(lambda (env) ...)' inside the various cases:

  ;; compile : TOY -> (env -> VAL)
  ;; compiles a TOY expression to a Scheme procedure
  (define (compile expr)
    (cases expr
      [(Num n) (lambda (env) (ScmV n))]
      [(Bind names exprs bound-body)
       (lambda (env)
         ((compile bound-body)
          (extend names
                  (map (lambda (e) ((compile e) env)) exprs)
                  env)))]
      [(Id name) (lambda (env) (lookup name env))]
      [(Fun bindings body) (lambda (env) (FunV bindings body env))]
      [(Call fun-expr arg-exprs)
       (lambda (env)
         (let ([arg-vals (map (lambda (e) ((compile e) env))
                              arg-exprs)])
           (cases ((compile fun-expr) env)
             [(PrimV p) (p arg-vals)]
             [(FunV bindings body fun-env)
              ((compile body) (extend bindings arg-vals fun-env))]
             [else (error 'compile
                          "call got a non-function value")])))]
      [(If cond-expr then-expr else-expr)
       (lambda (env)
         ((compile (if (cases ((compile cond-expr) env)
                         [(ScmV v) v]   ; any value=> also boolean
                         [(PrimV p) #t] ; other values always true
                         [(FunV bs body env) #t])
                     then-expr
                     else-expr))
          env))]))

and we have just shifted a whole bunch of stuff to compile time -- the
code that checks what structure we have, and extracts its different
slots.

But we can do even better than that.  Consider the case for `Bind':

      [(Bind names exprs bound-body)
       (lambda (env)
         ((compile bound-body)
          (extend names
                  (map (lambda (e) ((compile e) env)) exprs)
                  env)))]

At compile-time we identify and deconstruct the Bind structure, then
create a closure that has easy access to these parts.  But still, this
closure calls `compile' first on the bound-body, but the bound-body is
an expression that is known at compile-time (it is bound in the cases
slots, before the resulting (lambda (env) ...)).  So we can get that
done at compile time too:

      [(Bind names exprs bound-body)
       (let ([body (compile bound-body)])
         (lambda (env)
           (body (extend names
                         (map (lambda (e) ((compile e) env)) exprs)
                         env))))]

Further than that, notice that the arguments are all compiled in the
resulting compiled closure, but these also depend only on the input
expressions so can be computed before we return the compiled object:

      [(Bind names exprs bound-body)
       (let ([body  (compile bound-body)]
             [exprs (map compile exprs)])
         (lambda (env)
           (body (extend names
                         (map (lambda (e) (e env)) exprs)
                         env))))]

========================================================================
>>> Lazy evaluation: using a Lazy Scheme

For this part, we will use a new language level: "Lazy Scheme".  As the
name suggests, this is a version of Scheme that is lazy.

First of all, let's verify that this is indeed a lazy language:

  > (define (foo x) 3)
  > (foo (+ 1 "2"))
  3

That went without a problem -- the argument expression was indeed not
evaluated.  In this language, you can treat all expressions as future
`promises' to evaluate.  There are certain points where such promises
are actually `forced', all of these stem from a need to print a
resulting value:

  > (+ 1 "2")
  +: expects type <number> as 2nd argument, given: "2"; other arguments
  were: 1

The expression by itself only generates a promise, but when we want to
print it, this promise is forced to evaluate -- this forces the
addition, which forces its arguments (plain values rather than
computation promises), and at this stage we get an error.  (If we never
want to see any results, then the language will never do anything at
all.)  So a promise is forced either when a value printout is needed, or
if it is needed to recursively compute a value to print:

  > (* 1 (+ 2 "3"))
  +: expects type <number> as 2nd argument, given: "3"; other arguments
  were: 2

Note that the error was raised by the internal expression: the outer
expression uses `*', and `+' requires actual values not promises.

Another example, which is now obvious, is that we can now define an `if'
function:

  > (define (my-if x y z) (if x y z))
  > (my-if (< 1 2) 3 (+ 4 "5"))
  3

Actually, in this Scheme `if', `and', and `or' are all procedure values
instead of special forms:

  > (list if and or)
  (#<procedure:if> #<procedure:and> #<procedure:or>)

(By now, you should know that these have no value in Scheme -- using
them like this in plain will lead to syntax errors.)  There are some
primitives that do not force their arguments.  Constructors fall in this
category, for example `cons' and `list':

  > (define a (list 1 2 (+ 3 "4") (* 5 6)))

Nothing -- the definition simply worked, but that's expected, since
nothing is printed.  If we try to inspect this value, we can get some of
its parts, provided we do not force the bogus one:

  > (first a)
  1
  > (second a)
  2
  > (fourth a)
  30
  > (third a)
  +: expects type <number> as 2nd argument, given: "4"; other arguments
  were: 3

The same holds for cons:

  > (second (cons 1 (cons 2 (first null))))
  2

Now if this is the case, then how about this:

  > (define ones (cons 1 ones))

Everything is fine, as expected -- but what is the value of `ones' now?
Clearly, it is a list that has 1 as its first element:

  > (car ones)
  1

But what do we have in the tail of this list?  We have `ones' which we
already know is a list that has 1 in its first place -- so following
Scheme's usual rules, it means that the second element of `ones' is,
again, 1.  If we continue this, we can see that `ones' is, in fact, an
*infinite* list of 1s:

  > (second ones)
  1
  > (fifth ones)
  1

In this sense, the way `define' behaves is that it defines a true
equation: if ones is defined as (cons 1 ones), then the real value does
satisfy

  (equal? ones (cons 1 ones))

which means that the value is the fixpoint of the defined expression.

We can use `append' in a similar way:

  > (define foo (append (list 1 2 3) foo))
  > (fourth foo)
  1

This looks like it has some common theme with the discussion of
implementing recursive environments -- it actually demonstrates that in
this language, `letrec' can be used for "simple" values too.  First of
all, a side note -- here an expression that indicated a bug in our
substituting evaluator:

  > (let ([x (list y)])
      (let ([y 1])
        x))
  reference to undefined identifier: y

When our evaluator returned `1' for this, we noticed that this was a
bug: it does not obey the lexical scoping rules.  As seen above, the
lazy Scheme is correctly using lexical scope.  Now we can go back to the
use of `letrec' -- what do we get by this definition:

  > (define twos (let ([xs (cons 2 xs)]) xs))

we get an error:

  > (first twos)
  reference to undefined identifier: xs

`xs' is unbound because of the usual scope that `let' uses.  How can we
make this work?  -- We simply use `letrec':

  > (define twos (letrec ([xs (cons 2 xs)]) xs))
  > (first twos)
  2

As expected, if we try to print an infinite list will cause an infinite
loop, which DrScheme catches and prints in that weird way:

  > twos
  #0=(2 . #0#)

How would we inspect an infinite list?  We write a function that returns
part of it:

  > (define (take n l)
      (if (or (<= n 0) (null? l))
        null
        (cons (car l) (take (sub1 n) (cdr l)))))
  > (take 10 twos)
  (2 2 2 2 2 2 2 2 2 2)
  > (define foo (append (list 1 2 3) foo))
  > (take 10 foo)
  (1 2 3 1 2 3 1 2 3 1)

Dealing with infinite lists can lead to lots of interesting things, for
example:

  > (define fibs (cons 1 (cons 1 (map + fibs (cdr fibs)))))
  > (take 10 fibs)
  (1 1 2 3 5 8 13 21 34 55)

Too see how it works, see what you know about `fibs[n]' which will be
our notation for the nth element of `fibs' (starting from 1):

  fibs[1] = 1  because of the first `cons'
  fibs[2] = 1  because of the second `cons'

and for all n>2:

  fibs[n] = (map + fibs (cdr fibs))[n-2]
          = fibs[n-2] + (cdr fibs)[n-2]
          = fibs[n-2] + fibs[n-2+1]
          = fibs[n-2] + fibs[n-1]

so it follows the exact definition of Fibonacci numbers.

========================================================================

There are a few issues that we need to be aware of when we're dealing
with a lazy language.  First of all, remember that our previous attempt
at lazy evaluation has made

  {with {x y}
    {with {y 1}
      x}}

evaluate to 1, which does not follow the rules of lexical scope.  This
is *not* a problem with lazy evaluation, but rather a problem with our
naive implementation.  We will shortly see a way to resolve this
problem.  In the meanwhile, remember that when we try the same in Lazy
Scheme we do get the expected error:

  > (let ([x y])
      (let ([y 1])
        x))
  reference to undefined identifier: y

A second issue is a subtle point that you might have noticed when we
played with Lazy Scheme: for some of the list values we have see a "."
printed.  This is part of the standard way Scheme displays an "improper
list" -- any list that does not terminate with a null value.  For
example, in normal Scheme:

  > (cons 1 2)
  (1 . 2)
  > (cons 1 (cons 2 (cons 3 4)))
  (1 2 3 . 4)

In the dialect that we're using in this course, this is not possible.
The secret is that the `cons' that we use first checks that its second
argument is a proper list, and it will raise an error if not.  So how
come Lazy Scheme's `cons' is not doing the same thing?  The problem is
that to know that something is a proper list, we will have to force it,
which will make it not behave like a constructor.

Finally, there are two consequences of using a lazy language that make
it more difficult to debug (or at lease take some time to get used to).
First of all, control tends to flow in surprising ways.  For example,
enter the following into DrScheme, and run it in the normal language
level for the course:

  (define (foo3 x)
    (/ x "1"))

  (define (foo2 x)
    (foo3 x))
                      (define (foo1 x)
                        (list (foo2 x)))
  (define (foo0 x)
    (car (foo1 x)))

  (+ 1 (foo0 3))

In the normal language level, we get an error, and red arrows that show
us how where in the computation the error was raised.  The arrows are
all expected, except that `foo2' is not in the path -- why is that?
Remember the discussion about tail-calls and how they are important in
Scheme since they are the only tool to generate loops?  This is what
we're seeing here: `foo2' calls `foo3' in a tail position, so there is
no need to keep the `foo2' context anymore -- it is simply replaced by
`foo3'.  Now switch to Lazy Scheme and re-run -- you'll see a single
arrow, skipping over everything and going straight to the erroneous
expression.  What's the problem?  The call of `foo0' creates a promise
that is forced in the top-level expression, that simply returns the
`car' of the `list' that `foo1' created -- and all of that can be done
without forcing the `foo2' call.  Going this way, the computation is
finally running into an error *after* the calls to `foo0', `foo1', and
`foo2' are done -- so we get the seemingly out-of-context error.

Finally, there are also potential problems when you're not careful about
memory use.  A common technique when using a lazy language is to
generate an infinite list and pull out the Nth element.  For example, to
compute the Nth Fibonacci number, we can do this:

  (define (fib n)
    (letrec ([fibs (cons 1 (cons 1 (map + fibs (cdr fibs))))])
      (list-ref fibs n)))

but the problem here is that when `list-ref' is doing its way down the
list, it might still hold a reference to `fibs', which means that as the
list is forced, all intermediate values are held in memory.  Of course
it might be the case that our language implementation is smart enough to
see that `fibs' is not really needed any more and release the offending
hold, but even if this is the case, tricky situations are hard to avoid.

========================================================================
>>> Lazy Evaluation: Shell Examples

There is a very simple and elegant principle in shell programming -- we
get a single data type, a character stream, and many small functions,
each doing a single simple job.  With these small building blocks, we
can construct more sequences that achieve more complex tasks, for
example -- a sorted frequency table of lines in a file:

  sort foo | uniq -c | sort -nr

This is very much like a programming language -- we get small blocks,
and build stuff out of them.  Of course there are swiss army knives like
awk that try to do a whole bunch of stuff, (the same attitude that
brought Perl to the world...) and even these respect the "stream" data
type.  For example, a simple "{ print $1 }" statement will work over all
lines, one by one, making it a program over an infinite input stream,
which is what happens in reality in something like:

  cat /dev/console | awk ...

But there is something else in shell programming that makes so
effective: it is implementing a sort of a lazy evaluation.  For example,
compare this:

  cat foo | awk '{ print $1+$2; }' | uniq

to:

  cat foo | awk '{ print $1+$2; }' | uniq | head -5

Each element in the pipe is doing its own small job, and it is always
doing just enough to feed its output.  Each basic block is designed to
work even on infinite inputs!  (Even sort works on unlimited inputs...)
(Soon we will see a stronger connection with lazy evaluation.)

As an aside: (Alan Perlis) "It is better to have 100 functions operate
on one data structure than 10 functions on 10 data structures"...  But
the uniformity comes at a price: the biggest problem shells have is in
their lack of a recursive structure, contaminating the world with way
too many hacked up solutions.  More than that, it is extremely
inefficient and usually leads to data being re-parsed over and over and
over -- each small Unix command needs to always output stuff that is
human readable, but the next command in the pipe will need to re-parse
that, eg, rereading decimal numbers.  If you look at pipelines as
composing functions, then a pipe of numeric commands translates to
something like:

  itoa(baz(atoi(itoa(bar(atoi(itoa(foo(atoi(inp)))))))))

and it is impossible to get rid of the redundant "atoi(itoa(...))"s.

========================================================================
>>> Lazy Evaluation: Programming Examples

We already know that when we use lazy evaluation, we are guaranteed to
have more robust programs.  For example, a function like:

  (define (my-if x y z)
    (if x y z))

is completely useless in Scheme because all functions are eager, but in
a lazy language, it would behave exactly like the real if.  Note that we
still need *some* primitive conditional, but this primitive can be a
procedure (and it is, in Lazy Scheme).

But we get more than that.  If we have a lazy language, then
*computations* are pushed around as if they were values (computations,
because these are expressions that are yet to be evaluated).  In fact,
there is no distinction between computations and values, it just happens
that some values contain "computational promises", things that will do
something in the future.

To see how this happens, we write a simple program to compute the
(infinite) list of prime numbers using the sieve of Eratosthenes.  To do
this, we begin by defining the list of all natural numbers:

  (define nats (cons 1 (map add1 nats)))

And now define a `sift' function: it receives an integer `n' and an
infinite list of integers `l', and returns a list without the numbers
that can be divided by `n'.  This is simple to write using `filter':

  (define (sift n l)
    (filter (lambda (x) (not (divides? n x))) l))

and it requires a definition for `divides?' -- we use Scheme's `modulo'
for this:

  (define (divides? n m)
    (zero? (modulo m n)))

Now, a `sieve' is a function that consumes a list that begins with a
prime number, and returns the prime numbers from this list.  To do this,
it returns a list that has the same first number, and for its tail it
sifts out numbers that are divisible by the first from the original
list's tail, and calls itself recursively on the result:

  (define (sieve l)
    (cons (car l) (sieve (sift (car l) (cdr l)))))

Finally, the list of prime numbers is the result of applying `sieve' on
the list of numbers from 2.  The whole program is now:

  ----------------------------------------------------------------------
  (define nats (cons 1 (map add1 nats)))
  (define (divides? n m)
    (zero? (modulo m n)))
  (define (sift n l)
    (filter (lambda (x) (not (divides? n x))) l))
  (define (sieve l)
    (cons (car l) (sieve (sift (car l) (cdr l)))))
  (define primes (sieve (cdr nats)))
  ----------------------------------------------------------------------

To see how this runs, we trace `modulo' to see which tests are being
used.  The effect of this is that each time `divides?' is actually
required to return a value, we will see a line with its inputs, and its
output.  This output looks quite tricky -- things are computed only on a
"need to know" basis, meaning that debugging lazy programs can be
difficult, since things happen when they are needed which takes time to
get used to.  However, note that the program actually performs the same
tests that you'd do using any eager-language implementation of the sieve
of Eratosthenes, and the advantage is that we don't need to decide in
advance how many values we want to compute -- all values will be
computed when you want to see the corresponding result.  Implementing
*this* behavior in an eager language is more difficult than a simple
program, yet we don't need such complex code when we use lazy
evaluation.

Note that if we trace `divides?' we see results that are some promise
struct -- these are unevaluated expressions, and they point at the fact
that when `divides?' is used, it doesn't really force its arguments --
this happens later when these results are forced.

The analogy with shell programming using pipes should be clear now --
for example, we have seen this:

  cat foo | awk '{ print $1+$2; }' | uniq | head -5

The last `head -5' means that no computation is done on parts of the
original file that are not needed.  It is similar to a `(take 5 l)'
expression in Lazy Scheme.

========================================================================
>>> Call by Need vs Call by Name

Finally, note that on requiring different parts of the `primes', the
same calls are not repeated.  This indicates that our language
implements "call by need" rather than "call by name": once an expression
is forced, its value is remembered, so subsequent usages of this value
do not require further computations.

Using "call by name" means that we actually use expressions which can
lead to confusing code.  An old programming language that used this is
Algol.  A confusing example that demonstrates this evaluation strategy
is:

  ----------------------------------------------------------------------
  begin
    integer procedure SIGMA(x, i, n);
      value n;
      integer x, i, n;
    begin
      integer sum;
      sum:=0;
      for i:=1 step 1 until n do
          sum:=sum+x;
      SIGMA:=sum;
    end;
    integer q;
    printnln(SIGMA(q*2-1, q, 7));
  end
  ----------------------------------------------------------------------

`x' and `i' are arguments that are passed by name, which means that they
can use the same memory location.  This is called "aliasing", a problem
that happens when pointers are involved (eg, pointers in C and
`reference' arguments in C++).

========================================================================
>>> Example of Feature Embedding

Another interesting behavior that we can now observe, is that the TOY
evaluation rule for `with':

  eval({with {x E1} E2}) = eval(E2[eval(E1)/x])

is specifying an eager evaluator *only if* the language that this rule
is written in is itself eager.  Indeed, if we run the TOY interpreter in
Lazy Scheme (or other interpreters we have implemented), we can verify
that running:

  (run "{bind {{x {/ 1 0}}} 1}")

is perfectly fine -- the call to Scheme's division is done in the
evaluation of the TOY division expression, but since Lazy Scheme is
lazy, then if this value is never used then we never get to do this
division!  On the other hand, if we evaluate

  (run "{bind {{x {/ 1 0}}} {+ x 1}}")

we do get an error when DrScheme tries to display the result, which
forces strictness.  Note how the arrows in DrScheme that show where the
computation is are quite confusing: the computation seem to go directly
to the point of the arithmetic operations (arith-op) since the rest of
the evaluation that the evaluator performed was already done, and
succeeded.  The actual failure happens when we try to force the
resulting promise which contains only the strict points in our code.

========================================================================
>>> Implementing Laziness (in normal Scheme)

Generally, we know how lazy evaluation work when we use the substitution
model.  We even know that if we have:

  {bind {{x y}}
    {bind {{y 2}}
      {+ x y}}}

then the result should be an error because we cannot substitute the `y'
expression in because it will capture the `y' -- changing the binding
structure.  As an indication, the original expression contains a free
reference to `y', which is exactly why we shouldn't substitute it.  But
what about:

  {bind {{x {+ 4 5}}}
    {bind {{y {+ x x}}}
      {bind {{z y}}
        {bind {{x 4}}
          z}}}}

Evaluating this eagerly returns 18, we therefore expect any other
evaluation (eager or lazy, using substitutions or environments) to
return 18, because any of these options should not change the meaning of
numbers, of addition, *or* of the scoping rules.  For example, try using
lazy evaluation with substitutions:

  {bind {{x {+ 4 5}}}
    {bind {{y {+ x x}}}
      {bind {{z y}}
        {bind {{x 4}}
          z}}}}
  -->
  {bind {{y {+ {+ 4 5} {+ 4 5}}}}
    {bind {{z y}}
      {bind {{x 4}}
        z}}}
  -->
  {bind {{z {+ {+ 4 5} {+ 4 5}}}}
    {bind {{x 4}}
      z}}
  -->
  {bind {{x 4}}
    {+ {+ 4 5} {+ 4 5}}}
  -->
  {+ {+ 4 5} {+ 4 5}}
  -->
  {+ 9 9}
  -->
  18

And what about lazy evaluation using environments:

  {bind {{x {+ 4 5}}}
    {bind {{y {+ x x}}}
      {bind {{z y}}
        {bind {{x 4}}
          z}}}}
  -->
  {bind {{y {+ x x}}}
    {bind {{z y}}
      {bind {{x 4}}
        z}}}            [x:={+ 4 5}]
  -->
  {bind {{z y}}
    {bind {{x 4}}
      z}}               [x:={+ 4 5}, y:={+ x x}]
  -->
  {bind {{x 4}}
    z}                  [x:={+ 4 5}, y:={+ x x}, z:=y]
  -->
  z                     [x:=4, y:={+ x x}, z:=y]
  -->
  y                     [x:=4, y:={+ x x}, z:=y]
  -->
  {+ x x}               [x:=4, y:={+ x x}, z:=y]
  -->
  {+ 4 4}               [x:=4, y:={+ x x}, z:=y]
  -->
  8                     [x:=4, y:={+ x x}, z:=y]

We have a problem!  This problem should be familiar now, it is very
similar to the problem that led us down the mistaken path of dynamic
scoping when we tried to have first-class functions.  In both cases,
substitution always worked, and it looks like in both cases the problem
is that we don't remember the environment of an expression: in the case
of functions, it is the environment at the time of creating the closure
that we want to capture and use when we go back later to evaluate the
body of the function.  Here we have a similar situation, except that we
don't need a function to defer computation: *most* expressions get
evaluated at some time in the future, so every time we defer such a
computation we need to remember the lexical environment of the
expression.

This is the major point that will make things work again: every
expression creates something like a closure -- an object that closes
over an expression and an environment at the (lexical) place where that
expression was used, and when we actually want to evaluate it later, we
need to do it in the right lexical context.  So it is like a closure
except it doesn't need to be applied, and there are no arguments.  In
fact it is also a form of a closure -- instead of closing over a
function body and an environment, it closes over any expression and an
environment.  (As we shall see, lazy evaluation is tightly related to
using nullary functions: "thunks".)

========================================================================
>>> Sloth

So we implement this by creating such `closure' values for all
expressions that are not evaluated right now.  We begin with the Toy
language, and properly rename it to "Sloth".  We then add one more case
to the data type of values which implements the new kind of expression
closures:

  (define-type VAL
    [ScmV  (x any?)]
    [FunV  (names unique-names?) (body SLOTH?) (env ENV?)]
    [ExprV (expr SLOTH?) (env ENV?)] ;* new
    [PrimV (prim procedure?)])

Where should we use the new `ExprV'?  -- At any place where we want to
be lazy and defer evaluating an expression for later.  For example, the
code that handles a Bind:

  [(Bind names exprs bound-body)
   (eval bound-body
         (extend names
                 (map (lambda (e) (eval e env)) exprs)
                 env))]

should be changed to:

  [(Bind names exprs bound-body)
   (eval bound-body
         (extend names
                 (map (lambda (e) (ExprV e env)) exprs) ; eval -> ExprV
                 env))]

and note the simple change -- instead of an `eval' function call, we
create a value that contains the parts that would have been used in the
`eval' function call.  This value serves as a promise to do this
evaluation (the `eval' call) later, if needed.  (This is exactly why a
Lazy Scheme would make this a lazy evaluator: all function calls are
promises.)  Now, given this, we expect that evaluating:

  {bind {{x 1}} x}

will return something like:

  (ExprV (Num 1) ...the-global-environment...)

Another place where we add laziness is, obviously, function calls.  The
code that does that:

  [(Call fun-expr arg-exprs)
   (let ([fval (eval fun-expr env)]
         [arg-vals (map (lambda (e) (eval e env)) arg-exprs)])
     (cases fval
       [(PrimV proc) (proc arg-vals)]
       [(FunV names body fun-env)
        (eval body (extend names arg-vals fun-env))]
       [else (error 'eval "function call with a non-function: ~s"
                    fval)]))]

is modified in a similar way:

  [(Call fun-expr arg-exprs)
   (let ([fval (eval fun-expr env)]
         [arg-vals (map (lambda (e) (ExprV e env)) ; eval -> ExprV
                        arg-exprs)])
     (cases fval
       [(PrimV proc) (proc arg-vals)]
       [(FunV names body fun-env)
        (eval body (extend names arg-vals fun-env))]
       [else (error 'eval "function call with a non-function: ~s"
                    fval)]))]

But what about an expression like this one?

  {bind {{x 2}}
    {+ x x}}

Using what we have so far, this will be some (Call ...) syntax, but the
values that will be passed to the primitive `+' operation will be ExprV
promises.

What we really want is to actually add two *values*, not promises.  So
maybe distinguish the two applications -- treat PrimV differently from
FunV closures?

  [(Call fun-expr arg-exprs)
   (let ([fval (eval fun-expr env)])
     (cases fval
       [(PrimV proc)
        (proc (map (lambda (e) (eval e env))         ;* eval here
                   arg-exprs))]
       [(FunV names body fun-env)
        (eval body
             (extend names
                     (map (lambda (e) (ExprV e env)) ;* promise here
                          arg-exprs)
                     fun-env))]
       [else (error 'eval "function call with a non-function: ~s"
                    fval)]))]

This still doesn't work -- the problem is that the function now gets a
bunch of values, and some of these are `ExprV's...  Another way to see
this problem is to consider the code for evaluating an `If' conditional
expression:

  [(If cond-expr then-expr else-expr)
   (eval (if (cases (eval cond-expr env)
               [(ScmV v) v] ; Scheme value => use as boolean
               [else #t])   ; other values are always true
           then-expr
           else-expr)
         env)]

We need to take care of a possible ExprV here.  What should we do?
Obviously:

  [(If cond-expr then-expr else-expr)
   (eval (if (cases (eval cond-expr env)
               [(ScmV v) v] ; Scheme value => use as boolean
               [(ExprV expr env) (eval expr env)]
               [else #t])   ; other values are always true
           then-expr
           else-expr)
         env)]

Note how this translates back the data structure that represents an
`eval' promise back into a real `eval' call...

Going back to our code for `Call', there is a problem with it -- the

  (lambda (e) (eval e env))

will indeed evaluate the expression instead of lazily deferring this to
the future, but this evaluation might itself return such lazy values.
So we go and inspect that value again, forcing the promise if needed:

  [(Call fun-expr arg-exprs)
   (let ([fval (eval fun-expr env)])
     (cases fval
       [(PrimV proc)
        (proc (map (lambda (e)
                     (let ([v (eval e env)]) ;* eval here
                       (cases v
                         [(ExprV expr env) (eval expr env)]
                         [else v])))
                   arg-exprs))]
       [(FunV names body fun-env)
        (eval body
             (extend names
                     (map (lambda (e) (ExprV e env)) ;* promise here
                          arg-exprs)
                     fun-env))]
       [else (error 'eval "function call with a non-function: ~s"
                    fval)]))]

But we *still* have a problem -- as can be seen from our test cases,
when we try to run this:

  {bind {{add3 {fun {x} {+ x 3}}}}
    {bind {{add1 {fun {x} {+ x 1}}}}
      {bind {{x 3}}
        {add1 {add3 x}}}}}

we run into a problem -- the `(eval fun-expr env)' might also return an
ExprV.  So we need to do the whole thing all over again...  And more:
what if ExprV represents an `eval' call which itself return a promise
that should be forced again?

A better solution is to add a function that will do all that:

  ;; strict : VAL -> VAL which is not an ExprV
  ;; forces a (possibly nested) ExprV promise
  (define (strict v)
    (cases v
      [(ExprV expr env) (strict (eval expr env))]
      [else v]))

Note the recursive call: we can never be sure that `eval' didn't return
an ExprV promise, so we have to keep trying until we get a "real" value.
Now we can change the function call to something more manageable:

  [(Call fun-expr arg-exprs)
   (let ([fval (strict (eval fun-expr env))]       ;* strict!
         [arg-vals (map (lambda (e) (ExprV e env)) arg-exprs)])
     (cases fval
       [(PrimV proc) (proc (map strict arg-vals))] ;* strict!
       [(FunV names body fun-env)
        (eval body (extend names arg-vals fun-env))]
       [else (error 'eval "function call with a non-function: ~s"
                    fval)]))]

And the `If' case is similar (note that it doesn't matter if `strict' is
used with the result of `eval' or `ExprV'):

  [(If cond-expr then-expr else-expr)
   (eval (if (cases (strict (eval cond-expr env)) ;*
               [(ScmV v) v] ; Scheme value => use as boolean
               [else #t])   ; other values are always true
           then-expr
           else-expr)
         env)]

========================================================================
>>> Implementing Evaluation

Using `strict' is sufficient for us to implement lazy evaluation
properly.  All we need to do is to identify places in our program that
need to be lazy (simply call `eval') and places that need to be eager
(use `strict').  For example, the `run' function should now be:

  ;; run : string -> any
  ;; evaluate a SLOTH program contained in a string
  (define (run str)
    (let ([result (strict (eval (parse str) global-environment))]) ;*
      (cases result
        [(ScmV v) v]
        [else (error 'run
                     "evaluation returned a bad value: ~s" result)])))

and for the primitive functions, we need to add another flag that says
whether they are strict (most of them) or not (constructors) -- and
according to this flag, we use `strict' for the arguments:

  ;; scheme-func->prim-val : (any ... -> any) bool -> SLOTH-val
  ;; converts a scheme function to a primitive evaluator function which
  ;; is a PrimV holding a ((list-of SLOTH-val) -> SLOTH-val) procedure.
  ;; (the result procedure doesn't check for types and arity.)
  (define (scheme-func->prim-val scheme-func strict?)
    (PrimV (lambda (args)
             (let ([args (if strict?
                           (map (lambda (a)
                                  (let ([v (strict a)])
                                    (cases v
                                      [(ScmV x) x]
                                      [else (error 'scheme-func
                                                   "bad input: ~s"
                                                   a)])))
                                args)
                           args)])  ;* use values as is!
               (ScmV (apply scheme-func args))))))

And now we can add a few "interesting" primitives:

  ;; The global environment has a few primitives:
  (define global-environment
    (FrameEnv (list (list '+ (scheme-func->prim-val + #t))
                    (list '- (scheme-func->prim-val - #t))
                    (list '* (scheme-func->prim-val * #t))
                    (list '/ (scheme-func->prim-val / #t))
                    (list '< (scheme-func->prim-val < #t))
                    (list '> (scheme-func->prim-val > #t))
                    (list '= (scheme-func->prim-val = #t))
                    ;; note flags:
                    (list 'cons  (scheme-func->prim-val cons  #f))
                    (list 'list  (scheme-func->prim-val list  #f))
                    (list 'car   (scheme-func->prim-val car   #t))
                    (list 'cdr   (scheme-func->prim-val cdr   #t))
                    (list 'null? (scheme-func->prim-val null? #t))
                    ;; values
                    (list 'true  (ScmV #t))
                    (list 'false (ScmV #f))
                    (list 'null  (ScmV null)))
              (EmptyEnv)))

And now the code for dealing with primitive function calls is almost as
simple as it was in the beginning:

  [(Call fun-expr arg-exprs)
   (let ([fval (strict (eval fun-expr env))]
         [arg-vals (map (lambda (e) (ExprV e env)) arg-exprs)])
     (cases fval
       [(PrimV proc) (proc arg-vals)]
       [(FunV names body fun-env)
        (eval body (extend names arg-vals fun-env))]
       [else (error 'eval "function call with a non-function: ~s"
                    fval)]))]

Note that this last change raises a subtle type issue: before the
change, the `cons' function in the Sloth language would get two VAL
objects, and convert them to Scheme values, so the wrapped Scheme `cons'
is actually used with real Scheme values.  But now this does not happen
-- if we want actual Scheme values, then we'd have to use `strict'
first, which is exactly what we want to avoid with `cons'.  Instead, the
Scheme cons will be used with two ExprV values, which will raise an
error if we try running this program:

  {bind {{x {/ 1 0}}} {car {cons 1 null}}}

We therefore need to use the *real* Scheme cons which has no
restrictions.  There is no way, currently, for us to determine which
usage of `cons' is safe (we have already seen a similar effect in Lazy
Scheme's unrestricted cons).  The unrestricted `cons' is available in
our language as `cons*':

  (define global-environment
    (FrameEnv (list ...
                    (list 'cons  (scheme-func->prim-val cons* #f)) ;!
                    ...)
              (EmptyEnv)))

But we still need to consider the effects of this: the above shows a
problem when we use a `car' -- it will be applied on a cons cell holding
two evaluation promises, and return the first one -- in a `ScmV'
wrapper, which is wrong!  A solution to this is to make our `car' and
`cdr' functions return a value without wrapping it -- we can identify
this situation by the fact that the returned value is a VAL instead of
some other Scheme value:

  ;; scheme-func->prim-val : (any ... -> any) bool -> SLOTH-val
  ;; converts a scheme function to a primitive evaluator function which
  ;; is a PrimV holding a ((list-of SLOTH-val) -> SLOTH-val) procedure.
  ;; (the result procedure doesn't check for types and arity.)
  (define (scheme-func->prim-val scheme-func strict?)
    (PrimV (lambda (args)
             (let* ([args (if strict?
                            (map (lambda (a)
                                   (let ([v (strict a)])
                                     (cases v
                                       [(ScmV x) x]
                                       [else (error 'scheme-func
                                                    "bad input: ~s"
                                                    a)])))
                                 args)
                            args)]
                    [result (apply scheme-func args)])
               ;; Because there are non-strict constructors, primitives
               ;; like `car' might be returning promises which are
               ;; already VAL objects.
               (if (VAL? result) result (ScmV result))))))

Complete Sloth code follows.  (Also available as "sloth.scm" on the
website.)  It can be used to do the same fun things we did with Lazy
Scheme.

  ----------------------------------------------------------------------
  ;;; ==================================================================
  ;;; Syntax

  #| The BNF:
     <SLOTH> ::= <num>
               | <id>
               | { bind {{ <id> <SLOTH> } ... } <SLOTH> }
               | { fun { <id> ... } <SLOTH> }
               | { if <SLOTH> <SLOTH> <SLOTH> }
               | { <SLOTH> <SLOTH> ... }
  |#

  ;; A matching abstract syntax tree datatype:
  (define-type SLOTH
    [Num  (n number?)]
    [Id   (name symbol?)]
    [Bind (names unique-names?) (exprs (list-of SLOTH?)) (body SLOTH?)]
    [Fun  (names unique-names?) (body SLOTH?)]
    [Call (fun-expr SLOTH?) (arg-exprs (list-of SLOTH?))]
    [If   (cond-expr SLOTH?) (then-expr SLOTH?) (else-expr SLOTH?)])

  ;; unique-list? : list -> bool
  ;; Tests whether a list is unique, used to make `unique-names?' below.
  (define (unique-list? xs)
    (or (null? xs)
        (and (not (member (first xs) (rest xs)))
             (unique-list? (rest xs)))))

  ;; unique-names? : any -> bool
  ;; A predicate that is used to specify a type of unique symbol lists.
  (define unique-names?
    (intersection-of (list-of symbol?) unique-list?))

  ;; parse-sexpr : s-expr -> SLOTH
  ;; to convert s-expressions into SLOTHs
  (define (parse-sexpr sexpr)
    (match sexpr
      [(number: n)    (Num n)]
      [(symbol: name) (Id name)]
      [(cons 'bind more)
       (match sexpr
         [(list 'bind (list (list (symbol: names) nameds) ...) body)
          (Bind names (map parse-sexpr nameds) (parse-sexpr body))]
         [else (error 'parse-sexpr "bad `bind' syntax in ~s" sexpr)])]
      [(cons 'fun more)
       (match sexpr
         [(list 'fun (list (symbol: names) ...) body)
          (Fun names (parse-sexpr body))]
         [else (error 'parse-sexpr "bad `fun' syntax in ~s" sexpr)])]
      [(cons 'if more)
       (match sexpr
         [(list 'if cond then else)
          (If (parse-sexpr cond) (parse-sexpr then) (parse-sexpr else))]
         [else (error 'parse-sexpr "bad `if' syntax in ~s" sexpr)])]
      [(list fun args ...) ; other lists are applications
       (Call (parse-sexpr fun)
             (map parse-sexpr args))]
      [else (error 'parse-sexpr "bad syntax in ~s" sexpr)]))

  ;; parse : string -> SLOTH
  ;; Parses a string containing an SLOTH expression to a SLOTH AST.
  (define (parse str)
    (parse-sexpr (string->sexpr str)))

  ;;; ==================================================================
  ;;; Values and environments

  (define-type ENV
    [EmptyEnv]
    [FrameEnv (frame frame?) (rest ENV?)])

  (define-type VAL
    [ScmV  (x any?)]
    [FunV  (names unique-names?) (body SLOTH?) (env ENV?)]
    [ExprV (expr SLOTH?) (env ENV?)]
    [PrimV (prim procedure?)])

  ;; a frame is an association list of names and values.
  (define frame?
    (list-of (lambda (x)
               (and (list? x)
                    (= 2 (length x))
                    (symbol? (first x))
                    (VAL? (second x))))))

  ;; extend : (list-of symbol) (list-of VAL) ENV -> ENV
  ;; extends an environment with a new frame.
  (define (extend names values env)
    (if (= (length names) (length values))
      (FrameEnv (map list names values) env)
      (error 'extend "arity mismatch for names: ~s" names)))

  ;; lookup : symbol ENV -> VAL
  ;; looks a name in an environment, searching through each frame.
  (define (lookup name env)
    (cases env
      [(EmptyEnv) (error 'lookup "no binding for ~s" name)]
      [(FrameEnv frame rest)
       (let ([cell (assq name frame)])
         (if cell
           (second cell)
           (lookup name rest)))]))

  ;; scheme-func->prim-val : (any ... -> any) bool -> SLOTH-val
  ;; converts a scheme function to a primitive evaluator function which
  ;; is a PrimV holding a ((list-of SLOTH-val) -> SLOTH-val) procedure.
  ;; (the result procedure doesn't check for types and arity.)
  (define (scheme-func->prim-val scheme-func strict?)
    (PrimV (lambda (args)
             (let* ([args (if strict?
                            (map (lambda (a)
                                   (let ([v (strict a)])
                                     (cases v
                                       [(ScmV x) x]
                                       [else (error 'scheme-func
                                                    "bad input: ~s"
                                                    a)])))
                                 args)
                            args)]
                    [result (apply scheme-func args)])
               ;; Because there are non-strict constructors, primitives
               ;; like `car' might be returning promises which are
               ;; already VAL objects.
               (if (VAL? result) result (ScmV result))))))

  ;; The global environment has a few primitives:
  (define global-environment
    (FrameEnv (list (list '+ (scheme-func->prim-val + #t))
                    (list '- (scheme-func->prim-val - #t))
                    (list '* (scheme-func->prim-val * #t))
                    (list '/ (scheme-func->prim-val / #t))
                    (list '< (scheme-func->prim-val < #t))
                    (list '> (scheme-func->prim-val > #t))
                    (list '= (scheme-func->prim-val = #t))
                    ;; note flags:
                    (list 'cons  (scheme-func->prim-val cons* #f)) ;!
                    (list 'list  (scheme-func->prim-val list  #f))
                    (list 'car   (scheme-func->prim-val car   #t))
                    (list 'cdr   (scheme-func->prim-val cdr   #t))
                    (list 'null? (scheme-func->prim-val null? #f))
                    ;; values
                    (list 'true  (ScmV #t))
                    (list 'false (ScmV #f))
                    (list 'null  (ScmV null)))
              (EmptyEnv)))

  ;;; ==================================================================
  ;;; Evaluation

  ;; strict : VAL -> VAL which is not an ExprV
  ;; forces a (possibly nested) ExprV promise
  (define (strict v)
    (cases v
      [(ExprV expr env) (strict (eval expr env))]
      [else v]))

  ;; eval : SLOTH env -> VAL
  ;; evaluates SLOTH expressions.
  (define (eval expr env)
    (cases expr
      [(Num n) (ScmV n)]
      [(Id name) (lookup name env)]
      [(Bind names exprs bound-body)
       (eval bound-body
             (extend names
                     (map (lambda (e) (ExprV e env)) exprs)
                     env))]
      [(Fun names bound-body)
       (FunV names bound-body env)]
      [(Call fun-expr arg-exprs)
       (let ([fval (strict (eval fun-expr env))]
             [arg-vals (map (lambda (e) (ExprV e env)) arg-exprs)])
         (cases fval
           [(PrimV proc) (proc arg-vals)]
           [(FunV names body fun-env)
            (eval body (extend names arg-vals fun-env))]
           [else (error 'eval "function call with a non-function: ~s"
                        fval)]))]
      [(If cond-expr then-expr else-expr)
       (eval (if (cases (strict (eval cond-expr env))
                   [(ScmV v) v] ; Scheme value => use as boolean
                   [else #t])   ; other values are always true
               then-expr
               else-expr)
             env)]))

  ;; run : string -> any
  ;; evaluate a SLOTH program contained in a string
  (define (run str)
    (let ([result (strict (eval (parse str) global-environment))])
      (cases result
        [(ScmV v) v]
        [else (error 'run
                     "evaluation returned a bad value: ~s" result)])))

  ;;; ==================================================================
  ;;; Tests

  (test (run "{{fun {x} {+ x 1}} 4}")
        => 5)
  (test (run "{bind {{add3 {fun {x} {+ x 3}}}} {add3 1}}")
        => 4)
  (test (run "{bind {{add3 {fun {x} {+ x 3}}}
                     {add1 {fun {x} {+ x 1}}}}
                {bind {{x 3}} {add1 {add3 x}}}}")
        => 7)
  (test (run "{bind {{identity {fun {x} x}}
                     {foo {fun {x} {+ x 1}}}}
                {{identity foo} 123}}")
        => 124)
  (test (run "{bind {{x 3}}
                {bind {{f {fun {y} {+ x y}}}}
                  {bind {{x 5}}
                    {f 4}}}}")
        => 7)
  (test (run "{{{fun {x} {x 1}}
                {fun {x} {fun {y} {+ x y}}}}
               123}")
        => 124)

  ;; test laziness
  (test (run "{bind {{x {/ 1 0}}} {car {cons 1 null}}}")
        => 1)

  ;;; ==================================================================
  ----------------------------------------------------------------------

========================================================================
>>> Lazy Evaluation: Implementing Call by Need

Caching computation results

As we have seen, there are a number of advantages for lazy evaluation,
but its main disadvantage is the fact that it is extremely inefficient,
to the point of rendering lots of programs impractical, for example, in:

  {bind {{x {+ 4 5}}}
    {bind {{y {+ x x}}}
      y}}

we end up adding 4 and 5 twice.  We can gain some efficiency by caching
evaluation results, using a box that will be used to remember the
results.  The box will initially hold #f, and it will change to hold the
VAL that results from evaluation:

  (define-type VAL
    [ScmV  (x any?)]
    [FunV  (names unique-names?) (body SLOTH?) (env ENV?)]
    [ExprV (expr SLOTH?)
           (env ENV?)
           (cache (box-of (union-of false? VAL?)))]
    [PrimV (prim procedure?)])

we now use this function to create an evaluation promise, because when
an ExprV is created, its initial cache box needs an initial value:

  ;; eval-promise : SLOTH env -> VAL (the ExprV variant)
  ;; used instead of `eval' to create an evaluation promise
  (define (eval-promise expr env)
    (ExprV expr env (box #f)))

This `eval-promise' is used instead of `ExprV' in eval.  Finally,
whenever we force such an ExprV promise, we check if it was already
evaluated, and force it if not (remembering the result).  This is simple
to do since there is a single place where this is done:

  ;; strict : VAL -> VAL which is not an ExprV
  ;; forces a (possibly nested) ExprV promise
  (define (strict v)
    (cases v
      [(ExprV expr env cache)
       (or (unbox cache)
           (let ([val (strict (eval expr env))])
             (set-box! cache val)
             val))]
      [else v]))

But note that it is becoming problematic to mix side-effects with our
lazy evaluator in a sane way.  (This was true with call-by-name too, it
just got even more confusing now.)

========================================================================
>>> Side Effects in a Lazy Language

We've seen that a lazy language without the call-by-need optimization is
too slow to be practical, but the optimization destroys any chance of
doing sane side-effects -- no I/O, no mutation, etc.  If we can't do
these things, the question is whether there is any point in using a
purely functional lazy language at all.

There is a solution for that: the language does not have any facilities
for *doing* things (like `printf' that prints something in plain
Scheme), but it can use a data structure that *describes* operations.
For example, in lazy Scheme we cannot print stuff sanely using `printf',
but we can construct a string using `format' -- this is just like
`printf', but instead of printing something, it constructs the string
that `printf' would have printed.  So, instead of:

  (define (foo n)
    (printf "~s + 1 = ~s\n" n (+ n 1)))

we write:

  (define (foo n)
    (format "~s + 1 = ~s\n" n (+ n 1)))

and get back a string.  We can now change the way that our interpreter
deals with the output value that it receives after evaluating a lazy
expression: if it receives a string, then it can take that string as
denoting a request for printout, and simply print it.  Such an evaluator
will do the printout when the lazy evaluation is done, and everything
works fine because we don't try to use any side-effects in the lazy
language -- we just talk about representations of side-effects.

But the way things are now are very limited -- we can only have a single
printout description as a result of a lazy computation.  We need a way
to chain several printouts.  For this, we define a new type, which will
have one variant named `Print' for a "printout request", and another
`Begin2' which will chain two requests together (each one can itself be
a chain):

  (define-type IO
    [Print  (str string?)]
    [Begin2 (l IO?) (r IO?)])

Now we can use this to chain any number of printout representations by
turning them into a single `Begin2' request, which is very similar to
simply using a loop to print the list.  For example, the eager printout
code:

  ;; print-list : (list-of A) -> void
  (define (print-list l)
    (if (null? l)
      (printf "\n")
      (begin (printf "~s " (car l))
             (print-list (cdr l)))))

turns to the following code:

  ;; print-list : (list-of A) -> IO
  (define (print-list l)
    (if (null? l)
      (Print "\n")
      (Begin2 (Print (format "~s " (car l)))
              (print-list (cdr l)))))

This will basically scan an input list like the eager version, but
instead of printing the list, it will convert it into a single output
request that forms a recipe for this printout.  Note that within the
lazy world, the result of `print-list' is just a value, there are no
side effects involved.  Turning this value into the actual printout is
something that needs to be done on the eager side, which must be part of
the implementation.  In the case of Lazy Scheme, we have no access to
the implementation, but we can do so in the Sloth implementation --
again, `run' will inspect the result and either print a given string (if
it gets a `Print' value), or print two things recursively (if it gets a
`Begin2' value).

This will also work for an infinite list: the result of `print-list'
will be an IO value that is an infinite tree.  The eager side (the `run'
part of the implementation) will receive this IO value that holds
promises, and in its processing loop it will force (using `strict') only
what it needs to print and go on recursively.  This will be the case for
any kind of an infinite IO loop, for example, the infinite printout loop

  (define (print-loop)
    (printf "foo\n")
    (print-loop))

is translated into a function that returns an infinite tree of print
operations:

  (define (print-loop)
    (Begin2 (Print "foo\n")
            (print-loop)))

and when this tree is converted to actions, it will result in an
infinite loop that produces the same output.

Finally, how would we deal with inputs?  We can add another variant to
our type definition that represents a `read-line' operation:

  (define-type IO
    [Print  (str string?)]
    [ReadLine]
    [Begin2 (l IO?) (r IO?)])

and the eager implementation can invoke `read-line' when it encounters
`ReadLine' values -- but what should it do with the resulting string?
The solution is to use a `receiver' procedure as part of the `ReadLine'
operation description:

  (define-type IO
    [Print    (str string?)]
    [ReadLine (receiver procedure?)] ; should be: string -> IO
    [Begin2   (l IO?) (r IO?)])

Now, when the eager side sees a `ReadLine' value, it will read a line,
and invoke the embedded procedure with the string that it has read.  By
doing this, the control goes back to the lazy world to process the value
and get back another IO value to continue the processing.  For example,
this silly loop:

  (define (silly-loop)
    (printf "What is your name? ")
    (let ([name (read-line)])
      (if (equal? name "quit")
        (printf "bye\n")
        (begin (printf "Your name is ~s\n" name)
               (silly-loop)))))

is translated to:

  (define (silly-loop)
    (Begin2 (Print "What is your name? ")
            (ReadLine
             (lambda (name)
               (if (equal? name "quit")
                 (Print "bye\n")
                 (Begin2 (Print (format "Your name is ~s\n" name))
                         (silly-loop)))))))

Using this strategy to implement side-effects is possible, and you will
do that in the homework -- some technical details are going to be
different but the principle is the same as discussed above.  The last
problem is that the above code is difficult to work with -- in the
homework you will see how to use syntactic abstractions to make it all
much easier to use.

========================================================================
>>> Designing DSLs

Programming languages differ in numerous ways:

1. Each uses different notations for writing down programs.  As we've
   observed, however, syntax is only partially interesting.  (This is,
   however, less true of languages that are trying to mirror the
   notation of a particular domain.)

2. Control constructs: for instance, early languages didn't even support
   recursion, while most modern languages still don't have
   continuations.

3. The kinds of data they support.  Indeed, sophisticated languages like
   Scheme blur the distinction between control and data by making
   fragments of control into data values (such as first-class functions
   and continuations).

4. The means of organizing programs: do they have functions, modules,
   classes, ...?

5. Automation such as memory management, run-time safety checks, and so
   on.

Each of these items suggests natural questions to ask when you design
your own languages in particular domains.

Now, you know (hopefully) what programming languages are used for.  One
example that should not be ignored is using a programming language to
write a programming language -- for example, what we did so far (or any
other interpreter or compiler).  In the same way that some series of
statements in a PL can be used to represent things to do in the "real
world", there are other statements that can be used to represent things
to do in your language.  For example, the meaning of `one-brick' might
abstract over laying a brick when making a wall -- it abstracts all the
little details into a function:

  (define (one-brick wall brick-pile)
    (move-eye (location brick-pile))
    (let ([pos (find-available-brick-position brick-pile)])
      (move-hand pos)
      (grab-object))
    (move-eye wall)
    (let ([pos (find-next-brick-position wall)])
      (move-hand pos)
      (drop-object)))

allows us to write

  (one-brick my-wall my-brick-pile)

instead of all of the above, and and in the same way we can think of a
loop as an abstraction over the details of executing some sequence of
operations over and over again, for example this:

  (define (build-wall wall pile)
    (loop-for i from 1 to 500
      (one-brick wall pile)))

instead of:

  (one-brick my-wall my-pile)
  (one-brick my-wall my-pile)
  (one-brick my-wall my-pile)
  (one-brick my-wall my-pile)
  ...

Now going back to the different ways in which you can use a language:
there are lots of domain specific languages.  For example, four of the
oldest languages are:

  Fortran -- Formula Translator
  Algol   -- Algorithmic Language
  Cobol   -- Common Business Oriented Language
  Lisp    -- List Processing

Only in the late 60s / early 70s languages began to get free from their
special purpose domain and become "general purpose" languages (GPLs).
These days, we usually use some GPL for our programs and often come up
with small "domain specific" languages (DSLs) for specific jobs.  The
problem is designing such a specific language.  There are lots of
decisions to make, and as should be clear now, many ways of shooting
your self in the foot.  You need to know:

* What is your domain?

* What are the common notations in this domain (need to be convenient
  both for the machine and for humans)?

* What do you expect to get from your DSL?  (eg, performance gains when
  you know that you're dealing with a certain limited kind of
  functionality like arithmetics.)

* Do you have any semantic reason for a new language?  (For example,
  using special scoping rules, or a mixture of lazy and eager
  evaluation, maybe a completely different way of evaluation (eg,
  makefiles).)

* Is your language expected to envelope other functionality (eg, shell
  scripts, TCL), perhaps throwing some functionality on a different
  language (makefiles and shell scripts), or is it going to be embedded
  in a bigger application (eg, PHP), or embedded in a way that exposes
  parts of an application to user automation (Emacs Lisp, Word Basic).

* If you have one language embedded in another enveloping language --
  how do you handle syntax?  How can they communicate (eg, share
  variables)?

And very important:

* Is there a benefit for implementing a DSL over using a GPL -- how much
  will your DSL grow (usually more than you think)?  Will it get to a
  point where it will need the power of a full GPL?  Do you want to risk
  doing this just to end up admitting that you need a "Real Language"
  and dump your solution for "Visual Basic for Applications"?
  => It might be useful to think ahead about things that you know you
     don't need, rather than things you need.

========================================================================
>>> WSJ on the proliferation of PLs:

  "Computer Languages Multiply, Pleasing Many--But Not All"
  Wall Street Journal (12/14/05) P. B1; Gomes, Lee

  While the proliferation of languages has been a boon to software
  programmers, the extensive variety often frustrates their bosses and
  confounds the larger software companies.  C and the subsequent C++ may
  be the most popular languages in use today, but any programmer working
  on the Web must also include languages such as Perl, Python, PHP, and
  TCL in his resume.  The explosion has been partially fueled by the
  ability of an individual programmer or a small group to create and
  market a language, as was the case with Ruby on Rails, which became an
  overnight sensation thanks to a 15-minute demonstration video the
  Danish programmer David Hansson circulated over the Web.  Once a
  language has gained a core following, blogs and Web sites appear to
  track its developments.  Many languages owe their origins to small
  design firms trying to make a commercial success of themselves, while
  others are labors of love, as is the case with many open source
  projects.  As new languages continue to emerge, however, more
  programmers are defecting from mainstream systems such as .NET and
  Java in favor of niche offerings that are more tailored to a specific
  project.  CIOs are often assailed by complaints from their programmers
  when they try to impose restrictions on the number of languages that
  are permissible.  While it has been demonstrated theoretically that
  each language is the rough equivalent of any other, it is no more
  likely for a consensus to appear within the programming community than
  it is for a single car to be met with a universal embrace from the
  entire fleet of motorists.

========================================================================
>>> Syntax Transformations: Macros

Macros are one of the biggest advantages of Scheme: this section is
therefore specific to Scheme (which has this unique feature).

As we have previously seen, it is possible to implement one language
construct using another.  What we did could be described as bits of a
compiler, since they translate one language to another.

We will see how this can be done *in* Scheme: implementing some new
linguistic forms in terms of ones that are already known.  In essence,
we will be translating Scheme constructs to other Scheme constructs --
and all that is done *in Scheme*, no need to go back to the language
Scheme was implemented in (C in our case).

This is possible with a simple "trick": the Scheme implementation uses
some syntax objects.  These are the objects that the implementor of
Scheme is using when implementing our Scheme.  But these objects are
also directly available for our use -- part of the implementation is
exposed to our level.  This is quite similar to the way we have
implemented pairs in our language -- a TOY or a SLOTH pair is
implemented using a Scheme pair, so the *same* data object is available
at both levels.

This is the big idea in Lisp, which Scheme inherited from (to some
extent): programs are made of numbers, strings, symbols and lists of
these -- and these are all used both at the meta-level as well as the
user level.  This means that instead of having no meta-language at all
(locking away a lot of useful stuff), and instead of having some
crippled half-baked meta language (CPP being both the most obvious (as
well as the most popular) example for such a meta language), instead of
all this we get exactly the same language at both levels.

How is this used?  Well, the principle is simple.  For example, say we
want to write a macro that will evaluate two forms in sequence, but if
the first one returns a result that is not false then it returns it
instead of evaluating the second one too.  This is exactly how `or'
behaves, so pretend we don't have it -- call our version `orelse':

  (orelse <expr1> <expr2>)

in effect, we add a new `special' form to our language, with its own
evaluation rule, only we know how to express this evaluation rule by
translating it to things that are already part of our language.

We could do this as a simple function -- only if we're willing to
explicitly delay the arguments with a `lambda', and use the thunks in
the function:

  (define (orelse thunk1 thunk2)
    (if (thunk1)
      (thunk1) ; ignore the double evaluation for now
      (thunk2)))

or:

  (define (orelse thunk1 thunk2)
    ((if (thunk1)
       thunk1
       thunk2)))

and using it like this:

  (orelse (lambda () 1) (lambda () (error "boom")))

But this is clearly not the right way to do this: whoever uses this code
must be aware of the need to send us thunks, and it's verbose and
inconvenient.

We want to translate (orelse <expr1> <expr2>) to:

  (if <expr1>
    <expr1>
    <expr2>)

If we look at the code as an s-expression, then we can write the
following function:

  (define (translate-orelse l)
    (if (and (list? l)
             (= 3 (length l))
             (eq? 'orelse (first l)))
      (list 'if (second l) (second l) (third l))
      (error 'translate-orelse "bad input: ~s")))

We can now try it with a simple list:

  (translate-orelse '(orelse foo1 foo2))

and note that the result is correct.

How is this used?  Well, all we need is to hook *our* function into our
implementation's evaluator.  In Lisp, we get a `defmacro' form for this,
and many Schemes inherited it or something similar.  In MzScheme, we
need to

  (require (lib "defmacro.ss"))

but it requires the transformation to be a little different in a way
that makes life easier: the above contains a lot of boilerplate code.
Usually, we will require the input to be a list of some known length,
the first element to be a symbol that specifies our form, and then do
something with the other arguments.  So we'd want to always follow a
template that looks like:

  (define (translate-??? exprs)
    (if (and (list? exprs)
             (= N (length exprs))
             (eq? '??? (car exprs)))
      (let ([E1 (cadr exprs)]
            [E2 (caddr exprs)]
            ...)
        ...make result expression...)
      (error ...)))

But this looks very similar to making sure that a function call is a
specific function call (and for a good reason -- macro usages look just
like function calls).  So make the translation function get a number of
arguments one each for each part of the input, an s-expression.  For
example, the above translation and test become:

  (define (translate-orelse <expr1> <expr2>)
    (list 'if <expr1> <expr1> <expr2>))

  (translate-orelse 'foo1 'foo2)

The number of arguments is used to check the input (turning an arity
error for the macro to an arity error for the translator function call),
and we don't need to caddr our way to arguments.

This gives us the simple definition -- but what about the promised hook?
-- All we need is to use `define-macro' instead of `define', and change
the name to the name that will trigger this translation (providing the
last missing test of the input):

  (define-macro (orelse <expr1> <expr2>)
    (list 'if <expr1> <expr1> <expr2>))

and test it:

  (orelse 1 (error "boom"))

Note that this is basically a (usually purely functional) lazy language
of transformations which is built on top of Scheme.  It is possible for
macros to generate pieces of code that contain references to these same
macros, and they will be used to expand those instances again.

Now we start with the problems, one by one.

========================================================================
>>> Careful with macros

There is an inherent problem when macros are being used, in any form and
any language (even in CPP): you must remember that you are playing with
*expressions*, not with values -- which is why this is problematic:

  (define (foo x) (printf "foo ~s!\n" x) x)

  (or (foo 1) (foo 2))

  (orelse (foo 1) (foo 2))

And the reason for this should be clear.  The standard solution for this
is to save the value as a binding -- so back to the drawing board, we
want this transformation instead:

  (orelse <expr1> <expr2>)
  -->
  (let ((v1 <expr1>))
    (if v1
      v1
      <expr2>))

(Note that we would have the same problem in the version that used
simple functions and thunks.)

And to write the new code:

  (define-macro (orelse <expr1> <expr2>)
    (list 'let (list (list 'v1 <expr1>))
      (list 'if 'v1
        'v1
        <expr2>)))

  (orelse (foo 1) (foo 2))

and this works like we want it to.

========================================================================
>>> Complexity of S-Expression Transformations

As can be seen, writing a simple macro doesn't look too good -- what if
we want to write a more complicated macro?  A solution to this is to
look at the above macro and realize that it *almost* looks like the code
we want -- we basically want to return a list of a certain fixed shape,
we just want some parts to be filled in by the given arguments.
Something like:

  (define-macro (orelse <expr1> <expr2>)
    '(let ((v1 <expr1>))
       (if v1
         v1
         <expr2>)))

if we had a way to make the <...>s not be a fixed part of the result,
but we actually want the values that the transformation procedure
received.  (Remember that the "<" and ">" are a simple part of the
variable name, no magic, just something that we can remember what the
substitution looks like.)  This is related to notational problems that
logicians and philosophers had problems with for decades (even
centuries), and Lisp adopts one of the solutions to this -- instead of a
quote, you use back-quote (called quasiquote in Scheme) which is almost
like quote, except that you can use an unquote inside, in the form of a
comma.  Using this, the code can be written like this:

  (define-macro (orelse <expr1> <expr2>)
    `(let ((v1 ,<expr1>))
       (if v1
         v1
         ,<expr2>)))

========================================================================
>>> Scoping Problems

You should be able to guess what's this problem about.  The basic
problem of these macro is that they cannot be used reliably.  For
example:

  (let ((v1 4))
    (orelse #f v1))

One way to solve this is to write macros that look like this:

  (define-macro (orelse <expr1> <expr2>)
    `(let ((%%!my*internal*var-do-not-use!%% ,<expr1>))
       (if %%!my*internal*var-do-not-use!%%
         %%!my*internal*var-do-not-use!%%
         ,<expr2>)))

or:

  (define-macro (orelse <expr1> <expr2>)
    `(let ((i-am-using-orelse-so-i-should-not-use-this-name ,<expr1>))
       (if i-am-using-orelse-so-i-should-not-use-this-name
         i-am-using-orelse-so-i-should-not-use-this-name
         ,<expr2>)))

Which is really not too good because such obscure variables tend to
clobber each other too, in all kinds of unexpected ways.

Another way is to have a procedure that gives you a different variable
name every time you call it:

  (define-macro (orelse <expr1> <expr2>)
    (let ((temp (gensym)))
      `(let ((,temp ,<expr1>))
         (if ,temp
           ,temp
           ,<expr2>))))

but this is not safe either.  Finally, the Lisp solution is to use
"uninterned" symbols -- symbols that have their own identity, much like
strings, and even if two have the same name, they are not `eq?'

Ignore this for now.

========================================================================

Another problem -- manageability of these transformations.

Quasiquotes gets us a long way, but it is still insufficient.

For example, lets write a Scheme `bind' that uses `lambda' for binding.
The transformation we now want is:

  (bind ((var expr) ...)
    body)
  -->
  ((lambda (var ...) body)
   expr ...)

The code for this looks like this:

  (define-macro (bind var-expr-list body)
    (cons (list 'lambda (map car var-expr-list) body)
          (map cadr var-expr-list)))

This already has a lot more pitfalls.  There are `list's and `cons's
that you should be careful of, there are `map's and there are `cadr's
that would be catastrophic if you use `car's instead.  The quasiquote
syntax is a little more capable -- you can write this:

  (define-macro (bind var-expr-list body)
    `((lambda ,(map car var-expr-list) ,body)
      ,@(map cadr var-expr-list)))

but this is still not as readable as the transformation you actually
want.

This is related to another problem -- after you expand macros, if you
have an error, how do you know where is it coming from?  Imagine this
scenario:

  > (define (foo x) (some-macro (list x)))
  > (foo 3)
  cdr: expects argument of type <pair>; given 0

Yes?  What now?

========================================================================
>>> The Scheme Solution

Scheme has a solution that is better than `defmacro': it has
`define-syntax' and `syntax-rules'.  First of all, `define-syntax' is
used to create the "shortcut" from user code into the implementation:

  (define-syntax foo
    ...)

will make `foo' be a special syntax object that when used in the head if
an expression, it will be applied on the expression, and whatever it
returns is used instead.

Next, `syntax-rules' is used to create such a transformation in an easy
way.  The thing that was noted is that all of these informal
specifications of transformations like:

  let can be defined as the following transformation:
    (let ((x v) ...) body ...)
    --> ((lambda (x ...) body ...) v ...)

and

  let* is defined as two cases:
  1. (let* () body ...)
     --> (let () body ...)
  2. (let* ((x1 v1) (x2 v2) ...) body ...)
     --> (let ((x1 v1)) (let* ((x2 v2) ...) body ...))

can actually be formalized in the form of a creating a syntax
transformation function.  (Note that I'm using round parens so we don't
fall into the illusion that brackets are different: the resulting
transformation would be the same.)  The main point is to view the left
hand side as a *pattern* that can match some forms of syntax, and the
right hand side as producing an output that can use some matched
patterns.  For example:

  (x y) --> (y x)

does the thing you expect it to do.  The rules for "..." are the ones
that make sense.  For example:

  (x ...)

indicate a sequence of zero or more expressions, and the `x' pattern
variable is matched to this whole sequence, and

  (x1 x2 ...)

indicates a sequence of one or more expressions, where `x1' is matched
to the first, and `x2' to the sequence of the second to the last.  A
little more complex:

  ((x y) ...)

matches a sequence of sequences of two elements each, and `x' is matched
to the sequence of the first elements and `y' to the seconds.  When
specifying the result, the ellipsis can be used on a pattern that
contains both `x' and `y', or separately on `x' and on `y' (but since
they are matched to a sequence, they must be used in the context of some
ellipsis).  For example:

  ((x y) ...) --> ((y x) ...)

or:

  ((x y) ...) --> ((x ...) (y ...))

both do the right thing.  (Obviously, these things can be nested.)

`syntax-rules' is used with a bunch of specifications of such
transformations, for example:

  (syntax-rules ()
    [((x y) ...) ((y x) ...)])

specifies the previous transformation (ignore the first "()" for now).
Such transformations can be used in a `define-syntax' expression to tie
the transformer knot back into the implementation.  You can now
appreciate how all this work when you see how easy it is to define
macros that are very tedious with `define-macro'.  For example:

  (define-syntax let
    (syntax-rules ()
      [(let ((x v) ...) body ...)
       ((lambda (x ...) body ...) v ...)]))

========================================================================

This is solving the problems of easy code -- no need for `list', `cons'
etc, not even for quasiquotes and tedious syntax massaging.  But there
were other problems.  First, there was a problem of bad scope, one that
was previously solved with a `gensym':

  (define-macro (orelse <expr1> <expr2>)
    (let ((temp (gensym)))
      `(let ((,temp ,<expr1>))
         (if ,temp ,temp ,<expr2>))))

Translating this to `define-syntax' and `syntax-rules' we get something
simpler:

  (define-syntax orelse
    (syntax-rules ()
      [(orelse <expr1> <expr2>)
       (let ((temp <expr1>))
         (if temp temp <expr2>))]))

And the main thing here is that Scheme takes care of the bindings:

  (let ((temp 4))
    (orelse #f temp))

works fine.  In fact, `define-syntax' fully respects scoping rules:
there is no confusion between bindings that it introduces and other
bindings.  (Think about different colors for bindings introduced by the
macro and other bindings.)  This is also true for other cases of scope
problems, which are harder to cope with otherwise (eg, there is no
`gensym' magic solution):

  (let ((if +))
    (orelse 1 1))

========================================================================

There was also the problem of making debugging difficult, because a
macro can introduce errors that are "coming out of nowhere".  In the
implementation that we work with, this is solved by the fact that the
objects that these transformations manipulate are not the plain Scheme
objects that we have used so far.  Instead, they are syntax objects,
which contain such a simple Scheme object in addition to source
information -- and this allows DrScheme to always point you at the
correct place that produced the erroneous code.

Finally, there was the problem of the fact that macros are easy to get
wrong, like evaluating expressions twice where you don't need to.  This
problem has no automatic solution, because there is no way to know
whether you want to evaluate an expression twice or not -- furthermore,
evaluating it forces the same eager semantics as all function calls,
which is not what we want -- the macro writer is the one who decides
what gets evaluated and when.

========================================================================

Quick note: the above is all fine in lots of common cases, but some
times there are more "exotic" situations, for example, what if we *want*
to capture an identifier?  (PLT) Scheme does have a solution for that,
although that is a little more involved:

  (define-syntax (if-it stx)
    (syntax-case stx (if-it)
      [(if-it cond expr1 expr2)
       (with-syntax ([it (datum->syntax-object stx 'it stx)])
         (syntax
           (let ([it cond])
             (if it expr1 expr2))))]))

  (if-it (member 1 '(0 1 2 3 4)) (car it) 999)

so we will not get into this.

========================================================================
>>> Using Lazy Constructions in an Eager Language

(Not really lazy evaluation, but close.)

  (define-syntax cons-stream
    (syntax-rules ()
      [(cons-stream x y) (cons x (lambda () y))]))
  (define stream? pair?)
  (define null-stream null)
  (define null-stream? null?)
  (define stream-car car)
  (define (stream-cdr s) ((cdr s)))

Using it:

  (define ones (cons-stream 1 ones))
  (define (stream-map f s)
    (if (null-stream? s)
      null-stream
      (cons-stream (f (stream-car s))
                   (stream-map f (stream-cdr s1)))))
  (define (stream-map2 f s1 s2)
    (if (null-stream? s1)
      null-stream
      (cons-stream (f (stream-car s1) (stream-car s2))
                   (stream-map2 f (stream-cdr s1) (stream-cdr s2)))))
  (define ints (cons-stream 0 (stream-map2 + ones ints)))

Generalizing the laziness:

  (define-type promise
    [make-promise (thunk procedure?)])

  (define-syntax delay
    (syntax-rules ()
      [(delay expr) (make-promise (lambda () expr))]))

  (define (force p)
    (cases p
      [(make-promise thunk) (thunk)]))

========================================================================
>>> Recursive Macros

Syntax transformations can be recursive.  For example, we can implement
`let*' by translating it into a nested sequence of `let's:

  (define-syntax let*
    (syntax-rules ()
      [(let* () body ...)
       (let () body ...)]
      [(let* ((x1 v1) (x2 v2) ...) body ...)
       (let ((x1 v1)) (let* ((x2 v2) ...) body ...))]))

When Scheme expands a `let*' expression, the result may contain a new
`let*' which needs extending as well.  An important implication of this
is that recursive macros are fine, as long as the recursive case is
using a `smaller' expression.  This is just like any form of recursion
(or loop), where there needs to be something `well-founded' -- some
value that incrementally advances towards some base case.

For example, consider the following macro:

  (define-syntax while
    (syntax-rules ()
      [(while condition body ...)
       (when condition
         body ...
         (while condition body ...))]))

It seems like this is a good implementation of a `while' loop, but look
at the nested `while' -- it is exactly the same as the input template,
therefore this macro expands to infinite code!  The problem is that the
recursive use of the macro has exactly the same parts -- so the
expansion process will never stop.  Compare that, for example, to the
`let*' rule where the recursive use always has one less binding.

This is in contrast, for example, to using a function:

  (define (while condition-thunk body-thunk)
    (if (condition-thunk)
      (begin (body-thunk) (while condition-thunk body-thunk))
      'done))

Things would be fine in this case, since the recursive call is not done
if the condition is false, and the body is expected to have some side
effect that gets the program closer to a false condition, or we end up
in an infinite loop -- but this is all changes in run-time values.  But
in the macro case there is no evaluation happening, if the transformed
syntax contains the same input pattern, we end up having a macro that
expands to an infinite body.

The correct solution for a `while' macro is therefore to use plain
recursion using a local recursive function:

  (define-syntax while
    (syntax-rules ()
      [(while condition body ...)
       (letrec ([loop (lambda ()
                        (when condition
                          body ...
                          (loop)))])
         (loop))]))

========================================================================

Another example: a simple loop.

This is the code for a simple arithmetic loop:

  (define-syntax for
    (syntax-rules (= to do)
      [(for x = m to n do body ...)
       (letrec ([loop (lambda (x)
                        (when (<= x n)
                          body ...
                          (loop (+ x 1))))])
         (loop m))]))

(Note that this is not complete, it suffers from the usual problem of
multiple evaluations of the `n' expression.)  This use of `syntax-rules'
has a few names in the first argument of `syntax-rules' -- the problem
is that we want to specify that `=', `to', and `do' are keywords that
are part of the syntax, not pattern variables like `x', `n', `m' and
`body ...'.  The resulting pattern transformer will not allow forms that
do not use these keywords in the right places.

Note that the transformed code is what provides us with the semantics of
the "new" special form.  For example, it means that in:

  (for x = n to m do body ...)

the `x' is a binding instance, and that its scope covers the body
expressions.  Also, you can see that the value returned for the whole
`for' expression is whatever the value of `(if #f ...)' is (which
happens to be that special value that is not printed out).  In addition,
nested usages of this macro works like you intend them to work, for
example:

  (for a = 1 to 9 do
    (for b = 1 to 9 do (printf "~s,~s " a b))
    (newline))

Extensions of this syntax are very simple -- for example, say we want to
extend it to have a `step' optional keyword.  The standard idiom is to
have the step-less pattern translated into one that uses `step 1':

  (for x = m to n do body ...)
  --> (for x = m to n step 1 do body ...)

Usually, you should remember that `syntax-rules' tries the patterns one
by one until a match is found, but in this case there is no problems
because the keywords makes it unambiguous:

  (define-syntax for
    (syntax-rules (= to step do)
      [(for x = m to n do body ...)
       (for x = m to n step 1 do body ...)]
      [(for x = m to n step s do body ...)
       (letrec ([loop (lambda (x)
                        (when (<= x n)
                          body ...
                          (loop (+ x s))))])
         (loop m))]))

========================================================================
>>> Some conclusions

Macros are extremely powerful, but this also means that their usage
should be restricted only to situations where they are needed.  You can
view any function as extending the current collection of tools, so when
you read code, every function basically adds an additional verb to your
function, and every global variable adds a noun.  But macros add
different rules for reading, since using them might result in a
completely different evaluation.  Because of this, adding macros makes
code harder to read and debug -- and using them should be done in a way
that is as clear as possible for users.

When should a macro be used?

* Providing cosmetics: eliminating some annoying repetitiveness and/or
  inconvenient verbosity.  This is usually macros that are intended to
  beautify code, for example, we could use a macro to make this bit of
  the Sloth source:

            (list '+ (box (scheme-func->prim-val + #t)))
            (list '- (box (scheme-func->prim-val - #t)))
            (list '* (box (scheme-func->prim-val * #t)))

  look much better, by using a macro instead of the above.  (If we use a
  function, we still need two inputs for each call -- the name and the
  procedure.)

* Altering the order of evaluation: as seen with the `orelse' macro, we
  can control evaluation order in our macro.  This is achieved by
  translating the macro into Scheme code with a known evaluation order.
  We even choose not to evaluate some parts, or evaluate some parts
  multiple times (eg, the `for' macro).

  Note that by itself, we could get this if only we had a more
  light-weight notation for thunks, since then we could simply use
  functions.  For example, a `while' function could easily be used with
  thunks:

    (define (while cond body)
      (when (cond)
        (body)
        (while cond body)))

  if the syntax for a thunk would be as easy as, for example, using
  curly braces:

    (let ([i 0])
      (while { (< i 10) }
        { (printf "i = ~s\n" i) (set! i (+ i 1)) }))

* Introducing binding constructs: macros that have a different binding
  structure from Scheme's.  These kind of macros are ones that makes a
  powerful language -- for example, we've seen how we can survive
  without basic built-ins like `let'.  For example, the `for' macro has
  it's own binding structure.

* Defining data languages: macros can be used for expressions that are
  not Scheme expressions themselves.  For example, the parens that wrap
  binding pairs in a `let' form are not function applications.  Some
  times it is possible to use quotes for that, but then we get run-time
  values rather than being able to translate them into Scheme code.
  Another usage of this category is to hide representation details that
  might involve implicit lambda's (for example, `delay') -- if we define
  a macro, then there is a single point where we control whether an
  expression is used within some `lambda' -- but it it was a function,
  we'd have to change every usage of it to add an explicit lambda.

It is also important to note that macros should not be used too
frequently.  As said above, every macro adds a completely different way
of reading your code -- a way that doesn't use the usual "nouns" and
"verbs", but there are other reasons not to use a macro.

One common usage is as an optimization -- trying to avoid an extra
function call.  For example, this:

  int min(int x, int y) {
    if ( x < y ) then return x; else return y;
  }

might seem wasteful if you don't want a full function call on every
usage of `min'.  So you might be tempted to use this instead:

  #define min(x,y) x<y ? x : y

you even know the pitfalls of C macros so you make it more robust:

  #define min(x,y) (((x)<(y)) ? (x) : (y))

But small functions like the above are things that any decent compiler
should know how to optimize, and even if your compiler doesn't, it's
still not worth doing this optimization because programmer time is the
most expensive factor in any computer system.  In addition, a compiler
is committed to doing these optimizations only when possible (eg, it is
not possible to in-line a recursive function) and to do proper in-lining
-- unlike the `min' CPP macro above which is erroneous in case `x' or
`y' are expressions that have side-effects.

========================================================================
>>> Sidenote: why macros are so difficult in other languages?

Macros are an extremely powerful tool in Scheme (and other languages in
the Lisp family) -- how come nobody else uses them?

Well, people have tried to use them in many contexts.  The problem is
that you cannot get away with a simple solution that does nothing more
than textual manipulation of your programs.  For example, the standard C
preprocessor is a macro language, but it is fundamentally limited to
very simple situations.  This is still a hot topic these days, with
modern languages trying out different solutions (or giving up and
claiming that all macros are evil).

Here is an example that was written by Mark Jason Dominus ("Higher Order
Perl": you might write the following macro:

  #define square(x) x*x

which doesn't work because

  2/square(10)

expands to

        2/10*10

which is 2, but you wanted 0.02.  So you need this instead:

  #define square(x) (x*x)

but this breaks because

  square(1+1)

expands to

  (1+1*1+1)

which is 3, but you wanted 4.  So you need this instead:

  #define square(x) ((x)*(x))

But what about

  x = 2;
  square(x++)

which expands to

        ((x++)*(x++))

?  (This actually works in GCC).  So you need this instead:

  int MYTMP;
  #define square(x) (MYTMP = (x), MYTMP*MYTMP)

but now it only works for ints; you can't do square(3.5) any more.  To
really fix this you have to use nonstandard extensions, something
like:

  #define square(x) ({typedef xtype = x; xtype xval = x; xval*xval; })

And that's just to get trivial macros, like "square()", to work.

========================================================================

You should be able to appreciate the tremendous power of macros now.
This is why there are so many "primitive features" of programming
languages that can be considered as merely library functionality.  For
example, people are used to think about OOP as some inherent property of
a language -- but in PLT Scheme there are at least two very different
object systems, both implemented as a library which provides the
functionality as well as the necessary syntax in the form of macros.
The basic principle is to have a small core language with powerful
constructs, and make it easy to express complex ideas using these
constructs.

This is an important point to consider before starting a new DSL
(reminder: domain specific language) -- if you need something that looks
like a simple DSL but might grow to a full language, you can extend an
existing language with macros (like Scheme) to have the features you
want, and you will be able to use the full language if necessary.

========================================================================

Side note: the the principle of a powerful but simple code language and
easy extensions is not limited to using macros -- other factors are
involved, like first-class functions.  In fact, "first class"-ness can
help in many situations, for example: single inheritance + classes as
first-class values can be used instead of multiple inheritance.

========================================================================
>>> Types

In our Toy language implementation, there are certain situations that
are not covered.  For example,

  {< {+ 1 2} 3}

is not a problem, but

  {+ {< 1 2} 3}

will eventually use Scheme's addition function on a boolean value, which
will crash our evaluator.  Assuming that we go back to the simple
language we once had, where there were no booleans, we can still run
into errors -- except now these are the errors that our code raises:

  {+ {fun {} 1} 2}

or

  {1 2 3}

In any case, it would be good to avoid such errors right from the start
-- it seems like we should be able to identify such bad code and not
even try to run it.  One thing that we can do is do a little more work
at parse time, and declare the {1 2 3} program fragment as invalid.  We
can even try to forbid

  {bind {{x 1}} {x 2 3}}

in the same way, but what should we do with this? --

  {fun {x} {x 2 3}}

The validity of this depends on how it is used.  The same goes for some
invalid expressions -- the above bogus expression can be fine if it's in
a context that shadows `<':

  {bind {{< *}}
    {+ {< 1 2} 3}}

Finally, consider this:

  {+ 3 {if <mystery> 5 {fun {x} x}}}

where mystery contains something like `random' or `read'.  In general,
knowing whether a piece of code will run with no errors is a problem
that is equivalent to the halting problem -- and because of this, there
is no way to create an "exact" type system: they are all either too
restrictive (rejecting programs that would run with no errors) or too
permissive (accepting programs that might crash).  This is a very
practical issue -- type safety means a lot less bugs in the system.  A
good type system is still an actively researched problem.

========================================================================
>>> What is a Type?

A type is any property of a program (or an expression) that can be
determined without running the program.  (This is different than what is
considered a `type' in Scheme which is a property that is known only at
run-time, which means that before run-time we know nothing so in essence
we have a single type (in the static sense).)  Specifically, we want to
use types in a way that predicts some aspects of the program's behavior,
for example, whether a program will crash.

Usually, types are being used as the kind of value that an expression
can evaluate to, not the precise value itself.  For example, we might
have two kinds of values -- functions and numbers, and we know that
addition always operates on numbers, therefore

  {+ 1 {fun {x} x}}

is a type error.  Note that to determine this we don't care about the
actual function, just the fact that it is a function.

Important: types can discriminate certain programs as invalid, but they
cannot discriminate correct programs from incorrect ones.  For example,
there is no way for any type system to know that this:

  {fun {x} {+ x 1}}

is an incorrect decrease-by-one function.

In general, type systems try to get to the optimal point where as much
information as possible is known, yet the language is not too
restricted, no significant computing resources are wasted, and
programmers don't spend much time annotating their code.

Why would you want to use a type system?

* They help reduce the time spent on debugging (when they detect
  legitimate errors, rather than force you to change your code).

* Catch errors even in code that you don't execute, for example, when
  your tests are too weak (but they do *not* substitute proper test
  suites).

* As we have seen, they help in documenting code (but they do *not*
  substitute proper documentation).

* Compilers can use type information to make programs run much faster.

* They encourage more organized code (for example, our use of
  `define-type' and `cases' helps in writing code; these two constructs
  are inspired by ML).

========================================================================
>>> What are Our Types?

The first thing we need to do is to agree on what types are.  Earlier,
we talked about two types: numbers and functions (ignore booleans or
anything else for now), we will use these two types for now.

A type system is presented as a collection of rules called "type
judgments", which describe how to determine the type of an expression.
Beside the types and the judgments, a type system specification needs a
(decidable) algorithm that can assign types to expressions.

Such a specification should have one rule for every kind of syntactic
construct, so when we get a program we can determine the precise type of
any expression.  Also, these judgments are usually recursive since a
type judgment will almost always rely on the types of sub-expressions
(if any).

For our restricted system, we have two rules (=judgments) that we can
easily specify:

  n : number  (any numeral `n' is a number)
  {fun {x} E} : function

And what about an identifier?  Well, it is clear that we need to keep
some form of an environment that will keep an account of types assigned
to identifiers (note: all of this is not at run-time).  This environment
is used in all type judgments, and usually written as gamma (use G in
this text).  The conventional way to write the two rules above is:

  G |- n : number
  G |- {fun {x} E} : function

The first one is read as "gamma proves that `n' has the type `number'".
Note that this is a syntactic environment, much like DE-ENVs that you
have seen in homework.

So, we can write a rule for identifiers that simply has the type
assigned by the environment:

  G |- x : G(x)

We now need a rule for addition and a rule for application (note: we're
using a very limited subset of our old language, where arithmetic
operators are not function applications).  Addition is easy: if we can
prove that both `a' and `b' are numbers in some environment G, then we
know that `{+ a b}' is a number in the same environment.  We write this
as follows:

  G |- a : number   G |- b : number
  ---------------------------------
        G |- {+ a b} : number

Now, what about application?

  G |- f : function   G |- v : t_a   (use `t' for `tau', usual for
  --------------------------------    unknown types)
       G |- {call f v} : ???

that is -- if we can prove that `f' is a function, and that `v' is a
value of some type `t_a', then ... ???  Well, we need to know more about
`f': we need to know what type it consumes and what type it returns.  So
a simple `function' is not enough -- we need some sort of a function
type that specifies both input and output types.  We will use the
notation that was seen throughout the semester and dump `function'.  Now
we can write:

  G |- f : (t1 -> t2)  G |- v : t1
  --------------------------------
        G |- {call f v} : t2

which makes sense -- if you take a function of type `t1->t2' and you
feed it what it expects, you get the obvious output type.  But going
back to the language -- where do we get these new arrow types from?  We
will modify the language and require that every function specifies its
input and output type (and assume we have only one argument functions).
For example, we will write something like this for a function that is
the curried version of addition:

  {fun {x : number} : (number -> number)
    {fun {y : number} : number
      {+ x y}}}

So: the revised syntax for the limited language that contains only
additions, applications and single-argument functions, and for fun -- go
back to using the `call' keyword is.  The syntax we get is:

  <PICKY> ::= <num>
            | <id>
            | { fun { <id> : <TYPE> } : <TYPE> <PICKY> }
            | { + <PICKY> <PICKY> }
            | { call <PICKY> <PICKY> }

  <TYPE>  ::= number
            | ( <TYPE> -> <TYPE> )

and the typing rules are:

  G |- n : number

  G |- {fun {x : t1} : t2 E} : (t1 -> t2)

  G |- x : G(x)

  G |- a : number   G |- b : number
  ---------------------------------
        G |- {+ a b} : number

  G |- f : (t1 -> t2)  G |- v : t1
  --------------------------------
        G |- {call f v} : t2

But we're still missing a big part -- the current rule for a `fun'
expression is too weak, it does not allow us to conclude that this
expression:

  {fun {x : number} : (number -> number)
    3}

is invalid.  Instead, it will make us think that this program:

  {call {call {fun {x : number} : (number -> number)
                3}
              5}
        7}

is valid, and should return a number.  What's missing?  We need to check
that the body part of the function is correct, so the rule for typing a
`fun' is no longer a simple one.  Here is how we check the body instead
of blindly believing program annotations:

            G[x:=t1] |- E : t2
  ---------------------------------------
  G |- {fun {x : t1} : t2 E} : (t1 -> t2)

That is -- we want to make sure that if `x' has type `t1', then the body
expression `E' has type `t2', and if we can prove this, then we can
trust these annotations.

There is an important relationship between this rule and the `call' rule
for application: in this rule we assume that the input will have the
right type and guarantee (by a proof) that the output will have the
right type.  In the application rule, we guarantee (by a proof) an input
of the right type and assume a result of the right type.

Note that, as we said, `number' is really just a property of a certain
kind of values, we don't know exactly what numbers are actually used.
In the same way, the arrow function types don't tell us exactly what
function it is, for example, `(number -> number)' can indicate a
function that adds three to its argument, subtracts seven, or multiplies
it by 7619.  But it certainly contains much more than the previous naive
`function' type.

For reference, here is the complete BNF and typing rules:

  --------------------------------------------------------------------

    <PICKY> ::= <num>
              | <id>
              | { fun { <id> : <TYPE> } : <TYPE> <PICKY> }
              | { + <PICKY> <PICKY> }
              | { call <PICKY> <PICKY> }

    <TYPE>  ::= number
              | ( <TYPE> -> <TYPE> )

    G |- n : number

    G |- x : G(x)

    G |- a : number   G |- b : number
    ---------------------------------
          G |- {+ a b} : number

              G[x:=t1] |- E : t2
    ---------------------------------------
    G |- {fun {x : t1} : t2 E} : (t1 -> t2)

    G |- f : (t1 -> t2)  G |- v : t1
    --------------------------------
          G |- {call f v} : t2

  --------------------------------------------------------------------

========================================================================

Examples of using types (abbreviate `number' as `num'):

                  {} |- 5 : num   {} |- 7 : num
  {} |- 2 : num   -----------------------------
                       {} |- {+ 5 7} : num
  ---------------------------------------------
            {} |- {+ 2 {+ 5 7}} : num

     [x:=num] |- x : num   [x:=num] |- 3 : num
     -----------------------------------------
             [x:=num] |- {+ x 3} : num
  ------------------------------------------------   {} |- 5 : num
  {} |- {fun {x : num} : num {+ x 3}} : num -> num
  ----------------------------------------------------------------
         {} |- {call {fun {x : num} : num {+ x 3}} 5} : num

Finally, try a buggy program like

  {+ 3 {fun {x : number} : number x}}

and see where it is impossible to continue.

The main thing here is that to know that this is a type error, we have
to prove that there is no judgment for a certain type (in this case, any
way to prove that a `fun' expression has a `num' type), which we
(humans) can only do by inspecting all of the rules.  Because of this,
we need to also add an algorithm to our type system, one that we can
follow and determine when it gives up.

========================================================================
>>> Typing control

We will now extend our typed Picky language to have a conditional
expression, and predicates.  First, we extend the BNF with a predicate
expression, and we also need a type for the results:

  --------------------------------------------------------------------

    <PICKY> ::= <num>
              | <id>
              | { fun { <id> : <TYPE> } : <TYPE> <PICKY> }
              | { + <PICKY> <PICKY> }
              | { < <PICKY> <PICKY> }
              | { call <PICKY> <PICKY> }
              | { if <PICKY> <PICKY> <PICKY> }

    <TYPE>  ::= number
              | boolean
              | ( <TYPE> -> <TYPE> )

  --------------------------------------------------------------------

Initially, we use the same rules, and add the obvious type for the
predicate:

  G |- a : number   G |- b : number
  ---------------------------------
        G |- {< a b} : boolean

And what should the rule for `if' look like?  Well, to make sure that
the condition is a boolean, it should be something of this form:

  G |- c : boolean   G |- t : ???   G |- e : ???
  ----------------------------------------------
              G |- {if c t e} : ???

What would be the types of `t' and `e'?  A natural choice would be to
let the programmer use any two types:

  G |- c : boolean   G |- t : t1   G |- e : t2
  --------------------------------------------
             G |- {if c t e} : ???

But what would the return type be?  This is still a problem.  (BTW, some
kind of a union would be nice, but it has some strong implications that
we will not discuss.)  In addition, we will have a problem detecting
possible errors like:

  {+ 2 {if <mystery> 3 {fun {x} x}}}

Since we know nothing about the condition, we can just as well be
conservative and force both arms to have the same type.  The rule is
therefore:

  G |- c : boolean   G |- t : t   G |- e : t
  ------------------------------------------
           G |- {if c t e} : t

-- using the same letter indicates that we expect the types to be
identical, unlike the previous attempt.

========================================================================

In general, we can extend this language in one of two ways.  For
example, lets say that we want to add the `with' form.  One way to add
it is what we did above -- simply add it to the language, and write the
rule for it.  In this case, we get:

  G |- v : t1   G[x:=t1] |- E : t2
  --------------------------------
   G |- {with {x : t1 v} E} : t2

Note how this rule encapsulates information about the scope of `with'.
Also note that we need to specify the types for the bound values.

Another way to achieve this extension is if we add `with' as a derived
rule.  We know that when we see a

  {with {x v} E}

expression, we can just translate it into

  {call {fun {x} E} v}

So we could achieve this extension by using a rewrite rule to translate
all `with' expressions into `call's of anonymous functions (eg, using
the `with-stx' facility that we have seen recently).  This could be done
formally: begin with the `with' form, translate to the `call' form, and
finally show the necessary goals to prove its type.  The only thing to
be aware of is the need to translate the types too, and there is one
type that is missing from the typed-with version above -- the output
type of the function.  This is an indication that we don't really need
to specify function output types -- we can just deduce them from the
code.

========================================================================

Conclusion -- we've seen type judgment rules, and using them in proof
trees.  Note that in these trees there is a clear difference between
rules that have no preconditions -- there are axioms that are always
true (eg, a numeral is always of type `num').

The general way of proving a type seems similar to evaluation of an
expression, but there is a huge difference -- *nothing* is really
getting evaluated.  As an example, we always go into the body of a
function expression, which is done to get the function's type, and this
is later used anywhere this function is used -- when you evaluate this:

  {with {f {fun {x : num} : num x}}
    {+ {call f 1} {call f 2}}}

you first create a closure which means that you don't touch the body of
the function, and later you use it twice.  In contrast, when you prove
the type of this expression, you immediately go into the body of the
function which you have to do to prove that it has the expected
`num->num' type, and then you just use this type twice.

Finally, we have seen the importance of using the same type letters to
enforce types, and in the case of typing an `if' statement this had a
major role: specifying that the two arms can be any two types, or the
same type.

========================================================================
>>> Typing Recursion

We already know that without recursion life can be very boring...  So we
obviously want to be able to have recursive functions -- but the
question is how will they interact with our type system.  One thing that
we have seen is that by just having functions we get recursion.  This
was achieved by the Y combinator function.  It seems like the same
should apply to our simple typed language.  The core of the Y combinator
was using an expression similar to Omega that generates the infinite
loop that is needed.  In our language:

  {call {fun {x} {call x x}} {fun {x} {call x x}}}

This expression was impossible to evaluate completely since it never
terminates, but it served as a basis for the Y combinator.  Lets examine
its type: we begin with the internal function -- it is a function, so it
must have an arrow type, assume that the input type is t_i and the
output type is t_o:

  {fun {x} {call x x}} : t_i -> t_o

Now, the body of the function is `{call x x}', so `x' must be a function
itself, which means that t_i must also be an arrow type, say t_1->t_2
(a) for some t_1 and t_2, and the type of the whole function is now:

  t_i -> t_o  =  (t_1->t_2) -> t_o

What can we say about t_1?  Well, it is the input type of `x', but we
see that `x' is used with `x' as its input, therefore t_1 must be the
type of `x' (b) which is the argument for the function which is t_i.
What we get is:

  type-of(x) = t_1 -> t_2   (a)
  type-of(x) = t_1          (b)

and from this we get:

  => t_1 = t_1 -> t_2
         = (t_1 -> t_2) -> t_2
         = ((t_1 -> t_2) -> t_2) -> t_2
         = ...

And this is a type that does not exist in our type system, since we can
only have finite types.  Therefore, we have a proof by contradiction
that this expression cannot be typed in our system.

This is closely related to the fact that the typed language we have
described so far is "strongly normalizing": no matter what program you
write, it will always terminate!  To see this, very informally, consider
the language without functions -- this is clearly a function where all
programs terminate, since the only way to create a loop is through
function applications.  Now add functions and function application -- in
the typing rules for the resulting language, each `fun' creates a
function type (creates an arrow), and each function application consumes
a function type (deletes one arrow).

In the our language, therefore, the "halting problem" doesn't even
exist, since all programs (that are properly typed) are guaranteed to
halt.  This property is useful in many real-life situations (consider
firewall rules, configuration files, devices with embedded code).  But
the language that we get is very limited as a result -- we really want
the power to shoot our feet...

========================================================================
>>> Extending the typed language with recursion

As we have seen, our language is strongly normalizing, which means that
to get general recursion, we must introduce a new construct (unlike
previously, when we didn't really need one).  We can do this in the same
way as we did before -- add another explicit recursive binder, except
that instead of dealing with the complexity of `bindrec', we'll add
`rec' which can establish only a single binding (similar to the old
`with').

First, the new BNF:

  <PICKY> ::= <num>
            | <id>
            | { fun { <id> : <TYPE> } : <TYPE> <PICKY> }
            | { + <PICKY> <PICKY> }
            | { < <PICKY> <PICKY> }
            | { call <PICKY> <PICKY> }
            | { if <PICKY> <PICKY> <PICKY> }
            | { rec { <id> : <TYPE> <PICKY> } <PICKY> }

  <TYPE>  ::= number
            | boolean
            | ( <TYPE> -> <TYPE> )

We now need to add a typing judgment for `rec' expressions.  What should
it look like?

              ???
  ----------------------------
  G |- {rec {x : t_x v} E} : t

`rec' is similar to all the other local binding forms, like `with', it
can be seen as a combination of a function and an application.  So we
need to check the two things that those rules checked -- first, check
that the body expression has the right type assuming that the type
annotation given to `x' is valid:

    G[x:=t_x] |- E : t   ???
  ----------------------------
  G |- {rec {x : t_x v} E} : t

Now, we also want to add the other side -- making sure that the t_x type
annotation is valid:

  G[x:=t_x] |- E : t   G |- v : t_x
  ---------------------------------
    G |- {rec {x : t_x v} E} : t

But that will not be possible in general -- `v' is an expression that
can include `x' itself -- that's the whole point.  The conclusion is
that we should use a similar trick to the one that we used to specify
evaluation of recursive binders -- the same environment is used for both
the named expression and for the body expression:

  G[x:=t_x] |- E : t   G[x:=t_x] |- v : t_x
  -----------------------------------------
        G |- {rec {x : t_x v} E} : t

========================================================================
>>> Conclusion

Some stuff we never got to talk about:

* Polymorphic functions, Different choices for type systems.
  (Scheme vs ML & Java vs C & Assembly)

* Name-spaces.
  (modules, separate linking, oop etc)

* Object systems implemented as functions.

* MOP.

* Continuations.

* Logic programming.
  (example with append)

* Reactive programming.
  (example with seconds)

========================================================================
;; Local variables:
;; fill-column: 72
;; hide-local-variable-section: t
;; eval:(add-color-pattern "^=\\{72\\}\n" '*/blue4)
;; eval:(add-color-pattern "^ *>>>.*\n" 'yellow/red4-bold 0 t)
;; End:
